
/**
 * Client
**/

import * as runtime from './runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model User
 * 
 */
export type User = $Result.DefaultSelection<Prisma.$UserPayload>
/**
 * Model Project
 * 
 */
export type Project = $Result.DefaultSelection<Prisma.$ProjectPayload>
/**
 * Model ProjectMember
 * 
 */
export type ProjectMember = $Result.DefaultSelection<Prisma.$ProjectMemberPayload>
/**
 * Model ProjectUpdate
 * 
 */
export type ProjectUpdate = $Result.DefaultSelection<Prisma.$ProjectUpdatePayload>
/**
 * Model Media
 * 
 */
export type Media = $Result.DefaultSelection<Prisma.$MediaPayload>
/**
 * Model Payment
 * 
 */
export type Payment = $Result.DefaultSelection<Prisma.$PaymentPayload>
/**
 * Model Notification
 * 
 */
export type Notification = $Result.DefaultSelection<Prisma.$NotificationPayload>
/**
 * Model NotificationPreference
 * 
 */
export type NotificationPreference = $Result.DefaultSelection<Prisma.$NotificationPreferencePayload>
/**
 * Model Milestone
 * 
 */
export type Milestone = $Result.DefaultSelection<Prisma.$MilestonePayload>
/**
 * Model ChecklistItem
 * 
 */
export type ChecklistItem = $Result.DefaultSelection<Prisma.$ChecklistItemPayload>
/**
 * Model Inspection
 * 
 */
export type Inspection = $Result.DefaultSelection<Prisma.$InspectionPayload>
/**
 * Model InspectionResponse
 * 
 */
export type InspectionResponse = $Result.DefaultSelection<Prisma.$InspectionResponsePayload>
/**
 * Model Query
 * 
 */
export type Query = $Result.DefaultSelection<Prisma.$QueryPayload>
/**
 * Model QueryResponse
 * 
 */
export type QueryResponse = $Result.DefaultSelection<Prisma.$QueryResponsePayload>
/**
 * Model AuditLog
 * 
 */
export type AuditLog = $Result.DefaultSelection<Prisma.$AuditLogPayload>
/**
 * Model Material
 * 
 */
export type Material = $Result.DefaultSelection<Prisma.$MaterialPayload>

/**
 * Enums
 */
export namespace $Enums {
  export const Role: {
  SUPER_ADMIN: 'SUPER_ADMIN',
  ADMIN: 'ADMIN',
  PROJECT_MANAGER: 'PROJECT_MANAGER',
  SITE_ENGINEER: 'SITE_ENGINEER',
  CLIENT: 'CLIENT'
};

export type Role = (typeof Role)[keyof typeof Role]


export const ProjectStatus: {
  PLANNED: 'PLANNED',
  IN_PROGRESS: 'IN_PROGRESS',
  ON_HOLD: 'ON_HOLD',
  COMPLETED: 'COMPLETED'
};

export type ProjectStatus = (typeof ProjectStatus)[keyof typeof ProjectStatus]


export const ProjectMemberRole: {
  PROJECT_MANAGER: 'PROJECT_MANAGER',
  SITE_ENGINEER: 'SITE_ENGINEER'
};

export type ProjectMemberRole = (typeof ProjectMemberRole)[keyof typeof ProjectMemberRole]


export const MediaType: {
  INSPECTION_IMAGE: 'INSPECTION_IMAGE',
  RECEIPT: 'RECEIPT',
  DRAWING: 'DRAWING',
  QUERY_ATTACHMENT: 'QUERY_ATTACHMENT'
};

export type MediaType = (typeof MediaType)[keyof typeof MediaType]


export const PaymentStatus: {
  PENDING: 'PENDING',
  PARTIAL: 'PARTIAL',
  PAID: 'PAID',
  OVERDUE: 'OVERDUE'
};

export type PaymentStatus = (typeof PaymentStatus)[keyof typeof PaymentStatus]


export const PaymentCategory: {
  MATERIAL: 'MATERIAL',
  LABOR: 'LABOR',
  CONTRACTOR: 'CONTRACTOR',
  OTHER: 'OTHER'
};

export type PaymentCategory = (typeof PaymentCategory)[keyof typeof PaymentCategory]


export const MaterialStatus: {
  ORDERED: 'ORDERED',
  DELIVERED: 'DELIVERED',
  USED: 'USED'
};

export type MaterialStatus = (typeof MaterialStatus)[keyof typeof MaterialStatus]


export const NotificationPriority: {
  LOW: 'LOW',
  NORMAL: 'NORMAL',
  HIGH: 'HIGH',
  CRITICAL: 'CRITICAL'
};

export type NotificationPriority = (typeof NotificationPriority)[keyof typeof NotificationPriority]


export const ChecklistResult: {
  PASS: 'PASS',
  FAIL: 'FAIL',
  NA: 'NA'
};

export type ChecklistResult = (typeof ChecklistResult)[keyof typeof ChecklistResult]


export const InspectionStatus: {
  DRAFT: 'DRAFT',
  SUBMITTED: 'SUBMITTED',
  REVIEWED: 'REVIEWED'
};

export type InspectionStatus = (typeof InspectionStatus)[keyof typeof InspectionStatus]


export const QueryStatus: {
  OPEN: 'OPEN',
  IN_PROGRESS: 'IN_PROGRESS',
  RESOLVED: 'RESOLVED'
};

export type QueryStatus = (typeof QueryStatus)[keyof typeof QueryStatus]


export const QueryPriority: {
  LOW: 'LOW',
  MEDIUM: 'MEDIUM',
  HIGH: 'HIGH',
  URGENT: 'URGENT'
};

export type QueryPriority = (typeof QueryPriority)[keyof typeof QueryPriority]

}

export type Role = $Enums.Role

export const Role: typeof $Enums.Role

export type ProjectStatus = $Enums.ProjectStatus

export const ProjectStatus: typeof $Enums.ProjectStatus

export type ProjectMemberRole = $Enums.ProjectMemberRole

export const ProjectMemberRole: typeof $Enums.ProjectMemberRole

export type MediaType = $Enums.MediaType

export const MediaType: typeof $Enums.MediaType

export type PaymentStatus = $Enums.PaymentStatus

export const PaymentStatus: typeof $Enums.PaymentStatus

export type PaymentCategory = $Enums.PaymentCategory

export const PaymentCategory: typeof $Enums.PaymentCategory

export type MaterialStatus = $Enums.MaterialStatus

export const MaterialStatus: typeof $Enums.MaterialStatus

export type NotificationPriority = $Enums.NotificationPriority

export const NotificationPriority: typeof $Enums.NotificationPriority

export type ChecklistResult = $Enums.ChecklistResult

export const ChecklistResult: typeof $Enums.ChecklistResult

export type InspectionStatus = $Enums.InspectionStatus

export const InspectionStatus: typeof $Enums.InspectionStatus

export type QueryStatus = $Enums.QueryStatus

export const QueryStatus: typeof $Enums.QueryStatus

export type QueryPriority = $Enums.QueryPriority

export const QueryPriority: typeof $Enums.QueryPriority

/**
 * ##  Prisma Client ʲˢ
 *
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Users
 * const users = await prisma.user.findMany()
 * ```
 *
 *
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  const U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   *
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Users
   * const users = await prisma.user.findMany()
   * ```
   *
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): PrismaClient;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb<ClientOptions>, ExtArgs, $Utils.Call<Prisma.TypeMapCb<ClientOptions>, {
    extArgs: ExtArgs
  }>>

      /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.UserDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.project`: Exposes CRUD operations for the **Project** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Projects
    * const projects = await prisma.project.findMany()
    * ```
    */
  get project(): Prisma.ProjectDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.projectMember`: Exposes CRUD operations for the **ProjectMember** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ProjectMembers
    * const projectMembers = await prisma.projectMember.findMany()
    * ```
    */
  get projectMember(): Prisma.ProjectMemberDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.projectUpdate`: Exposes CRUD operations for the **ProjectUpdate** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ProjectUpdates
    * const projectUpdates = await prisma.projectUpdate.findMany()
    * ```
    */
  get projectUpdate(): Prisma.ProjectUpdateDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.media`: Exposes CRUD operations for the **Media** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Media
    * const media = await prisma.media.findMany()
    * ```
    */
  get media(): Prisma.MediaDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.payment`: Exposes CRUD operations for the **Payment** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Payments
    * const payments = await prisma.payment.findMany()
    * ```
    */
  get payment(): Prisma.PaymentDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.notification`: Exposes CRUD operations for the **Notification** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Notifications
    * const notifications = await prisma.notification.findMany()
    * ```
    */
  get notification(): Prisma.NotificationDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.notificationPreference`: Exposes CRUD operations for the **NotificationPreference** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more NotificationPreferences
    * const notificationPreferences = await prisma.notificationPreference.findMany()
    * ```
    */
  get notificationPreference(): Prisma.NotificationPreferenceDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.milestone`: Exposes CRUD operations for the **Milestone** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Milestones
    * const milestones = await prisma.milestone.findMany()
    * ```
    */
  get milestone(): Prisma.MilestoneDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.checklistItem`: Exposes CRUD operations for the **ChecklistItem** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ChecklistItems
    * const checklistItems = await prisma.checklistItem.findMany()
    * ```
    */
  get checklistItem(): Prisma.ChecklistItemDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.inspection`: Exposes CRUD operations for the **Inspection** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Inspections
    * const inspections = await prisma.inspection.findMany()
    * ```
    */
  get inspection(): Prisma.InspectionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.inspectionResponse`: Exposes CRUD operations for the **InspectionResponse** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more InspectionResponses
    * const inspectionResponses = await prisma.inspectionResponse.findMany()
    * ```
    */
  get inspectionResponse(): Prisma.InspectionResponseDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.query`: Exposes CRUD operations for the **Query** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Queries
    * const queries = await prisma.query.findMany()
    * ```
    */
  get query(): Prisma.QueryDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.queryResponse`: Exposes CRUD operations for the **QueryResponse** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more QueryResponses
    * const queryResponses = await prisma.queryResponse.findMany()
    * ```
    */
  get queryResponse(): Prisma.QueryResponseDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.auditLog`: Exposes CRUD operations for the **AuditLog** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AuditLogs
    * const auditLogs = await prisma.auditLog.findMany()
    * ```
    */
  get auditLog(): Prisma.AuditLogDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.material`: Exposes CRUD operations for the **Material** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Materials
    * const materials = await prisma.material.findMany()
    * ```
    */
  get material(): Prisma.MaterialDelegate<ExtArgs, ClientOptions>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 6.14.0
   * Query Engine version: 717184b7b35ea05dfa71a3236b7af656013e1e49
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? P : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    User: 'User',
    Project: 'Project',
    ProjectMember: 'ProjectMember',
    ProjectUpdate: 'ProjectUpdate',
    Media: 'Media',
    Payment: 'Payment',
    Notification: 'Notification',
    NotificationPreference: 'NotificationPreference',
    Milestone: 'Milestone',
    ChecklistItem: 'ChecklistItem',
    Inspection: 'Inspection',
    InspectionResponse: 'InspectionResponse',
    Query: 'Query',
    QueryResponse: 'QueryResponse',
    AuditLog: 'AuditLog',
    Material: 'Material'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb<ClientOptions = {}> extends $Utils.Fn<{extArgs: $Extensions.InternalArgs }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], ClientOptions extends { omit: infer OmitOptions } ? OmitOptions : {}>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> = {
    globalOmitOptions: {
      omit: GlobalOmitOptions
    }
    meta: {
      modelProps: "user" | "project" | "projectMember" | "projectUpdate" | "media" | "payment" | "notification" | "notificationPreference" | "milestone" | "checklistItem" | "inspection" | "inspectionResponse" | "query" | "queryResponse" | "auditLog" | "material"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      User: {
        payload: Prisma.$UserPayload<ExtArgs>
        fields: Prisma.UserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findFirst: {
            args: Prisma.UserFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findMany: {
            args: Prisma.UserFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          create: {
            args: Prisma.UserCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          createMany: {
            args: Prisma.UserCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          delete: {
            args: Prisma.UserDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          update: {
            args: Prisma.UserUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          deleteMany: {
            args: Prisma.UserDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UserUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          upsert: {
            args: Prisma.UserUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          aggregate: {
            args: Prisma.UserAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUser>
          }
          groupBy: {
            args: Prisma.UserGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserCountArgs<ExtArgs>
            result: $Utils.Optional<UserCountAggregateOutputType> | number
          }
        }
      }
      Project: {
        payload: Prisma.$ProjectPayload<ExtArgs>
        fields: Prisma.ProjectFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ProjectFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ProjectFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectPayload>
          }
          findFirst: {
            args: Prisma.ProjectFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ProjectFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectPayload>
          }
          findMany: {
            args: Prisma.ProjectFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectPayload>[]
          }
          create: {
            args: Prisma.ProjectCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectPayload>
          }
          createMany: {
            args: Prisma.ProjectCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ProjectCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectPayload>[]
          }
          delete: {
            args: Prisma.ProjectDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectPayload>
          }
          update: {
            args: Prisma.ProjectUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectPayload>
          }
          deleteMany: {
            args: Prisma.ProjectDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ProjectUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ProjectUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectPayload>[]
          }
          upsert: {
            args: Prisma.ProjectUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectPayload>
          }
          aggregate: {
            args: Prisma.ProjectAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateProject>
          }
          groupBy: {
            args: Prisma.ProjectGroupByArgs<ExtArgs>
            result: $Utils.Optional<ProjectGroupByOutputType>[]
          }
          count: {
            args: Prisma.ProjectCountArgs<ExtArgs>
            result: $Utils.Optional<ProjectCountAggregateOutputType> | number
          }
        }
      }
      ProjectMember: {
        payload: Prisma.$ProjectMemberPayload<ExtArgs>
        fields: Prisma.ProjectMemberFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ProjectMemberFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectMemberPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ProjectMemberFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectMemberPayload>
          }
          findFirst: {
            args: Prisma.ProjectMemberFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectMemberPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ProjectMemberFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectMemberPayload>
          }
          findMany: {
            args: Prisma.ProjectMemberFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectMemberPayload>[]
          }
          create: {
            args: Prisma.ProjectMemberCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectMemberPayload>
          }
          createMany: {
            args: Prisma.ProjectMemberCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ProjectMemberCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectMemberPayload>[]
          }
          delete: {
            args: Prisma.ProjectMemberDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectMemberPayload>
          }
          update: {
            args: Prisma.ProjectMemberUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectMemberPayload>
          }
          deleteMany: {
            args: Prisma.ProjectMemberDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ProjectMemberUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ProjectMemberUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectMemberPayload>[]
          }
          upsert: {
            args: Prisma.ProjectMemberUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectMemberPayload>
          }
          aggregate: {
            args: Prisma.ProjectMemberAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateProjectMember>
          }
          groupBy: {
            args: Prisma.ProjectMemberGroupByArgs<ExtArgs>
            result: $Utils.Optional<ProjectMemberGroupByOutputType>[]
          }
          count: {
            args: Prisma.ProjectMemberCountArgs<ExtArgs>
            result: $Utils.Optional<ProjectMemberCountAggregateOutputType> | number
          }
        }
      }
      ProjectUpdate: {
        payload: Prisma.$ProjectUpdatePayload<ExtArgs>
        fields: Prisma.ProjectUpdateFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ProjectUpdateFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectUpdatePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ProjectUpdateFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectUpdatePayload>
          }
          findFirst: {
            args: Prisma.ProjectUpdateFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectUpdatePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ProjectUpdateFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectUpdatePayload>
          }
          findMany: {
            args: Prisma.ProjectUpdateFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectUpdatePayload>[]
          }
          create: {
            args: Prisma.ProjectUpdateCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectUpdatePayload>
          }
          createMany: {
            args: Prisma.ProjectUpdateCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ProjectUpdateCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectUpdatePayload>[]
          }
          delete: {
            args: Prisma.ProjectUpdateDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectUpdatePayload>
          }
          update: {
            args: Prisma.ProjectUpdateUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectUpdatePayload>
          }
          deleteMany: {
            args: Prisma.ProjectUpdateDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ProjectUpdateUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ProjectUpdateUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectUpdatePayload>[]
          }
          upsert: {
            args: Prisma.ProjectUpdateUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectUpdatePayload>
          }
          aggregate: {
            args: Prisma.ProjectUpdateAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateProjectUpdate>
          }
          groupBy: {
            args: Prisma.ProjectUpdateGroupByArgs<ExtArgs>
            result: $Utils.Optional<ProjectUpdateGroupByOutputType>[]
          }
          count: {
            args: Prisma.ProjectUpdateCountArgs<ExtArgs>
            result: $Utils.Optional<ProjectUpdateCountAggregateOutputType> | number
          }
        }
      }
      Media: {
        payload: Prisma.$MediaPayload<ExtArgs>
        fields: Prisma.MediaFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MediaFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MediaPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MediaFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MediaPayload>
          }
          findFirst: {
            args: Prisma.MediaFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MediaPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MediaFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MediaPayload>
          }
          findMany: {
            args: Prisma.MediaFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MediaPayload>[]
          }
          create: {
            args: Prisma.MediaCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MediaPayload>
          }
          createMany: {
            args: Prisma.MediaCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.MediaCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MediaPayload>[]
          }
          delete: {
            args: Prisma.MediaDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MediaPayload>
          }
          update: {
            args: Prisma.MediaUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MediaPayload>
          }
          deleteMany: {
            args: Prisma.MediaDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MediaUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.MediaUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MediaPayload>[]
          }
          upsert: {
            args: Prisma.MediaUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MediaPayload>
          }
          aggregate: {
            args: Prisma.MediaAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMedia>
          }
          groupBy: {
            args: Prisma.MediaGroupByArgs<ExtArgs>
            result: $Utils.Optional<MediaGroupByOutputType>[]
          }
          count: {
            args: Prisma.MediaCountArgs<ExtArgs>
            result: $Utils.Optional<MediaCountAggregateOutputType> | number
          }
        }
      }
      Payment: {
        payload: Prisma.$PaymentPayload<ExtArgs>
        fields: Prisma.PaymentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PaymentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PaymentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>
          }
          findFirst: {
            args: Prisma.PaymentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PaymentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>
          }
          findMany: {
            args: Prisma.PaymentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>[]
          }
          create: {
            args: Prisma.PaymentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>
          }
          createMany: {
            args: Prisma.PaymentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PaymentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>[]
          }
          delete: {
            args: Prisma.PaymentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>
          }
          update: {
            args: Prisma.PaymentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>
          }
          deleteMany: {
            args: Prisma.PaymentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PaymentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PaymentUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>[]
          }
          upsert: {
            args: Prisma.PaymentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>
          }
          aggregate: {
            args: Prisma.PaymentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePayment>
          }
          groupBy: {
            args: Prisma.PaymentGroupByArgs<ExtArgs>
            result: $Utils.Optional<PaymentGroupByOutputType>[]
          }
          count: {
            args: Prisma.PaymentCountArgs<ExtArgs>
            result: $Utils.Optional<PaymentCountAggregateOutputType> | number
          }
        }
      }
      Notification: {
        payload: Prisma.$NotificationPayload<ExtArgs>
        fields: Prisma.NotificationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.NotificationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.NotificationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          findFirst: {
            args: Prisma.NotificationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.NotificationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          findMany: {
            args: Prisma.NotificationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>[]
          }
          create: {
            args: Prisma.NotificationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          createMany: {
            args: Prisma.NotificationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.NotificationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>[]
          }
          delete: {
            args: Prisma.NotificationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          update: {
            args: Prisma.NotificationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          deleteMany: {
            args: Prisma.NotificationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.NotificationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.NotificationUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>[]
          }
          upsert: {
            args: Prisma.NotificationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          aggregate: {
            args: Prisma.NotificationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateNotification>
          }
          groupBy: {
            args: Prisma.NotificationGroupByArgs<ExtArgs>
            result: $Utils.Optional<NotificationGroupByOutputType>[]
          }
          count: {
            args: Prisma.NotificationCountArgs<ExtArgs>
            result: $Utils.Optional<NotificationCountAggregateOutputType> | number
          }
        }
      }
      NotificationPreference: {
        payload: Prisma.$NotificationPreferencePayload<ExtArgs>
        fields: Prisma.NotificationPreferenceFieldRefs
        operations: {
          findUnique: {
            args: Prisma.NotificationPreferenceFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPreferencePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.NotificationPreferenceFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPreferencePayload>
          }
          findFirst: {
            args: Prisma.NotificationPreferenceFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPreferencePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.NotificationPreferenceFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPreferencePayload>
          }
          findMany: {
            args: Prisma.NotificationPreferenceFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPreferencePayload>[]
          }
          create: {
            args: Prisma.NotificationPreferenceCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPreferencePayload>
          }
          createMany: {
            args: Prisma.NotificationPreferenceCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.NotificationPreferenceCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPreferencePayload>[]
          }
          delete: {
            args: Prisma.NotificationPreferenceDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPreferencePayload>
          }
          update: {
            args: Prisma.NotificationPreferenceUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPreferencePayload>
          }
          deleteMany: {
            args: Prisma.NotificationPreferenceDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.NotificationPreferenceUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.NotificationPreferenceUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPreferencePayload>[]
          }
          upsert: {
            args: Prisma.NotificationPreferenceUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPreferencePayload>
          }
          aggregate: {
            args: Prisma.NotificationPreferenceAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateNotificationPreference>
          }
          groupBy: {
            args: Prisma.NotificationPreferenceGroupByArgs<ExtArgs>
            result: $Utils.Optional<NotificationPreferenceGroupByOutputType>[]
          }
          count: {
            args: Prisma.NotificationPreferenceCountArgs<ExtArgs>
            result: $Utils.Optional<NotificationPreferenceCountAggregateOutputType> | number
          }
        }
      }
      Milestone: {
        payload: Prisma.$MilestonePayload<ExtArgs>
        fields: Prisma.MilestoneFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MilestoneFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MilestonePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MilestoneFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MilestonePayload>
          }
          findFirst: {
            args: Prisma.MilestoneFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MilestonePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MilestoneFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MilestonePayload>
          }
          findMany: {
            args: Prisma.MilestoneFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MilestonePayload>[]
          }
          create: {
            args: Prisma.MilestoneCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MilestonePayload>
          }
          createMany: {
            args: Prisma.MilestoneCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.MilestoneCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MilestonePayload>[]
          }
          delete: {
            args: Prisma.MilestoneDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MilestonePayload>
          }
          update: {
            args: Prisma.MilestoneUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MilestonePayload>
          }
          deleteMany: {
            args: Prisma.MilestoneDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MilestoneUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.MilestoneUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MilestonePayload>[]
          }
          upsert: {
            args: Prisma.MilestoneUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MilestonePayload>
          }
          aggregate: {
            args: Prisma.MilestoneAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMilestone>
          }
          groupBy: {
            args: Prisma.MilestoneGroupByArgs<ExtArgs>
            result: $Utils.Optional<MilestoneGroupByOutputType>[]
          }
          count: {
            args: Prisma.MilestoneCountArgs<ExtArgs>
            result: $Utils.Optional<MilestoneCountAggregateOutputType> | number
          }
        }
      }
      ChecklistItem: {
        payload: Prisma.$ChecklistItemPayload<ExtArgs>
        fields: Prisma.ChecklistItemFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ChecklistItemFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChecklistItemPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ChecklistItemFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChecklistItemPayload>
          }
          findFirst: {
            args: Prisma.ChecklistItemFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChecklistItemPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ChecklistItemFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChecklistItemPayload>
          }
          findMany: {
            args: Prisma.ChecklistItemFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChecklistItemPayload>[]
          }
          create: {
            args: Prisma.ChecklistItemCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChecklistItemPayload>
          }
          createMany: {
            args: Prisma.ChecklistItemCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ChecklistItemCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChecklistItemPayload>[]
          }
          delete: {
            args: Prisma.ChecklistItemDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChecklistItemPayload>
          }
          update: {
            args: Prisma.ChecklistItemUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChecklistItemPayload>
          }
          deleteMany: {
            args: Prisma.ChecklistItemDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ChecklistItemUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ChecklistItemUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChecklistItemPayload>[]
          }
          upsert: {
            args: Prisma.ChecklistItemUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChecklistItemPayload>
          }
          aggregate: {
            args: Prisma.ChecklistItemAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateChecklistItem>
          }
          groupBy: {
            args: Prisma.ChecklistItemGroupByArgs<ExtArgs>
            result: $Utils.Optional<ChecklistItemGroupByOutputType>[]
          }
          count: {
            args: Prisma.ChecklistItemCountArgs<ExtArgs>
            result: $Utils.Optional<ChecklistItemCountAggregateOutputType> | number
          }
        }
      }
      Inspection: {
        payload: Prisma.$InspectionPayload<ExtArgs>
        fields: Prisma.InspectionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.InspectionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InspectionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.InspectionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InspectionPayload>
          }
          findFirst: {
            args: Prisma.InspectionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InspectionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.InspectionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InspectionPayload>
          }
          findMany: {
            args: Prisma.InspectionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InspectionPayload>[]
          }
          create: {
            args: Prisma.InspectionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InspectionPayload>
          }
          createMany: {
            args: Prisma.InspectionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.InspectionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InspectionPayload>[]
          }
          delete: {
            args: Prisma.InspectionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InspectionPayload>
          }
          update: {
            args: Prisma.InspectionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InspectionPayload>
          }
          deleteMany: {
            args: Prisma.InspectionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.InspectionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.InspectionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InspectionPayload>[]
          }
          upsert: {
            args: Prisma.InspectionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InspectionPayload>
          }
          aggregate: {
            args: Prisma.InspectionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateInspection>
          }
          groupBy: {
            args: Prisma.InspectionGroupByArgs<ExtArgs>
            result: $Utils.Optional<InspectionGroupByOutputType>[]
          }
          count: {
            args: Prisma.InspectionCountArgs<ExtArgs>
            result: $Utils.Optional<InspectionCountAggregateOutputType> | number
          }
        }
      }
      InspectionResponse: {
        payload: Prisma.$InspectionResponsePayload<ExtArgs>
        fields: Prisma.InspectionResponseFieldRefs
        operations: {
          findUnique: {
            args: Prisma.InspectionResponseFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InspectionResponsePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.InspectionResponseFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InspectionResponsePayload>
          }
          findFirst: {
            args: Prisma.InspectionResponseFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InspectionResponsePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.InspectionResponseFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InspectionResponsePayload>
          }
          findMany: {
            args: Prisma.InspectionResponseFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InspectionResponsePayload>[]
          }
          create: {
            args: Prisma.InspectionResponseCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InspectionResponsePayload>
          }
          createMany: {
            args: Prisma.InspectionResponseCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.InspectionResponseCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InspectionResponsePayload>[]
          }
          delete: {
            args: Prisma.InspectionResponseDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InspectionResponsePayload>
          }
          update: {
            args: Prisma.InspectionResponseUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InspectionResponsePayload>
          }
          deleteMany: {
            args: Prisma.InspectionResponseDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.InspectionResponseUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.InspectionResponseUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InspectionResponsePayload>[]
          }
          upsert: {
            args: Prisma.InspectionResponseUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InspectionResponsePayload>
          }
          aggregate: {
            args: Prisma.InspectionResponseAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateInspectionResponse>
          }
          groupBy: {
            args: Prisma.InspectionResponseGroupByArgs<ExtArgs>
            result: $Utils.Optional<InspectionResponseGroupByOutputType>[]
          }
          count: {
            args: Prisma.InspectionResponseCountArgs<ExtArgs>
            result: $Utils.Optional<InspectionResponseCountAggregateOutputType> | number
          }
        }
      }
      Query: {
        payload: Prisma.$QueryPayload<ExtArgs>
        fields: Prisma.QueryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.QueryFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QueryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.QueryFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QueryPayload>
          }
          findFirst: {
            args: Prisma.QueryFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QueryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.QueryFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QueryPayload>
          }
          findMany: {
            args: Prisma.QueryFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QueryPayload>[]
          }
          create: {
            args: Prisma.QueryCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QueryPayload>
          }
          createMany: {
            args: Prisma.QueryCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.QueryCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QueryPayload>[]
          }
          delete: {
            args: Prisma.QueryDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QueryPayload>
          }
          update: {
            args: Prisma.QueryUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QueryPayload>
          }
          deleteMany: {
            args: Prisma.QueryDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.QueryUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.QueryUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QueryPayload>[]
          }
          upsert: {
            args: Prisma.QueryUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QueryPayload>
          }
          aggregate: {
            args: Prisma.QueryAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateQuery>
          }
          groupBy: {
            args: Prisma.QueryGroupByArgs<ExtArgs>
            result: $Utils.Optional<QueryGroupByOutputType>[]
          }
          count: {
            args: Prisma.QueryCountArgs<ExtArgs>
            result: $Utils.Optional<QueryCountAggregateOutputType> | number
          }
        }
      }
      QueryResponse: {
        payload: Prisma.$QueryResponsePayload<ExtArgs>
        fields: Prisma.QueryResponseFieldRefs
        operations: {
          findUnique: {
            args: Prisma.QueryResponseFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QueryResponsePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.QueryResponseFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QueryResponsePayload>
          }
          findFirst: {
            args: Prisma.QueryResponseFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QueryResponsePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.QueryResponseFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QueryResponsePayload>
          }
          findMany: {
            args: Prisma.QueryResponseFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QueryResponsePayload>[]
          }
          create: {
            args: Prisma.QueryResponseCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QueryResponsePayload>
          }
          createMany: {
            args: Prisma.QueryResponseCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.QueryResponseCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QueryResponsePayload>[]
          }
          delete: {
            args: Prisma.QueryResponseDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QueryResponsePayload>
          }
          update: {
            args: Prisma.QueryResponseUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QueryResponsePayload>
          }
          deleteMany: {
            args: Prisma.QueryResponseDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.QueryResponseUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.QueryResponseUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QueryResponsePayload>[]
          }
          upsert: {
            args: Prisma.QueryResponseUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QueryResponsePayload>
          }
          aggregate: {
            args: Prisma.QueryResponseAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateQueryResponse>
          }
          groupBy: {
            args: Prisma.QueryResponseGroupByArgs<ExtArgs>
            result: $Utils.Optional<QueryResponseGroupByOutputType>[]
          }
          count: {
            args: Prisma.QueryResponseCountArgs<ExtArgs>
            result: $Utils.Optional<QueryResponseCountAggregateOutputType> | number
          }
        }
      }
      AuditLog: {
        payload: Prisma.$AuditLogPayload<ExtArgs>
        fields: Prisma.AuditLogFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AuditLogFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AuditLogFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          findFirst: {
            args: Prisma.AuditLogFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AuditLogFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          findMany: {
            args: Prisma.AuditLogFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>[]
          }
          create: {
            args: Prisma.AuditLogCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          createMany: {
            args: Prisma.AuditLogCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AuditLogCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>[]
          }
          delete: {
            args: Prisma.AuditLogDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          update: {
            args: Prisma.AuditLogUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          deleteMany: {
            args: Prisma.AuditLogDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AuditLogUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AuditLogUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>[]
          }
          upsert: {
            args: Prisma.AuditLogUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          aggregate: {
            args: Prisma.AuditLogAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAuditLog>
          }
          groupBy: {
            args: Prisma.AuditLogGroupByArgs<ExtArgs>
            result: $Utils.Optional<AuditLogGroupByOutputType>[]
          }
          count: {
            args: Prisma.AuditLogCountArgs<ExtArgs>
            result: $Utils.Optional<AuditLogCountAggregateOutputType> | number
          }
        }
      }
      Material: {
        payload: Prisma.$MaterialPayload<ExtArgs>
        fields: Prisma.MaterialFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MaterialFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MaterialPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MaterialFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MaterialPayload>
          }
          findFirst: {
            args: Prisma.MaterialFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MaterialPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MaterialFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MaterialPayload>
          }
          findMany: {
            args: Prisma.MaterialFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MaterialPayload>[]
          }
          create: {
            args: Prisma.MaterialCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MaterialPayload>
          }
          createMany: {
            args: Prisma.MaterialCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.MaterialCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MaterialPayload>[]
          }
          delete: {
            args: Prisma.MaterialDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MaterialPayload>
          }
          update: {
            args: Prisma.MaterialUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MaterialPayload>
          }
          deleteMany: {
            args: Prisma.MaterialDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MaterialUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.MaterialUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MaterialPayload>[]
          }
          upsert: {
            args: Prisma.MaterialUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MaterialPayload>
          }
          aggregate: {
            args: Prisma.MaterialAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMaterial>
          }
          groupBy: {
            args: Prisma.MaterialGroupByArgs<ExtArgs>
            result: $Utils.Optional<MaterialGroupByOutputType>[]
          }
          count: {
            args: Prisma.MaterialCountArgs<ExtArgs>
            result: $Utils.Optional<MaterialCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Shorthand for `emit: 'stdout'`
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events only
     * log: [
     *   { emit: 'event', level: 'query' },
     *   { emit: 'event', level: 'info' },
     *   { emit: 'event', level: 'warn' }
     *   { emit: 'event', level: 'error' }
     * ]
     * 
     * / Emit as events and log to stdout
     * og: [
     *  { emit: 'stdout', level: 'query' },
     *  { emit: 'stdout', level: 'info' },
     *  { emit: 'stdout', level: 'warn' }
     *  { emit: 'stdout', level: 'error' }
     * 
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
    /**
     * Global configuration for omitting model fields by default.
     * 
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   omit: {
     *     user: {
     *       password: true
     *     }
     *   }
     * })
     * ```
     */
    omit?: Prisma.GlobalOmitConfig
  }
  export type GlobalOmitConfig = {
    user?: UserOmit
    project?: ProjectOmit
    projectMember?: ProjectMemberOmit
    projectUpdate?: ProjectUpdateOmit
    media?: MediaOmit
    payment?: PaymentOmit
    notification?: NotificationOmit
    notificationPreference?: NotificationPreferenceOmit
    milestone?: MilestoneOmit
    checklistItem?: ChecklistItemOmit
    inspection?: InspectionOmit
    inspectionResponse?: InspectionResponseOmit
    query?: QueryOmit
    queryResponse?: QueryResponseOmit
    auditLog?: AuditLogOmit
    material?: MaterialOmit
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type CheckIsLogLevel<T> = T extends LogLevel ? T : never;

  export type GetLogType<T> = CheckIsLogLevel<
    T extends LogDefinition ? T['level'] : T
  >;

  export type GetEvents<T extends any[]> = T extends Array<LogLevel | LogDefinition>
    ? GetLogType<T[number]>
    : never;

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'updateManyAndReturn'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type UserCountOutputType
   */

  export type UserCountOutputType = {
    createdUsers: number
    managedProjects: number
    clientProjects: number
    projectMembers: number
    projectUpdates: number
    media: number
    paymentsCreated: number
    notifications: number
    projectsCreated: number
    inspections: number
    reviewedInspections: number
    queries: number
    queryResponses: number
    auditLogs: number
    materialsCreated: number
  }

  export type UserCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    createdUsers?: boolean | UserCountOutputTypeCountCreatedUsersArgs
    managedProjects?: boolean | UserCountOutputTypeCountManagedProjectsArgs
    clientProjects?: boolean | UserCountOutputTypeCountClientProjectsArgs
    projectMembers?: boolean | UserCountOutputTypeCountProjectMembersArgs
    projectUpdates?: boolean | UserCountOutputTypeCountProjectUpdatesArgs
    media?: boolean | UserCountOutputTypeCountMediaArgs
    paymentsCreated?: boolean | UserCountOutputTypeCountPaymentsCreatedArgs
    notifications?: boolean | UserCountOutputTypeCountNotificationsArgs
    projectsCreated?: boolean | UserCountOutputTypeCountProjectsCreatedArgs
    inspections?: boolean | UserCountOutputTypeCountInspectionsArgs
    reviewedInspections?: boolean | UserCountOutputTypeCountReviewedInspectionsArgs
    queries?: boolean | UserCountOutputTypeCountQueriesArgs
    queryResponses?: boolean | UserCountOutputTypeCountQueryResponsesArgs
    auditLogs?: boolean | UserCountOutputTypeCountAuditLogsArgs
    materialsCreated?: boolean | UserCountOutputTypeCountMaterialsCreatedArgs
  }

  // Custom InputTypes
  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCountOutputType
     */
    select?: UserCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountCreatedUsersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountManagedProjectsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProjectWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountClientProjectsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProjectWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountProjectMembersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProjectMemberWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountProjectUpdatesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProjectUpdateWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountMediaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MediaWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountPaymentsCreatedArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PaymentWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountNotificationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NotificationWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountProjectsCreatedArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProjectWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountInspectionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InspectionWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountReviewedInspectionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InspectionWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountQueriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: QueryWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountQueryResponsesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: QueryResponseWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountAuditLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AuditLogWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountMaterialsCreatedArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MaterialWhereInput
  }


  /**
   * Count Type ProjectCountOutputType
   */

  export type ProjectCountOutputType = {
    members: number
    updates: number
    media: number
    payments: number
    milestones: number
    inspections: number
    queries: number
    materials: number
    auditLogs: number
  }

  export type ProjectCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    members?: boolean | ProjectCountOutputTypeCountMembersArgs
    updates?: boolean | ProjectCountOutputTypeCountUpdatesArgs
    media?: boolean | ProjectCountOutputTypeCountMediaArgs
    payments?: boolean | ProjectCountOutputTypeCountPaymentsArgs
    milestones?: boolean | ProjectCountOutputTypeCountMilestonesArgs
    inspections?: boolean | ProjectCountOutputTypeCountInspectionsArgs
    queries?: boolean | ProjectCountOutputTypeCountQueriesArgs
    materials?: boolean | ProjectCountOutputTypeCountMaterialsArgs
    auditLogs?: boolean | ProjectCountOutputTypeCountAuditLogsArgs
  }

  // Custom InputTypes
  /**
   * ProjectCountOutputType without action
   */
  export type ProjectCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectCountOutputType
     */
    select?: ProjectCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ProjectCountOutputType without action
   */
  export type ProjectCountOutputTypeCountMembersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProjectMemberWhereInput
  }

  /**
   * ProjectCountOutputType without action
   */
  export type ProjectCountOutputTypeCountUpdatesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProjectUpdateWhereInput
  }

  /**
   * ProjectCountOutputType without action
   */
  export type ProjectCountOutputTypeCountMediaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MediaWhereInput
  }

  /**
   * ProjectCountOutputType without action
   */
  export type ProjectCountOutputTypeCountPaymentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PaymentWhereInput
  }

  /**
   * ProjectCountOutputType without action
   */
  export type ProjectCountOutputTypeCountMilestonesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MilestoneWhereInput
  }

  /**
   * ProjectCountOutputType without action
   */
  export type ProjectCountOutputTypeCountInspectionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InspectionWhereInput
  }

  /**
   * ProjectCountOutputType without action
   */
  export type ProjectCountOutputTypeCountQueriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: QueryWhereInput
  }

  /**
   * ProjectCountOutputType without action
   */
  export type ProjectCountOutputTypeCountMaterialsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MaterialWhereInput
  }

  /**
   * ProjectCountOutputType without action
   */
  export type ProjectCountOutputTypeCountAuditLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AuditLogWhereInput
  }


  /**
   * Count Type ProjectUpdateCountOutputType
   */

  export type ProjectUpdateCountOutputType = {
    media: number
  }

  export type ProjectUpdateCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    media?: boolean | ProjectUpdateCountOutputTypeCountMediaArgs
  }

  // Custom InputTypes
  /**
   * ProjectUpdateCountOutputType without action
   */
  export type ProjectUpdateCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectUpdateCountOutputType
     */
    select?: ProjectUpdateCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ProjectUpdateCountOutputType without action
   */
  export type ProjectUpdateCountOutputTypeCountMediaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MediaWhereInput
  }


  /**
   * Count Type MediaCountOutputType
   */

  export type MediaCountOutputType = {
    inspectionResponses: number
  }

  export type MediaCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    inspectionResponses?: boolean | MediaCountOutputTypeCountInspectionResponsesArgs
  }

  // Custom InputTypes
  /**
   * MediaCountOutputType without action
   */
  export type MediaCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MediaCountOutputType
     */
    select?: MediaCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * MediaCountOutputType without action
   */
  export type MediaCountOutputTypeCountInspectionResponsesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InspectionResponseWhereInput
  }


  /**
   * Count Type PaymentCountOutputType
   */

  export type PaymentCountOutputType = {
    media: number
  }

  export type PaymentCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    media?: boolean | PaymentCountOutputTypeCountMediaArgs
  }

  // Custom InputTypes
  /**
   * PaymentCountOutputType without action
   */
  export type PaymentCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentCountOutputType
     */
    select?: PaymentCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * PaymentCountOutputType without action
   */
  export type PaymentCountOutputTypeCountMediaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MediaWhereInput
  }


  /**
   * Count Type MilestoneCountOutputType
   */

  export type MilestoneCountOutputType = {
    checklistItems: number
    inspections: number
  }

  export type MilestoneCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    checklistItems?: boolean | MilestoneCountOutputTypeCountChecklistItemsArgs
    inspections?: boolean | MilestoneCountOutputTypeCountInspectionsArgs
  }

  // Custom InputTypes
  /**
   * MilestoneCountOutputType without action
   */
  export type MilestoneCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MilestoneCountOutputType
     */
    select?: MilestoneCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * MilestoneCountOutputType without action
   */
  export type MilestoneCountOutputTypeCountChecklistItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ChecklistItemWhereInput
  }

  /**
   * MilestoneCountOutputType without action
   */
  export type MilestoneCountOutputTypeCountInspectionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InspectionWhereInput
  }


  /**
   * Count Type ChecklistItemCountOutputType
   */

  export type ChecklistItemCountOutputType = {
    responses: number
  }

  export type ChecklistItemCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    responses?: boolean | ChecklistItemCountOutputTypeCountResponsesArgs
  }

  // Custom InputTypes
  /**
   * ChecklistItemCountOutputType without action
   */
  export type ChecklistItemCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChecklistItemCountOutputType
     */
    select?: ChecklistItemCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ChecklistItemCountOutputType without action
   */
  export type ChecklistItemCountOutputTypeCountResponsesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InspectionResponseWhereInput
  }


  /**
   * Count Type InspectionCountOutputType
   */

  export type InspectionCountOutputType = {
    responses: number
  }

  export type InspectionCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    responses?: boolean | InspectionCountOutputTypeCountResponsesArgs
  }

  // Custom InputTypes
  /**
   * InspectionCountOutputType without action
   */
  export type InspectionCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InspectionCountOutputType
     */
    select?: InspectionCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * InspectionCountOutputType without action
   */
  export type InspectionCountOutputTypeCountResponsesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InspectionResponseWhereInput
  }


  /**
   * Count Type QueryCountOutputType
   */

  export type QueryCountOutputType = {
    attachments: number
    responses: number
  }

  export type QueryCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    attachments?: boolean | QueryCountOutputTypeCountAttachmentsArgs
    responses?: boolean | QueryCountOutputTypeCountResponsesArgs
  }

  // Custom InputTypes
  /**
   * QueryCountOutputType without action
   */
  export type QueryCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QueryCountOutputType
     */
    select?: QueryCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * QueryCountOutputType without action
   */
  export type QueryCountOutputTypeCountAttachmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MediaWhereInput
  }

  /**
   * QueryCountOutputType without action
   */
  export type QueryCountOutputTypeCountResponsesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: QueryResponseWhereInput
  }


  /**
   * Models
   */

  /**
   * Model User
   */

  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserMinAggregateOutputType = {
    id: string | null
    name: string | null
    email: string | null
    passwordHash: string | null
    role: $Enums.Role | null
    isActive: boolean | null
    createdById: string | null
    createdAt: Date | null
    phone: string | null
    designation: string | null
  }

  export type UserMaxAggregateOutputType = {
    id: string | null
    name: string | null
    email: string | null
    passwordHash: string | null
    role: $Enums.Role | null
    isActive: boolean | null
    createdById: string | null
    createdAt: Date | null
    phone: string | null
    designation: string | null
  }

  export type UserCountAggregateOutputType = {
    id: number
    name: number
    email: number
    passwordHash: number
    role: number
    isActive: number
    createdById: number
    createdAt: number
    phone: number
    designation: number
    _all: number
  }


  export type UserMinAggregateInputType = {
    id?: true
    name?: true
    email?: true
    passwordHash?: true
    role?: true
    isActive?: true
    createdById?: true
    createdAt?: true
    phone?: true
    designation?: true
  }

  export type UserMaxAggregateInputType = {
    id?: true
    name?: true
    email?: true
    passwordHash?: true
    role?: true
    isActive?: true
    createdById?: true
    createdAt?: true
    phone?: true
    designation?: true
  }

  export type UserCountAggregateInputType = {
    id?: true
    name?: true
    email?: true
    passwordHash?: true
    role?: true
    isActive?: true
    createdById?: true
    createdAt?: true
    phone?: true
    designation?: true
    _all?: true
  }

  export type UserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which User to aggregate.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type UserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
    orderBy?: UserOrderByWithAggregationInput | UserOrderByWithAggregationInput[]
    by: UserScalarFieldEnum[] | UserScalarFieldEnum
    having?: UserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }

  export type UserGroupByOutputType = {
    id: string
    name: string
    email: string
    passwordHash: string
    role: $Enums.Role
    isActive: boolean
    createdById: string | null
    createdAt: Date
    phone: string | null
    designation: string | null
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends UserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type UserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    email?: boolean
    passwordHash?: boolean
    role?: boolean
    isActive?: boolean
    createdById?: boolean
    createdAt?: boolean
    phone?: boolean
    designation?: boolean
    createdBy?: boolean | User$createdByArgs<ExtArgs>
    createdUsers?: boolean | User$createdUsersArgs<ExtArgs>
    managedProjects?: boolean | User$managedProjectsArgs<ExtArgs>
    clientProjects?: boolean | User$clientProjectsArgs<ExtArgs>
    projectMembers?: boolean | User$projectMembersArgs<ExtArgs>
    projectUpdates?: boolean | User$projectUpdatesArgs<ExtArgs>
    media?: boolean | User$mediaArgs<ExtArgs>
    paymentsCreated?: boolean | User$paymentsCreatedArgs<ExtArgs>
    notifications?: boolean | User$notificationsArgs<ExtArgs>
    projectsCreated?: boolean | User$projectsCreatedArgs<ExtArgs>
    inspections?: boolean | User$inspectionsArgs<ExtArgs>
    reviewedInspections?: boolean | User$reviewedInspectionsArgs<ExtArgs>
    queries?: boolean | User$queriesArgs<ExtArgs>
    queryResponses?: boolean | User$queryResponsesArgs<ExtArgs>
    auditLogs?: boolean | User$auditLogsArgs<ExtArgs>
    notificationPrefs?: boolean | User$notificationPrefsArgs<ExtArgs>
    materialsCreated?: boolean | User$materialsCreatedArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    email?: boolean
    passwordHash?: boolean
    role?: boolean
    isActive?: boolean
    createdById?: boolean
    createdAt?: boolean
    phone?: boolean
    designation?: boolean
    createdBy?: boolean | User$createdByArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    email?: boolean
    passwordHash?: boolean
    role?: boolean
    isActive?: boolean
    createdById?: boolean
    createdAt?: boolean
    phone?: boolean
    designation?: boolean
    createdBy?: boolean | User$createdByArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectScalar = {
    id?: boolean
    name?: boolean
    email?: boolean
    passwordHash?: boolean
    role?: boolean
    isActive?: boolean
    createdById?: boolean
    createdAt?: boolean
    phone?: boolean
    designation?: boolean
  }

  export type UserOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "email" | "passwordHash" | "role" | "isActive" | "createdById" | "createdAt" | "phone" | "designation", ExtArgs["result"]["user"]>
  export type UserInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    createdBy?: boolean | User$createdByArgs<ExtArgs>
    createdUsers?: boolean | User$createdUsersArgs<ExtArgs>
    managedProjects?: boolean | User$managedProjectsArgs<ExtArgs>
    clientProjects?: boolean | User$clientProjectsArgs<ExtArgs>
    projectMembers?: boolean | User$projectMembersArgs<ExtArgs>
    projectUpdates?: boolean | User$projectUpdatesArgs<ExtArgs>
    media?: boolean | User$mediaArgs<ExtArgs>
    paymentsCreated?: boolean | User$paymentsCreatedArgs<ExtArgs>
    notifications?: boolean | User$notificationsArgs<ExtArgs>
    projectsCreated?: boolean | User$projectsCreatedArgs<ExtArgs>
    inspections?: boolean | User$inspectionsArgs<ExtArgs>
    reviewedInspections?: boolean | User$reviewedInspectionsArgs<ExtArgs>
    queries?: boolean | User$queriesArgs<ExtArgs>
    queryResponses?: boolean | User$queryResponsesArgs<ExtArgs>
    auditLogs?: boolean | User$auditLogsArgs<ExtArgs>
    notificationPrefs?: boolean | User$notificationPrefsArgs<ExtArgs>
    materialsCreated?: boolean | User$materialsCreatedArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type UserIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    createdBy?: boolean | User$createdByArgs<ExtArgs>
  }
  export type UserIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    createdBy?: boolean | User$createdByArgs<ExtArgs>
  }

  export type $UserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "User"
    objects: {
      createdBy: Prisma.$UserPayload<ExtArgs> | null
      createdUsers: Prisma.$UserPayload<ExtArgs>[]
      managedProjects: Prisma.$ProjectPayload<ExtArgs>[]
      clientProjects: Prisma.$ProjectPayload<ExtArgs>[]
      projectMembers: Prisma.$ProjectMemberPayload<ExtArgs>[]
      projectUpdates: Prisma.$ProjectUpdatePayload<ExtArgs>[]
      media: Prisma.$MediaPayload<ExtArgs>[]
      paymentsCreated: Prisma.$PaymentPayload<ExtArgs>[]
      notifications: Prisma.$NotificationPayload<ExtArgs>[]
      projectsCreated: Prisma.$ProjectPayload<ExtArgs>[]
      inspections: Prisma.$InspectionPayload<ExtArgs>[]
      reviewedInspections: Prisma.$InspectionPayload<ExtArgs>[]
      queries: Prisma.$QueryPayload<ExtArgs>[]
      queryResponses: Prisma.$QueryResponsePayload<ExtArgs>[]
      auditLogs: Prisma.$AuditLogPayload<ExtArgs>[]
      notificationPrefs: Prisma.$NotificationPreferencePayload<ExtArgs> | null
      materialsCreated: Prisma.$MaterialPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      email: string
      passwordHash: string
      role: $Enums.Role
      isActive: boolean
      createdById: string | null
      createdAt: Date
      phone: string | null
      designation: string | null
    }, ExtArgs["result"]["user"]>
    composites: {}
  }

  type UserGetPayload<S extends boolean | null | undefined | UserDefaultArgs> = $Result.GetResult<Prisma.$UserPayload, S>

  type UserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserCountAggregateInputType | true
    }

  export interface UserDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['User'], meta: { name: 'User' } }
    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserFindUniqueArgs>(args: SelectSubset<T, UserFindUniqueArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one User that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserFindUniqueOrThrowArgs>(args: SelectSubset<T, UserFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserFindFirstArgs>(args?: SelectSubset<T, UserFindFirstArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserFindFirstOrThrowArgs>(args?: SelectSubset<T, UserFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserFindManyArgs>(args?: SelectSubset<T, UserFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
     */
    create<T extends UserCreateArgs>(args: SelectSubset<T, UserCreateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Users.
     * @param {UserCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserCreateManyArgs>(args?: SelectSubset<T, UserCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Users and returns the data saved in the database.
     * @param {UserCreateManyAndReturnArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Users and only return the `id`
     * const userWithIdOnly = await prisma.user.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserCreateManyAndReturnArgs>(args?: SelectSubset<T, UserCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
     */
    delete<T extends UserDeleteArgs>(args: SelectSubset<T, UserDeleteArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserUpdateArgs>(args: SelectSubset<T, UserUpdateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserDeleteManyArgs>(args?: SelectSubset<T, UserDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserUpdateManyArgs>(args: SelectSubset<T, UserUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users and returns the data updated in the database.
     * @param {UserUpdateManyAndReturnArgs} args - Arguments to update many Users.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Users and only return the `id`
     * const userWithIdOnly = await prisma.user.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UserUpdateManyAndReturnArgs>(args: SelectSubset<T, UserUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
     */
    upsert<T extends UserUpsertArgs>(args: SelectSubset<T, UserUpsertArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): Prisma.PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the User model
   */
  readonly fields: UserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    createdBy<T extends User$createdByArgs<ExtArgs> = {}>(args?: Subset<T, User$createdByArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    createdUsers<T extends User$createdUsersArgs<ExtArgs> = {}>(args?: Subset<T, User$createdUsersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    managedProjects<T extends User$managedProjectsArgs<ExtArgs> = {}>(args?: Subset<T, User$managedProjectsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    clientProjects<T extends User$clientProjectsArgs<ExtArgs> = {}>(args?: Subset<T, User$clientProjectsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    projectMembers<T extends User$projectMembersArgs<ExtArgs> = {}>(args?: Subset<T, User$projectMembersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProjectMemberPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    projectUpdates<T extends User$projectUpdatesArgs<ExtArgs> = {}>(args?: Subset<T, User$projectUpdatesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProjectUpdatePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    media<T extends User$mediaArgs<ExtArgs> = {}>(args?: Subset<T, User$mediaArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MediaPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    paymentsCreated<T extends User$paymentsCreatedArgs<ExtArgs> = {}>(args?: Subset<T, User$paymentsCreatedArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    notifications<T extends User$notificationsArgs<ExtArgs> = {}>(args?: Subset<T, User$notificationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    projectsCreated<T extends User$projectsCreatedArgs<ExtArgs> = {}>(args?: Subset<T, User$projectsCreatedArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    inspections<T extends User$inspectionsArgs<ExtArgs> = {}>(args?: Subset<T, User$inspectionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InspectionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    reviewedInspections<T extends User$reviewedInspectionsArgs<ExtArgs> = {}>(args?: Subset<T, User$reviewedInspectionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InspectionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    queries<T extends User$queriesArgs<ExtArgs> = {}>(args?: Subset<T, User$queriesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QueryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    queryResponses<T extends User$queryResponsesArgs<ExtArgs> = {}>(args?: Subset<T, User$queryResponsesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QueryResponsePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    auditLogs<T extends User$auditLogsArgs<ExtArgs> = {}>(args?: Subset<T, User$auditLogsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    notificationPrefs<T extends User$notificationPrefsArgs<ExtArgs> = {}>(args?: Subset<T, User$notificationPrefsArgs<ExtArgs>>): Prisma__NotificationPreferenceClient<$Result.GetResult<Prisma.$NotificationPreferencePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    materialsCreated<T extends User$materialsCreatedArgs<ExtArgs> = {}>(args?: Subset<T, User$materialsCreatedArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MaterialPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the User model
   */
  interface UserFieldRefs {
    readonly id: FieldRef<"User", 'String'>
    readonly name: FieldRef<"User", 'String'>
    readonly email: FieldRef<"User", 'String'>
    readonly passwordHash: FieldRef<"User", 'String'>
    readonly role: FieldRef<"User", 'Role'>
    readonly isActive: FieldRef<"User", 'Boolean'>
    readonly createdById: FieldRef<"User", 'String'>
    readonly createdAt: FieldRef<"User", 'DateTime'>
    readonly phone: FieldRef<"User", 'String'>
    readonly designation: FieldRef<"User", 'String'>
  }
    

  // Custom InputTypes
  /**
   * User findUnique
   */
  export type UserFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findUniqueOrThrow
   */
  export type UserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findFirst
   */
  export type UserFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findFirstOrThrow
   */
  export type UserFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findMany
   */
  export type UserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User create
   */
  export type UserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to create a User.
     */
    data: XOR<UserCreateInput, UserUncheckedCreateInput>
  }

  /**
   * User createMany
   */
  export type UserCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User createManyAndReturn
   */
  export type UserCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * User update
   */
  export type UserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to update a User.
     */
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>
    /**
     * Choose, which User to update.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User updateMany
   */
  export type UserUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
  }

  /**
   * User updateManyAndReturn
   */
  export type UserUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * User upsert
   */
  export type UserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The filter to search for the User to update in case it exists.
     */
    where: UserWhereUniqueInput
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     */
    create: XOR<UserCreateInput, UserUncheckedCreateInput>
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>
  }

  /**
   * User delete
   */
  export type UserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter which User to delete.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Users to delete
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to delete.
     */
    limit?: number
  }

  /**
   * User.createdBy
   */
  export type User$createdByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * User.createdUsers
   */
  export type User$createdUsersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    cursor?: UserWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User.managedProjects
   */
  export type User$managedProjectsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Project
     */
    omit?: ProjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInclude<ExtArgs> | null
    where?: ProjectWhereInput
    orderBy?: ProjectOrderByWithRelationInput | ProjectOrderByWithRelationInput[]
    cursor?: ProjectWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProjectScalarFieldEnum | ProjectScalarFieldEnum[]
  }

  /**
   * User.clientProjects
   */
  export type User$clientProjectsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Project
     */
    omit?: ProjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInclude<ExtArgs> | null
    where?: ProjectWhereInput
    orderBy?: ProjectOrderByWithRelationInput | ProjectOrderByWithRelationInput[]
    cursor?: ProjectWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProjectScalarFieldEnum | ProjectScalarFieldEnum[]
  }

  /**
   * User.projectMembers
   */
  export type User$projectMembersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectMember
     */
    select?: ProjectMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProjectMember
     */
    omit?: ProjectMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectMemberInclude<ExtArgs> | null
    where?: ProjectMemberWhereInput
    orderBy?: ProjectMemberOrderByWithRelationInput | ProjectMemberOrderByWithRelationInput[]
    cursor?: ProjectMemberWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProjectMemberScalarFieldEnum | ProjectMemberScalarFieldEnum[]
  }

  /**
   * User.projectUpdates
   */
  export type User$projectUpdatesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectUpdate
     */
    select?: ProjectUpdateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProjectUpdate
     */
    omit?: ProjectUpdateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectUpdateInclude<ExtArgs> | null
    where?: ProjectUpdateWhereInput
    orderBy?: ProjectUpdateOrderByWithRelationInput | ProjectUpdateOrderByWithRelationInput[]
    cursor?: ProjectUpdateWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProjectUpdateScalarFieldEnum | ProjectUpdateScalarFieldEnum[]
  }

  /**
   * User.media
   */
  export type User$mediaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Media
     */
    select?: MediaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Media
     */
    omit?: MediaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MediaInclude<ExtArgs> | null
    where?: MediaWhereInput
    orderBy?: MediaOrderByWithRelationInput | MediaOrderByWithRelationInput[]
    cursor?: MediaWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MediaScalarFieldEnum | MediaScalarFieldEnum[]
  }

  /**
   * User.paymentsCreated
   */
  export type User$paymentsCreatedArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    where?: PaymentWhereInput
    orderBy?: PaymentOrderByWithRelationInput | PaymentOrderByWithRelationInput[]
    cursor?: PaymentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PaymentScalarFieldEnum | PaymentScalarFieldEnum[]
  }

  /**
   * User.notifications
   */
  export type User$notificationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    where?: NotificationWhereInput
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    cursor?: NotificationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * User.projectsCreated
   */
  export type User$projectsCreatedArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Project
     */
    omit?: ProjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInclude<ExtArgs> | null
    where?: ProjectWhereInput
    orderBy?: ProjectOrderByWithRelationInput | ProjectOrderByWithRelationInput[]
    cursor?: ProjectWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProjectScalarFieldEnum | ProjectScalarFieldEnum[]
  }

  /**
   * User.inspections
   */
  export type User$inspectionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Inspection
     */
    select?: InspectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Inspection
     */
    omit?: InspectionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InspectionInclude<ExtArgs> | null
    where?: InspectionWhereInput
    orderBy?: InspectionOrderByWithRelationInput | InspectionOrderByWithRelationInput[]
    cursor?: InspectionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: InspectionScalarFieldEnum | InspectionScalarFieldEnum[]
  }

  /**
   * User.reviewedInspections
   */
  export type User$reviewedInspectionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Inspection
     */
    select?: InspectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Inspection
     */
    omit?: InspectionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InspectionInclude<ExtArgs> | null
    where?: InspectionWhereInput
    orderBy?: InspectionOrderByWithRelationInput | InspectionOrderByWithRelationInput[]
    cursor?: InspectionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: InspectionScalarFieldEnum | InspectionScalarFieldEnum[]
  }

  /**
   * User.queries
   */
  export type User$queriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Query
     */
    select?: QuerySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Query
     */
    omit?: QueryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QueryInclude<ExtArgs> | null
    where?: QueryWhereInput
    orderBy?: QueryOrderByWithRelationInput | QueryOrderByWithRelationInput[]
    cursor?: QueryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: QueryScalarFieldEnum | QueryScalarFieldEnum[]
  }

  /**
   * User.queryResponses
   */
  export type User$queryResponsesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QueryResponse
     */
    select?: QueryResponseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QueryResponse
     */
    omit?: QueryResponseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QueryResponseInclude<ExtArgs> | null
    where?: QueryResponseWhereInput
    orderBy?: QueryResponseOrderByWithRelationInput | QueryResponseOrderByWithRelationInput[]
    cursor?: QueryResponseWhereUniqueInput
    take?: number
    skip?: number
    distinct?: QueryResponseScalarFieldEnum | QueryResponseScalarFieldEnum[]
  }

  /**
   * User.auditLogs
   */
  export type User$auditLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    where?: AuditLogWhereInput
    orderBy?: AuditLogOrderByWithRelationInput | AuditLogOrderByWithRelationInput[]
    cursor?: AuditLogWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AuditLogScalarFieldEnum | AuditLogScalarFieldEnum[]
  }

  /**
   * User.notificationPrefs
   */
  export type User$notificationPrefsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationPreference
     */
    select?: NotificationPreferenceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NotificationPreference
     */
    omit?: NotificationPreferenceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationPreferenceInclude<ExtArgs> | null
    where?: NotificationPreferenceWhereInput
  }

  /**
   * User.materialsCreated
   */
  export type User$materialsCreatedArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Material
     */
    select?: MaterialSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Material
     */
    omit?: MaterialOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaterialInclude<ExtArgs> | null
    where?: MaterialWhereInput
    orderBy?: MaterialOrderByWithRelationInput | MaterialOrderByWithRelationInput[]
    cursor?: MaterialWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MaterialScalarFieldEnum | MaterialScalarFieldEnum[]
  }

  /**
   * User without action
   */
  export type UserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
  }


  /**
   * Model Project
   */

  export type AggregateProject = {
    _count: ProjectCountAggregateOutputType | null
    _min: ProjectMinAggregateOutputType | null
    _max: ProjectMaxAggregateOutputType | null
  }

  export type ProjectMinAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    status: $Enums.ProjectStatus | null
    isArchived: boolean | null
    createdById: string | null
    managerId: string | null
    clientId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ProjectMaxAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    status: $Enums.ProjectStatus | null
    isArchived: boolean | null
    createdById: string | null
    managerId: string | null
    clientId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ProjectCountAggregateOutputType = {
    id: number
    name: number
    description: number
    status: number
    isArchived: number
    createdById: number
    managerId: number
    clientId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ProjectMinAggregateInputType = {
    id?: true
    name?: true
    description?: true
    status?: true
    isArchived?: true
    createdById?: true
    managerId?: true
    clientId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ProjectMaxAggregateInputType = {
    id?: true
    name?: true
    description?: true
    status?: true
    isArchived?: true
    createdById?: true
    managerId?: true
    clientId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ProjectCountAggregateInputType = {
    id?: true
    name?: true
    description?: true
    status?: true
    isArchived?: true
    createdById?: true
    managerId?: true
    clientId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ProjectAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Project to aggregate.
     */
    where?: ProjectWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Projects to fetch.
     */
    orderBy?: ProjectOrderByWithRelationInput | ProjectOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ProjectWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Projects from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Projects.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Projects
    **/
    _count?: true | ProjectCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProjectMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProjectMaxAggregateInputType
  }

  export type GetProjectAggregateType<T extends ProjectAggregateArgs> = {
        [P in keyof T & keyof AggregateProject]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProject[P]>
      : GetScalarType<T[P], AggregateProject[P]>
  }




  export type ProjectGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProjectWhereInput
    orderBy?: ProjectOrderByWithAggregationInput | ProjectOrderByWithAggregationInput[]
    by: ProjectScalarFieldEnum[] | ProjectScalarFieldEnum
    having?: ProjectScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProjectCountAggregateInputType | true
    _min?: ProjectMinAggregateInputType
    _max?: ProjectMaxAggregateInputType
  }

  export type ProjectGroupByOutputType = {
    id: string
    name: string
    description: string | null
    status: $Enums.ProjectStatus
    isArchived: boolean
    createdById: string
    managerId: string
    clientId: string
    createdAt: Date
    updatedAt: Date
    _count: ProjectCountAggregateOutputType | null
    _min: ProjectMinAggregateOutputType | null
    _max: ProjectMaxAggregateOutputType | null
  }

  type GetProjectGroupByPayload<T extends ProjectGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ProjectGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProjectGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProjectGroupByOutputType[P]>
            : GetScalarType<T[P], ProjectGroupByOutputType[P]>
        }
      >
    >


  export type ProjectSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    status?: boolean
    isArchived?: boolean
    createdById?: boolean
    managerId?: boolean
    clientId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    createdBy?: boolean | UserDefaultArgs<ExtArgs>
    manager?: boolean | UserDefaultArgs<ExtArgs>
    client?: boolean | UserDefaultArgs<ExtArgs>
    members?: boolean | Project$membersArgs<ExtArgs>
    updates?: boolean | Project$updatesArgs<ExtArgs>
    media?: boolean | Project$mediaArgs<ExtArgs>
    payments?: boolean | Project$paymentsArgs<ExtArgs>
    milestones?: boolean | Project$milestonesArgs<ExtArgs>
    inspections?: boolean | Project$inspectionsArgs<ExtArgs>
    queries?: boolean | Project$queriesArgs<ExtArgs>
    materials?: boolean | Project$materialsArgs<ExtArgs>
    auditLogs?: boolean | Project$auditLogsArgs<ExtArgs>
    _count?: boolean | ProjectCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["project"]>

  export type ProjectSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    status?: boolean
    isArchived?: boolean
    createdById?: boolean
    managerId?: boolean
    clientId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    createdBy?: boolean | UserDefaultArgs<ExtArgs>
    manager?: boolean | UserDefaultArgs<ExtArgs>
    client?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["project"]>

  export type ProjectSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    status?: boolean
    isArchived?: boolean
    createdById?: boolean
    managerId?: boolean
    clientId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    createdBy?: boolean | UserDefaultArgs<ExtArgs>
    manager?: boolean | UserDefaultArgs<ExtArgs>
    client?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["project"]>

  export type ProjectSelectScalar = {
    id?: boolean
    name?: boolean
    description?: boolean
    status?: boolean
    isArchived?: boolean
    createdById?: boolean
    managerId?: boolean
    clientId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ProjectOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "description" | "status" | "isArchived" | "createdById" | "managerId" | "clientId" | "createdAt" | "updatedAt", ExtArgs["result"]["project"]>
  export type ProjectInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    createdBy?: boolean | UserDefaultArgs<ExtArgs>
    manager?: boolean | UserDefaultArgs<ExtArgs>
    client?: boolean | UserDefaultArgs<ExtArgs>
    members?: boolean | Project$membersArgs<ExtArgs>
    updates?: boolean | Project$updatesArgs<ExtArgs>
    media?: boolean | Project$mediaArgs<ExtArgs>
    payments?: boolean | Project$paymentsArgs<ExtArgs>
    milestones?: boolean | Project$milestonesArgs<ExtArgs>
    inspections?: boolean | Project$inspectionsArgs<ExtArgs>
    queries?: boolean | Project$queriesArgs<ExtArgs>
    materials?: boolean | Project$materialsArgs<ExtArgs>
    auditLogs?: boolean | Project$auditLogsArgs<ExtArgs>
    _count?: boolean | ProjectCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ProjectIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    createdBy?: boolean | UserDefaultArgs<ExtArgs>
    manager?: boolean | UserDefaultArgs<ExtArgs>
    client?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type ProjectIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    createdBy?: boolean | UserDefaultArgs<ExtArgs>
    manager?: boolean | UserDefaultArgs<ExtArgs>
    client?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $ProjectPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Project"
    objects: {
      createdBy: Prisma.$UserPayload<ExtArgs>
      manager: Prisma.$UserPayload<ExtArgs>
      client: Prisma.$UserPayload<ExtArgs>
      members: Prisma.$ProjectMemberPayload<ExtArgs>[]
      updates: Prisma.$ProjectUpdatePayload<ExtArgs>[]
      media: Prisma.$MediaPayload<ExtArgs>[]
      payments: Prisma.$PaymentPayload<ExtArgs>[]
      milestones: Prisma.$MilestonePayload<ExtArgs>[]
      inspections: Prisma.$InspectionPayload<ExtArgs>[]
      queries: Prisma.$QueryPayload<ExtArgs>[]
      materials: Prisma.$MaterialPayload<ExtArgs>[]
      auditLogs: Prisma.$AuditLogPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      description: string | null
      status: $Enums.ProjectStatus
      isArchived: boolean
      createdById: string
      managerId: string
      clientId: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["project"]>
    composites: {}
  }

  type ProjectGetPayload<S extends boolean | null | undefined | ProjectDefaultArgs> = $Result.GetResult<Prisma.$ProjectPayload, S>

  type ProjectCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ProjectFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ProjectCountAggregateInputType | true
    }

  export interface ProjectDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Project'], meta: { name: 'Project' } }
    /**
     * Find zero or one Project that matches the filter.
     * @param {ProjectFindUniqueArgs} args - Arguments to find a Project
     * @example
     * // Get one Project
     * const project = await prisma.project.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ProjectFindUniqueArgs>(args: SelectSubset<T, ProjectFindUniqueArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Project that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ProjectFindUniqueOrThrowArgs} args - Arguments to find a Project
     * @example
     * // Get one Project
     * const project = await prisma.project.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ProjectFindUniqueOrThrowArgs>(args: SelectSubset<T, ProjectFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Project that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectFindFirstArgs} args - Arguments to find a Project
     * @example
     * // Get one Project
     * const project = await prisma.project.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ProjectFindFirstArgs>(args?: SelectSubset<T, ProjectFindFirstArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Project that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectFindFirstOrThrowArgs} args - Arguments to find a Project
     * @example
     * // Get one Project
     * const project = await prisma.project.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ProjectFindFirstOrThrowArgs>(args?: SelectSubset<T, ProjectFindFirstOrThrowArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Projects that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Projects
     * const projects = await prisma.project.findMany()
     * 
     * // Get first 10 Projects
     * const projects = await prisma.project.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const projectWithIdOnly = await prisma.project.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ProjectFindManyArgs>(args?: SelectSubset<T, ProjectFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Project.
     * @param {ProjectCreateArgs} args - Arguments to create a Project.
     * @example
     * // Create one Project
     * const Project = await prisma.project.create({
     *   data: {
     *     // ... data to create a Project
     *   }
     * })
     * 
     */
    create<T extends ProjectCreateArgs>(args: SelectSubset<T, ProjectCreateArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Projects.
     * @param {ProjectCreateManyArgs} args - Arguments to create many Projects.
     * @example
     * // Create many Projects
     * const project = await prisma.project.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ProjectCreateManyArgs>(args?: SelectSubset<T, ProjectCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Projects and returns the data saved in the database.
     * @param {ProjectCreateManyAndReturnArgs} args - Arguments to create many Projects.
     * @example
     * // Create many Projects
     * const project = await prisma.project.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Projects and only return the `id`
     * const projectWithIdOnly = await prisma.project.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ProjectCreateManyAndReturnArgs>(args?: SelectSubset<T, ProjectCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Project.
     * @param {ProjectDeleteArgs} args - Arguments to delete one Project.
     * @example
     * // Delete one Project
     * const Project = await prisma.project.delete({
     *   where: {
     *     // ... filter to delete one Project
     *   }
     * })
     * 
     */
    delete<T extends ProjectDeleteArgs>(args: SelectSubset<T, ProjectDeleteArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Project.
     * @param {ProjectUpdateArgs} args - Arguments to update one Project.
     * @example
     * // Update one Project
     * const project = await prisma.project.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ProjectUpdateArgs>(args: SelectSubset<T, ProjectUpdateArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Projects.
     * @param {ProjectDeleteManyArgs} args - Arguments to filter Projects to delete.
     * @example
     * // Delete a few Projects
     * const { count } = await prisma.project.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ProjectDeleteManyArgs>(args?: SelectSubset<T, ProjectDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Projects.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Projects
     * const project = await prisma.project.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ProjectUpdateManyArgs>(args: SelectSubset<T, ProjectUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Projects and returns the data updated in the database.
     * @param {ProjectUpdateManyAndReturnArgs} args - Arguments to update many Projects.
     * @example
     * // Update many Projects
     * const project = await prisma.project.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Projects and only return the `id`
     * const projectWithIdOnly = await prisma.project.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ProjectUpdateManyAndReturnArgs>(args: SelectSubset<T, ProjectUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Project.
     * @param {ProjectUpsertArgs} args - Arguments to update or create a Project.
     * @example
     * // Update or create a Project
     * const project = await prisma.project.upsert({
     *   create: {
     *     // ... data to create a Project
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Project we want to update
     *   }
     * })
     */
    upsert<T extends ProjectUpsertArgs>(args: SelectSubset<T, ProjectUpsertArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Projects.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectCountArgs} args - Arguments to filter Projects to count.
     * @example
     * // Count the number of Projects
     * const count = await prisma.project.count({
     *   where: {
     *     // ... the filter for the Projects we want to count
     *   }
     * })
    **/
    count<T extends ProjectCountArgs>(
      args?: Subset<T, ProjectCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProjectCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Project.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProjectAggregateArgs>(args: Subset<T, ProjectAggregateArgs>): Prisma.PrismaPromise<GetProjectAggregateType<T>>

    /**
     * Group by Project.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProjectGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProjectGroupByArgs['orderBy'] }
        : { orderBy?: ProjectGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProjectGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProjectGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Project model
   */
  readonly fields: ProjectFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Project.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ProjectClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    createdBy<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    manager<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    client<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    members<T extends Project$membersArgs<ExtArgs> = {}>(args?: Subset<T, Project$membersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProjectMemberPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    updates<T extends Project$updatesArgs<ExtArgs> = {}>(args?: Subset<T, Project$updatesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProjectUpdatePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    media<T extends Project$mediaArgs<ExtArgs> = {}>(args?: Subset<T, Project$mediaArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MediaPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    payments<T extends Project$paymentsArgs<ExtArgs> = {}>(args?: Subset<T, Project$paymentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    milestones<T extends Project$milestonesArgs<ExtArgs> = {}>(args?: Subset<T, Project$milestonesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MilestonePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    inspections<T extends Project$inspectionsArgs<ExtArgs> = {}>(args?: Subset<T, Project$inspectionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InspectionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    queries<T extends Project$queriesArgs<ExtArgs> = {}>(args?: Subset<T, Project$queriesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QueryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    materials<T extends Project$materialsArgs<ExtArgs> = {}>(args?: Subset<T, Project$materialsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MaterialPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    auditLogs<T extends Project$auditLogsArgs<ExtArgs> = {}>(args?: Subset<T, Project$auditLogsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Project model
   */
  interface ProjectFieldRefs {
    readonly id: FieldRef<"Project", 'String'>
    readonly name: FieldRef<"Project", 'String'>
    readonly description: FieldRef<"Project", 'String'>
    readonly status: FieldRef<"Project", 'ProjectStatus'>
    readonly isArchived: FieldRef<"Project", 'Boolean'>
    readonly createdById: FieldRef<"Project", 'String'>
    readonly managerId: FieldRef<"Project", 'String'>
    readonly clientId: FieldRef<"Project", 'String'>
    readonly createdAt: FieldRef<"Project", 'DateTime'>
    readonly updatedAt: FieldRef<"Project", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Project findUnique
   */
  export type ProjectFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Project
     */
    omit?: ProjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInclude<ExtArgs> | null
    /**
     * Filter, which Project to fetch.
     */
    where: ProjectWhereUniqueInput
  }

  /**
   * Project findUniqueOrThrow
   */
  export type ProjectFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Project
     */
    omit?: ProjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInclude<ExtArgs> | null
    /**
     * Filter, which Project to fetch.
     */
    where: ProjectWhereUniqueInput
  }

  /**
   * Project findFirst
   */
  export type ProjectFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Project
     */
    omit?: ProjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInclude<ExtArgs> | null
    /**
     * Filter, which Project to fetch.
     */
    where?: ProjectWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Projects to fetch.
     */
    orderBy?: ProjectOrderByWithRelationInput | ProjectOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Projects.
     */
    cursor?: ProjectWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Projects from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Projects.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Projects.
     */
    distinct?: ProjectScalarFieldEnum | ProjectScalarFieldEnum[]
  }

  /**
   * Project findFirstOrThrow
   */
  export type ProjectFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Project
     */
    omit?: ProjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInclude<ExtArgs> | null
    /**
     * Filter, which Project to fetch.
     */
    where?: ProjectWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Projects to fetch.
     */
    orderBy?: ProjectOrderByWithRelationInput | ProjectOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Projects.
     */
    cursor?: ProjectWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Projects from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Projects.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Projects.
     */
    distinct?: ProjectScalarFieldEnum | ProjectScalarFieldEnum[]
  }

  /**
   * Project findMany
   */
  export type ProjectFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Project
     */
    omit?: ProjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInclude<ExtArgs> | null
    /**
     * Filter, which Projects to fetch.
     */
    where?: ProjectWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Projects to fetch.
     */
    orderBy?: ProjectOrderByWithRelationInput | ProjectOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Projects.
     */
    cursor?: ProjectWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Projects from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Projects.
     */
    skip?: number
    distinct?: ProjectScalarFieldEnum | ProjectScalarFieldEnum[]
  }

  /**
   * Project create
   */
  export type ProjectCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Project
     */
    omit?: ProjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInclude<ExtArgs> | null
    /**
     * The data needed to create a Project.
     */
    data: XOR<ProjectCreateInput, ProjectUncheckedCreateInput>
  }

  /**
   * Project createMany
   */
  export type ProjectCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Projects.
     */
    data: ProjectCreateManyInput | ProjectCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Project createManyAndReturn
   */
  export type ProjectCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Project
     */
    omit?: ProjectOmit<ExtArgs> | null
    /**
     * The data used to create many Projects.
     */
    data: ProjectCreateManyInput | ProjectCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Project update
   */
  export type ProjectUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Project
     */
    omit?: ProjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInclude<ExtArgs> | null
    /**
     * The data needed to update a Project.
     */
    data: XOR<ProjectUpdateInput, ProjectUncheckedUpdateInput>
    /**
     * Choose, which Project to update.
     */
    where: ProjectWhereUniqueInput
  }

  /**
   * Project updateMany
   */
  export type ProjectUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Projects.
     */
    data: XOR<ProjectUpdateManyMutationInput, ProjectUncheckedUpdateManyInput>
    /**
     * Filter which Projects to update
     */
    where?: ProjectWhereInput
    /**
     * Limit how many Projects to update.
     */
    limit?: number
  }

  /**
   * Project updateManyAndReturn
   */
  export type ProjectUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Project
     */
    omit?: ProjectOmit<ExtArgs> | null
    /**
     * The data used to update Projects.
     */
    data: XOR<ProjectUpdateManyMutationInput, ProjectUncheckedUpdateManyInput>
    /**
     * Filter which Projects to update
     */
    where?: ProjectWhereInput
    /**
     * Limit how many Projects to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Project upsert
   */
  export type ProjectUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Project
     */
    omit?: ProjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInclude<ExtArgs> | null
    /**
     * The filter to search for the Project to update in case it exists.
     */
    where: ProjectWhereUniqueInput
    /**
     * In case the Project found by the `where` argument doesn't exist, create a new Project with this data.
     */
    create: XOR<ProjectCreateInput, ProjectUncheckedCreateInput>
    /**
     * In case the Project was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ProjectUpdateInput, ProjectUncheckedUpdateInput>
  }

  /**
   * Project delete
   */
  export type ProjectDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Project
     */
    omit?: ProjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInclude<ExtArgs> | null
    /**
     * Filter which Project to delete.
     */
    where: ProjectWhereUniqueInput
  }

  /**
   * Project deleteMany
   */
  export type ProjectDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Projects to delete
     */
    where?: ProjectWhereInput
    /**
     * Limit how many Projects to delete.
     */
    limit?: number
  }

  /**
   * Project.members
   */
  export type Project$membersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectMember
     */
    select?: ProjectMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProjectMember
     */
    omit?: ProjectMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectMemberInclude<ExtArgs> | null
    where?: ProjectMemberWhereInput
    orderBy?: ProjectMemberOrderByWithRelationInput | ProjectMemberOrderByWithRelationInput[]
    cursor?: ProjectMemberWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProjectMemberScalarFieldEnum | ProjectMemberScalarFieldEnum[]
  }

  /**
   * Project.updates
   */
  export type Project$updatesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectUpdate
     */
    select?: ProjectUpdateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProjectUpdate
     */
    omit?: ProjectUpdateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectUpdateInclude<ExtArgs> | null
    where?: ProjectUpdateWhereInput
    orderBy?: ProjectUpdateOrderByWithRelationInput | ProjectUpdateOrderByWithRelationInput[]
    cursor?: ProjectUpdateWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProjectUpdateScalarFieldEnum | ProjectUpdateScalarFieldEnum[]
  }

  /**
   * Project.media
   */
  export type Project$mediaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Media
     */
    select?: MediaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Media
     */
    omit?: MediaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MediaInclude<ExtArgs> | null
    where?: MediaWhereInput
    orderBy?: MediaOrderByWithRelationInput | MediaOrderByWithRelationInput[]
    cursor?: MediaWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MediaScalarFieldEnum | MediaScalarFieldEnum[]
  }

  /**
   * Project.payments
   */
  export type Project$paymentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    where?: PaymentWhereInput
    orderBy?: PaymentOrderByWithRelationInput | PaymentOrderByWithRelationInput[]
    cursor?: PaymentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PaymentScalarFieldEnum | PaymentScalarFieldEnum[]
  }

  /**
   * Project.milestones
   */
  export type Project$milestonesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Milestone
     */
    select?: MilestoneSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Milestone
     */
    omit?: MilestoneOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MilestoneInclude<ExtArgs> | null
    where?: MilestoneWhereInput
    orderBy?: MilestoneOrderByWithRelationInput | MilestoneOrderByWithRelationInput[]
    cursor?: MilestoneWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MilestoneScalarFieldEnum | MilestoneScalarFieldEnum[]
  }

  /**
   * Project.inspections
   */
  export type Project$inspectionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Inspection
     */
    select?: InspectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Inspection
     */
    omit?: InspectionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InspectionInclude<ExtArgs> | null
    where?: InspectionWhereInput
    orderBy?: InspectionOrderByWithRelationInput | InspectionOrderByWithRelationInput[]
    cursor?: InspectionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: InspectionScalarFieldEnum | InspectionScalarFieldEnum[]
  }

  /**
   * Project.queries
   */
  export type Project$queriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Query
     */
    select?: QuerySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Query
     */
    omit?: QueryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QueryInclude<ExtArgs> | null
    where?: QueryWhereInput
    orderBy?: QueryOrderByWithRelationInput | QueryOrderByWithRelationInput[]
    cursor?: QueryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: QueryScalarFieldEnum | QueryScalarFieldEnum[]
  }

  /**
   * Project.materials
   */
  export type Project$materialsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Material
     */
    select?: MaterialSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Material
     */
    omit?: MaterialOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaterialInclude<ExtArgs> | null
    where?: MaterialWhereInput
    orderBy?: MaterialOrderByWithRelationInput | MaterialOrderByWithRelationInput[]
    cursor?: MaterialWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MaterialScalarFieldEnum | MaterialScalarFieldEnum[]
  }

  /**
   * Project.auditLogs
   */
  export type Project$auditLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    where?: AuditLogWhereInput
    orderBy?: AuditLogOrderByWithRelationInput | AuditLogOrderByWithRelationInput[]
    cursor?: AuditLogWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AuditLogScalarFieldEnum | AuditLogScalarFieldEnum[]
  }

  /**
   * Project without action
   */
  export type ProjectDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Project
     */
    omit?: ProjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInclude<ExtArgs> | null
  }


  /**
   * Model ProjectMember
   */

  export type AggregateProjectMember = {
    _count: ProjectMemberCountAggregateOutputType | null
    _min: ProjectMemberMinAggregateOutputType | null
    _max: ProjectMemberMaxAggregateOutputType | null
  }

  export type ProjectMemberMinAggregateOutputType = {
    id: string | null
    projectId: string | null
    userId: string | null
    role: $Enums.ProjectMemberRole | null
    createdAt: Date | null
  }

  export type ProjectMemberMaxAggregateOutputType = {
    id: string | null
    projectId: string | null
    userId: string | null
    role: $Enums.ProjectMemberRole | null
    createdAt: Date | null
  }

  export type ProjectMemberCountAggregateOutputType = {
    id: number
    projectId: number
    userId: number
    role: number
    createdAt: number
    _all: number
  }


  export type ProjectMemberMinAggregateInputType = {
    id?: true
    projectId?: true
    userId?: true
    role?: true
    createdAt?: true
  }

  export type ProjectMemberMaxAggregateInputType = {
    id?: true
    projectId?: true
    userId?: true
    role?: true
    createdAt?: true
  }

  export type ProjectMemberCountAggregateInputType = {
    id?: true
    projectId?: true
    userId?: true
    role?: true
    createdAt?: true
    _all?: true
  }

  export type ProjectMemberAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProjectMember to aggregate.
     */
    where?: ProjectMemberWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProjectMembers to fetch.
     */
    orderBy?: ProjectMemberOrderByWithRelationInput | ProjectMemberOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ProjectMemberWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProjectMembers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProjectMembers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ProjectMembers
    **/
    _count?: true | ProjectMemberCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProjectMemberMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProjectMemberMaxAggregateInputType
  }

  export type GetProjectMemberAggregateType<T extends ProjectMemberAggregateArgs> = {
        [P in keyof T & keyof AggregateProjectMember]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProjectMember[P]>
      : GetScalarType<T[P], AggregateProjectMember[P]>
  }




  export type ProjectMemberGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProjectMemberWhereInput
    orderBy?: ProjectMemberOrderByWithAggregationInput | ProjectMemberOrderByWithAggregationInput[]
    by: ProjectMemberScalarFieldEnum[] | ProjectMemberScalarFieldEnum
    having?: ProjectMemberScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProjectMemberCountAggregateInputType | true
    _min?: ProjectMemberMinAggregateInputType
    _max?: ProjectMemberMaxAggregateInputType
  }

  export type ProjectMemberGroupByOutputType = {
    id: string
    projectId: string
    userId: string
    role: $Enums.ProjectMemberRole
    createdAt: Date
    _count: ProjectMemberCountAggregateOutputType | null
    _min: ProjectMemberMinAggregateOutputType | null
    _max: ProjectMemberMaxAggregateOutputType | null
  }

  type GetProjectMemberGroupByPayload<T extends ProjectMemberGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ProjectMemberGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProjectMemberGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProjectMemberGroupByOutputType[P]>
            : GetScalarType<T[P], ProjectMemberGroupByOutputType[P]>
        }
      >
    >


  export type ProjectMemberSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    projectId?: boolean
    userId?: boolean
    role?: boolean
    createdAt?: boolean
    project?: boolean | ProjectDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["projectMember"]>

  export type ProjectMemberSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    projectId?: boolean
    userId?: boolean
    role?: boolean
    createdAt?: boolean
    project?: boolean | ProjectDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["projectMember"]>

  export type ProjectMemberSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    projectId?: boolean
    userId?: boolean
    role?: boolean
    createdAt?: boolean
    project?: boolean | ProjectDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["projectMember"]>

  export type ProjectMemberSelectScalar = {
    id?: boolean
    projectId?: boolean
    userId?: boolean
    role?: boolean
    createdAt?: boolean
  }

  export type ProjectMemberOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "projectId" | "userId" | "role" | "createdAt", ExtArgs["result"]["projectMember"]>
  export type ProjectMemberInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    project?: boolean | ProjectDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type ProjectMemberIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    project?: boolean | ProjectDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type ProjectMemberIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    project?: boolean | ProjectDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $ProjectMemberPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ProjectMember"
    objects: {
      project: Prisma.$ProjectPayload<ExtArgs>
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      projectId: string
      userId: string
      role: $Enums.ProjectMemberRole
      createdAt: Date
    }, ExtArgs["result"]["projectMember"]>
    composites: {}
  }

  type ProjectMemberGetPayload<S extends boolean | null | undefined | ProjectMemberDefaultArgs> = $Result.GetResult<Prisma.$ProjectMemberPayload, S>

  type ProjectMemberCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ProjectMemberFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ProjectMemberCountAggregateInputType | true
    }

  export interface ProjectMemberDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ProjectMember'], meta: { name: 'ProjectMember' } }
    /**
     * Find zero or one ProjectMember that matches the filter.
     * @param {ProjectMemberFindUniqueArgs} args - Arguments to find a ProjectMember
     * @example
     * // Get one ProjectMember
     * const projectMember = await prisma.projectMember.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ProjectMemberFindUniqueArgs>(args: SelectSubset<T, ProjectMemberFindUniqueArgs<ExtArgs>>): Prisma__ProjectMemberClient<$Result.GetResult<Prisma.$ProjectMemberPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ProjectMember that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ProjectMemberFindUniqueOrThrowArgs} args - Arguments to find a ProjectMember
     * @example
     * // Get one ProjectMember
     * const projectMember = await prisma.projectMember.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ProjectMemberFindUniqueOrThrowArgs>(args: SelectSubset<T, ProjectMemberFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ProjectMemberClient<$Result.GetResult<Prisma.$ProjectMemberPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ProjectMember that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectMemberFindFirstArgs} args - Arguments to find a ProjectMember
     * @example
     * // Get one ProjectMember
     * const projectMember = await prisma.projectMember.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ProjectMemberFindFirstArgs>(args?: SelectSubset<T, ProjectMemberFindFirstArgs<ExtArgs>>): Prisma__ProjectMemberClient<$Result.GetResult<Prisma.$ProjectMemberPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ProjectMember that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectMemberFindFirstOrThrowArgs} args - Arguments to find a ProjectMember
     * @example
     * // Get one ProjectMember
     * const projectMember = await prisma.projectMember.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ProjectMemberFindFirstOrThrowArgs>(args?: SelectSubset<T, ProjectMemberFindFirstOrThrowArgs<ExtArgs>>): Prisma__ProjectMemberClient<$Result.GetResult<Prisma.$ProjectMemberPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ProjectMembers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectMemberFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ProjectMembers
     * const projectMembers = await prisma.projectMember.findMany()
     * 
     * // Get first 10 ProjectMembers
     * const projectMembers = await prisma.projectMember.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const projectMemberWithIdOnly = await prisma.projectMember.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ProjectMemberFindManyArgs>(args?: SelectSubset<T, ProjectMemberFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProjectMemberPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ProjectMember.
     * @param {ProjectMemberCreateArgs} args - Arguments to create a ProjectMember.
     * @example
     * // Create one ProjectMember
     * const ProjectMember = await prisma.projectMember.create({
     *   data: {
     *     // ... data to create a ProjectMember
     *   }
     * })
     * 
     */
    create<T extends ProjectMemberCreateArgs>(args: SelectSubset<T, ProjectMemberCreateArgs<ExtArgs>>): Prisma__ProjectMemberClient<$Result.GetResult<Prisma.$ProjectMemberPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ProjectMembers.
     * @param {ProjectMemberCreateManyArgs} args - Arguments to create many ProjectMembers.
     * @example
     * // Create many ProjectMembers
     * const projectMember = await prisma.projectMember.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ProjectMemberCreateManyArgs>(args?: SelectSubset<T, ProjectMemberCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ProjectMembers and returns the data saved in the database.
     * @param {ProjectMemberCreateManyAndReturnArgs} args - Arguments to create many ProjectMembers.
     * @example
     * // Create many ProjectMembers
     * const projectMember = await prisma.projectMember.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ProjectMembers and only return the `id`
     * const projectMemberWithIdOnly = await prisma.projectMember.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ProjectMemberCreateManyAndReturnArgs>(args?: SelectSubset<T, ProjectMemberCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProjectMemberPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ProjectMember.
     * @param {ProjectMemberDeleteArgs} args - Arguments to delete one ProjectMember.
     * @example
     * // Delete one ProjectMember
     * const ProjectMember = await prisma.projectMember.delete({
     *   where: {
     *     // ... filter to delete one ProjectMember
     *   }
     * })
     * 
     */
    delete<T extends ProjectMemberDeleteArgs>(args: SelectSubset<T, ProjectMemberDeleteArgs<ExtArgs>>): Prisma__ProjectMemberClient<$Result.GetResult<Prisma.$ProjectMemberPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ProjectMember.
     * @param {ProjectMemberUpdateArgs} args - Arguments to update one ProjectMember.
     * @example
     * // Update one ProjectMember
     * const projectMember = await prisma.projectMember.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ProjectMemberUpdateArgs>(args: SelectSubset<T, ProjectMemberUpdateArgs<ExtArgs>>): Prisma__ProjectMemberClient<$Result.GetResult<Prisma.$ProjectMemberPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ProjectMembers.
     * @param {ProjectMemberDeleteManyArgs} args - Arguments to filter ProjectMembers to delete.
     * @example
     * // Delete a few ProjectMembers
     * const { count } = await prisma.projectMember.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ProjectMemberDeleteManyArgs>(args?: SelectSubset<T, ProjectMemberDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ProjectMembers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectMemberUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ProjectMembers
     * const projectMember = await prisma.projectMember.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ProjectMemberUpdateManyArgs>(args: SelectSubset<T, ProjectMemberUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ProjectMembers and returns the data updated in the database.
     * @param {ProjectMemberUpdateManyAndReturnArgs} args - Arguments to update many ProjectMembers.
     * @example
     * // Update many ProjectMembers
     * const projectMember = await prisma.projectMember.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ProjectMembers and only return the `id`
     * const projectMemberWithIdOnly = await prisma.projectMember.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ProjectMemberUpdateManyAndReturnArgs>(args: SelectSubset<T, ProjectMemberUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProjectMemberPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ProjectMember.
     * @param {ProjectMemberUpsertArgs} args - Arguments to update or create a ProjectMember.
     * @example
     * // Update or create a ProjectMember
     * const projectMember = await prisma.projectMember.upsert({
     *   create: {
     *     // ... data to create a ProjectMember
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ProjectMember we want to update
     *   }
     * })
     */
    upsert<T extends ProjectMemberUpsertArgs>(args: SelectSubset<T, ProjectMemberUpsertArgs<ExtArgs>>): Prisma__ProjectMemberClient<$Result.GetResult<Prisma.$ProjectMemberPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ProjectMembers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectMemberCountArgs} args - Arguments to filter ProjectMembers to count.
     * @example
     * // Count the number of ProjectMembers
     * const count = await prisma.projectMember.count({
     *   where: {
     *     // ... the filter for the ProjectMembers we want to count
     *   }
     * })
    **/
    count<T extends ProjectMemberCountArgs>(
      args?: Subset<T, ProjectMemberCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProjectMemberCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ProjectMember.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectMemberAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProjectMemberAggregateArgs>(args: Subset<T, ProjectMemberAggregateArgs>): Prisma.PrismaPromise<GetProjectMemberAggregateType<T>>

    /**
     * Group by ProjectMember.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectMemberGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProjectMemberGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProjectMemberGroupByArgs['orderBy'] }
        : { orderBy?: ProjectMemberGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProjectMemberGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProjectMemberGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ProjectMember model
   */
  readonly fields: ProjectMemberFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ProjectMember.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ProjectMemberClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    project<T extends ProjectDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProjectDefaultArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ProjectMember model
   */
  interface ProjectMemberFieldRefs {
    readonly id: FieldRef<"ProjectMember", 'String'>
    readonly projectId: FieldRef<"ProjectMember", 'String'>
    readonly userId: FieldRef<"ProjectMember", 'String'>
    readonly role: FieldRef<"ProjectMember", 'ProjectMemberRole'>
    readonly createdAt: FieldRef<"ProjectMember", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ProjectMember findUnique
   */
  export type ProjectMemberFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectMember
     */
    select?: ProjectMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProjectMember
     */
    omit?: ProjectMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectMemberInclude<ExtArgs> | null
    /**
     * Filter, which ProjectMember to fetch.
     */
    where: ProjectMemberWhereUniqueInput
  }

  /**
   * ProjectMember findUniqueOrThrow
   */
  export type ProjectMemberFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectMember
     */
    select?: ProjectMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProjectMember
     */
    omit?: ProjectMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectMemberInclude<ExtArgs> | null
    /**
     * Filter, which ProjectMember to fetch.
     */
    where: ProjectMemberWhereUniqueInput
  }

  /**
   * ProjectMember findFirst
   */
  export type ProjectMemberFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectMember
     */
    select?: ProjectMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProjectMember
     */
    omit?: ProjectMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectMemberInclude<ExtArgs> | null
    /**
     * Filter, which ProjectMember to fetch.
     */
    where?: ProjectMemberWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProjectMembers to fetch.
     */
    orderBy?: ProjectMemberOrderByWithRelationInput | ProjectMemberOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProjectMembers.
     */
    cursor?: ProjectMemberWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProjectMembers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProjectMembers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProjectMembers.
     */
    distinct?: ProjectMemberScalarFieldEnum | ProjectMemberScalarFieldEnum[]
  }

  /**
   * ProjectMember findFirstOrThrow
   */
  export type ProjectMemberFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectMember
     */
    select?: ProjectMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProjectMember
     */
    omit?: ProjectMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectMemberInclude<ExtArgs> | null
    /**
     * Filter, which ProjectMember to fetch.
     */
    where?: ProjectMemberWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProjectMembers to fetch.
     */
    orderBy?: ProjectMemberOrderByWithRelationInput | ProjectMemberOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProjectMembers.
     */
    cursor?: ProjectMemberWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProjectMembers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProjectMembers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProjectMembers.
     */
    distinct?: ProjectMemberScalarFieldEnum | ProjectMemberScalarFieldEnum[]
  }

  /**
   * ProjectMember findMany
   */
  export type ProjectMemberFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectMember
     */
    select?: ProjectMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProjectMember
     */
    omit?: ProjectMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectMemberInclude<ExtArgs> | null
    /**
     * Filter, which ProjectMembers to fetch.
     */
    where?: ProjectMemberWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProjectMembers to fetch.
     */
    orderBy?: ProjectMemberOrderByWithRelationInput | ProjectMemberOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ProjectMembers.
     */
    cursor?: ProjectMemberWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProjectMembers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProjectMembers.
     */
    skip?: number
    distinct?: ProjectMemberScalarFieldEnum | ProjectMemberScalarFieldEnum[]
  }

  /**
   * ProjectMember create
   */
  export type ProjectMemberCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectMember
     */
    select?: ProjectMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProjectMember
     */
    omit?: ProjectMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectMemberInclude<ExtArgs> | null
    /**
     * The data needed to create a ProjectMember.
     */
    data: XOR<ProjectMemberCreateInput, ProjectMemberUncheckedCreateInput>
  }

  /**
   * ProjectMember createMany
   */
  export type ProjectMemberCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ProjectMembers.
     */
    data: ProjectMemberCreateManyInput | ProjectMemberCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ProjectMember createManyAndReturn
   */
  export type ProjectMemberCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectMember
     */
    select?: ProjectMemberSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ProjectMember
     */
    omit?: ProjectMemberOmit<ExtArgs> | null
    /**
     * The data used to create many ProjectMembers.
     */
    data: ProjectMemberCreateManyInput | ProjectMemberCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectMemberIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ProjectMember update
   */
  export type ProjectMemberUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectMember
     */
    select?: ProjectMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProjectMember
     */
    omit?: ProjectMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectMemberInclude<ExtArgs> | null
    /**
     * The data needed to update a ProjectMember.
     */
    data: XOR<ProjectMemberUpdateInput, ProjectMemberUncheckedUpdateInput>
    /**
     * Choose, which ProjectMember to update.
     */
    where: ProjectMemberWhereUniqueInput
  }

  /**
   * ProjectMember updateMany
   */
  export type ProjectMemberUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ProjectMembers.
     */
    data: XOR<ProjectMemberUpdateManyMutationInput, ProjectMemberUncheckedUpdateManyInput>
    /**
     * Filter which ProjectMembers to update
     */
    where?: ProjectMemberWhereInput
    /**
     * Limit how many ProjectMembers to update.
     */
    limit?: number
  }

  /**
   * ProjectMember updateManyAndReturn
   */
  export type ProjectMemberUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectMember
     */
    select?: ProjectMemberSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ProjectMember
     */
    omit?: ProjectMemberOmit<ExtArgs> | null
    /**
     * The data used to update ProjectMembers.
     */
    data: XOR<ProjectMemberUpdateManyMutationInput, ProjectMemberUncheckedUpdateManyInput>
    /**
     * Filter which ProjectMembers to update
     */
    where?: ProjectMemberWhereInput
    /**
     * Limit how many ProjectMembers to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectMemberIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ProjectMember upsert
   */
  export type ProjectMemberUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectMember
     */
    select?: ProjectMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProjectMember
     */
    omit?: ProjectMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectMemberInclude<ExtArgs> | null
    /**
     * The filter to search for the ProjectMember to update in case it exists.
     */
    where: ProjectMemberWhereUniqueInput
    /**
     * In case the ProjectMember found by the `where` argument doesn't exist, create a new ProjectMember with this data.
     */
    create: XOR<ProjectMemberCreateInput, ProjectMemberUncheckedCreateInput>
    /**
     * In case the ProjectMember was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ProjectMemberUpdateInput, ProjectMemberUncheckedUpdateInput>
  }

  /**
   * ProjectMember delete
   */
  export type ProjectMemberDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectMember
     */
    select?: ProjectMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProjectMember
     */
    omit?: ProjectMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectMemberInclude<ExtArgs> | null
    /**
     * Filter which ProjectMember to delete.
     */
    where: ProjectMemberWhereUniqueInput
  }

  /**
   * ProjectMember deleteMany
   */
  export type ProjectMemberDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProjectMembers to delete
     */
    where?: ProjectMemberWhereInput
    /**
     * Limit how many ProjectMembers to delete.
     */
    limit?: number
  }

  /**
   * ProjectMember without action
   */
  export type ProjectMemberDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectMember
     */
    select?: ProjectMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProjectMember
     */
    omit?: ProjectMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectMemberInclude<ExtArgs> | null
  }


  /**
   * Model ProjectUpdate
   */

  export type AggregateProjectUpdate = {
    _count: ProjectUpdateCountAggregateOutputType | null
    _min: ProjectUpdateMinAggregateOutputType | null
    _max: ProjectUpdateMaxAggregateOutputType | null
  }

  export type ProjectUpdateMinAggregateOutputType = {
    id: string | null
    projectId: string | null
    authorId: string | null
    notes: string | null
    statusSnapshot: string | null
    createdAt: Date | null
  }

  export type ProjectUpdateMaxAggregateOutputType = {
    id: string | null
    projectId: string | null
    authorId: string | null
    notes: string | null
    statusSnapshot: string | null
    createdAt: Date | null
  }

  export type ProjectUpdateCountAggregateOutputType = {
    id: number
    projectId: number
    authorId: number
    notes: number
    statusSnapshot: number
    createdAt: number
    _all: number
  }


  export type ProjectUpdateMinAggregateInputType = {
    id?: true
    projectId?: true
    authorId?: true
    notes?: true
    statusSnapshot?: true
    createdAt?: true
  }

  export type ProjectUpdateMaxAggregateInputType = {
    id?: true
    projectId?: true
    authorId?: true
    notes?: true
    statusSnapshot?: true
    createdAt?: true
  }

  export type ProjectUpdateCountAggregateInputType = {
    id?: true
    projectId?: true
    authorId?: true
    notes?: true
    statusSnapshot?: true
    createdAt?: true
    _all?: true
  }

  export type ProjectUpdateAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProjectUpdate to aggregate.
     */
    where?: ProjectUpdateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProjectUpdates to fetch.
     */
    orderBy?: ProjectUpdateOrderByWithRelationInput | ProjectUpdateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ProjectUpdateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProjectUpdates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProjectUpdates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ProjectUpdates
    **/
    _count?: true | ProjectUpdateCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProjectUpdateMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProjectUpdateMaxAggregateInputType
  }

  export type GetProjectUpdateAggregateType<T extends ProjectUpdateAggregateArgs> = {
        [P in keyof T & keyof AggregateProjectUpdate]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProjectUpdate[P]>
      : GetScalarType<T[P], AggregateProjectUpdate[P]>
  }




  export type ProjectUpdateGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProjectUpdateWhereInput
    orderBy?: ProjectUpdateOrderByWithAggregationInput | ProjectUpdateOrderByWithAggregationInput[]
    by: ProjectUpdateScalarFieldEnum[] | ProjectUpdateScalarFieldEnum
    having?: ProjectUpdateScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProjectUpdateCountAggregateInputType | true
    _min?: ProjectUpdateMinAggregateInputType
    _max?: ProjectUpdateMaxAggregateInputType
  }

  export type ProjectUpdateGroupByOutputType = {
    id: string
    projectId: string
    authorId: string
    notes: string
    statusSnapshot: string | null
    createdAt: Date
    _count: ProjectUpdateCountAggregateOutputType | null
    _min: ProjectUpdateMinAggregateOutputType | null
    _max: ProjectUpdateMaxAggregateOutputType | null
  }

  type GetProjectUpdateGroupByPayload<T extends ProjectUpdateGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ProjectUpdateGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProjectUpdateGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProjectUpdateGroupByOutputType[P]>
            : GetScalarType<T[P], ProjectUpdateGroupByOutputType[P]>
        }
      >
    >


  export type ProjectUpdateSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    projectId?: boolean
    authorId?: boolean
    notes?: boolean
    statusSnapshot?: boolean
    createdAt?: boolean
    project?: boolean | ProjectDefaultArgs<ExtArgs>
    author?: boolean | UserDefaultArgs<ExtArgs>
    media?: boolean | ProjectUpdate$mediaArgs<ExtArgs>
    _count?: boolean | ProjectUpdateCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["projectUpdate"]>

  export type ProjectUpdateSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    projectId?: boolean
    authorId?: boolean
    notes?: boolean
    statusSnapshot?: boolean
    createdAt?: boolean
    project?: boolean | ProjectDefaultArgs<ExtArgs>
    author?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["projectUpdate"]>

  export type ProjectUpdateSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    projectId?: boolean
    authorId?: boolean
    notes?: boolean
    statusSnapshot?: boolean
    createdAt?: boolean
    project?: boolean | ProjectDefaultArgs<ExtArgs>
    author?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["projectUpdate"]>

  export type ProjectUpdateSelectScalar = {
    id?: boolean
    projectId?: boolean
    authorId?: boolean
    notes?: boolean
    statusSnapshot?: boolean
    createdAt?: boolean
  }

  export type ProjectUpdateOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "projectId" | "authorId" | "notes" | "statusSnapshot" | "createdAt", ExtArgs["result"]["projectUpdate"]>
  export type ProjectUpdateInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    project?: boolean | ProjectDefaultArgs<ExtArgs>
    author?: boolean | UserDefaultArgs<ExtArgs>
    media?: boolean | ProjectUpdate$mediaArgs<ExtArgs>
    _count?: boolean | ProjectUpdateCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ProjectUpdateIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    project?: boolean | ProjectDefaultArgs<ExtArgs>
    author?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type ProjectUpdateIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    project?: boolean | ProjectDefaultArgs<ExtArgs>
    author?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $ProjectUpdatePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ProjectUpdate"
    objects: {
      project: Prisma.$ProjectPayload<ExtArgs>
      author: Prisma.$UserPayload<ExtArgs>
      media: Prisma.$MediaPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      projectId: string
      authorId: string
      notes: string
      statusSnapshot: string | null
      createdAt: Date
    }, ExtArgs["result"]["projectUpdate"]>
    composites: {}
  }

  type ProjectUpdateGetPayload<S extends boolean | null | undefined | ProjectUpdateDefaultArgs> = $Result.GetResult<Prisma.$ProjectUpdatePayload, S>

  type ProjectUpdateCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ProjectUpdateFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ProjectUpdateCountAggregateInputType | true
    }

  export interface ProjectUpdateDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ProjectUpdate'], meta: { name: 'ProjectUpdate' } }
    /**
     * Find zero or one ProjectUpdate that matches the filter.
     * @param {ProjectUpdateFindUniqueArgs} args - Arguments to find a ProjectUpdate
     * @example
     * // Get one ProjectUpdate
     * const projectUpdate = await prisma.projectUpdate.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ProjectUpdateFindUniqueArgs>(args: SelectSubset<T, ProjectUpdateFindUniqueArgs<ExtArgs>>): Prisma__ProjectUpdateClient<$Result.GetResult<Prisma.$ProjectUpdatePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ProjectUpdate that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ProjectUpdateFindUniqueOrThrowArgs} args - Arguments to find a ProjectUpdate
     * @example
     * // Get one ProjectUpdate
     * const projectUpdate = await prisma.projectUpdate.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ProjectUpdateFindUniqueOrThrowArgs>(args: SelectSubset<T, ProjectUpdateFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ProjectUpdateClient<$Result.GetResult<Prisma.$ProjectUpdatePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ProjectUpdate that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectUpdateFindFirstArgs} args - Arguments to find a ProjectUpdate
     * @example
     * // Get one ProjectUpdate
     * const projectUpdate = await prisma.projectUpdate.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ProjectUpdateFindFirstArgs>(args?: SelectSubset<T, ProjectUpdateFindFirstArgs<ExtArgs>>): Prisma__ProjectUpdateClient<$Result.GetResult<Prisma.$ProjectUpdatePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ProjectUpdate that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectUpdateFindFirstOrThrowArgs} args - Arguments to find a ProjectUpdate
     * @example
     * // Get one ProjectUpdate
     * const projectUpdate = await prisma.projectUpdate.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ProjectUpdateFindFirstOrThrowArgs>(args?: SelectSubset<T, ProjectUpdateFindFirstOrThrowArgs<ExtArgs>>): Prisma__ProjectUpdateClient<$Result.GetResult<Prisma.$ProjectUpdatePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ProjectUpdates that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectUpdateFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ProjectUpdates
     * const projectUpdates = await prisma.projectUpdate.findMany()
     * 
     * // Get first 10 ProjectUpdates
     * const projectUpdates = await prisma.projectUpdate.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const projectUpdateWithIdOnly = await prisma.projectUpdate.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ProjectUpdateFindManyArgs>(args?: SelectSubset<T, ProjectUpdateFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProjectUpdatePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ProjectUpdate.
     * @param {ProjectUpdateCreateArgs} args - Arguments to create a ProjectUpdate.
     * @example
     * // Create one ProjectUpdate
     * const ProjectUpdate = await prisma.projectUpdate.create({
     *   data: {
     *     // ... data to create a ProjectUpdate
     *   }
     * })
     * 
     */
    create<T extends ProjectUpdateCreateArgs>(args: SelectSubset<T, ProjectUpdateCreateArgs<ExtArgs>>): Prisma__ProjectUpdateClient<$Result.GetResult<Prisma.$ProjectUpdatePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ProjectUpdates.
     * @param {ProjectUpdateCreateManyArgs} args - Arguments to create many ProjectUpdates.
     * @example
     * // Create many ProjectUpdates
     * const projectUpdate = await prisma.projectUpdate.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ProjectUpdateCreateManyArgs>(args?: SelectSubset<T, ProjectUpdateCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ProjectUpdates and returns the data saved in the database.
     * @param {ProjectUpdateCreateManyAndReturnArgs} args - Arguments to create many ProjectUpdates.
     * @example
     * // Create many ProjectUpdates
     * const projectUpdate = await prisma.projectUpdate.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ProjectUpdates and only return the `id`
     * const projectUpdateWithIdOnly = await prisma.projectUpdate.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ProjectUpdateCreateManyAndReturnArgs>(args?: SelectSubset<T, ProjectUpdateCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProjectUpdatePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ProjectUpdate.
     * @param {ProjectUpdateDeleteArgs} args - Arguments to delete one ProjectUpdate.
     * @example
     * // Delete one ProjectUpdate
     * const ProjectUpdate = await prisma.projectUpdate.delete({
     *   where: {
     *     // ... filter to delete one ProjectUpdate
     *   }
     * })
     * 
     */
    delete<T extends ProjectUpdateDeleteArgs>(args: SelectSubset<T, ProjectUpdateDeleteArgs<ExtArgs>>): Prisma__ProjectUpdateClient<$Result.GetResult<Prisma.$ProjectUpdatePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ProjectUpdate.
     * @param {ProjectUpdateUpdateArgs} args - Arguments to update one ProjectUpdate.
     * @example
     * // Update one ProjectUpdate
     * const projectUpdate = await prisma.projectUpdate.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ProjectUpdateUpdateArgs>(args: SelectSubset<T, ProjectUpdateUpdateArgs<ExtArgs>>): Prisma__ProjectUpdateClient<$Result.GetResult<Prisma.$ProjectUpdatePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ProjectUpdates.
     * @param {ProjectUpdateDeleteManyArgs} args - Arguments to filter ProjectUpdates to delete.
     * @example
     * // Delete a few ProjectUpdates
     * const { count } = await prisma.projectUpdate.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ProjectUpdateDeleteManyArgs>(args?: SelectSubset<T, ProjectUpdateDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ProjectUpdates.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectUpdateUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ProjectUpdates
     * const projectUpdate = await prisma.projectUpdate.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ProjectUpdateUpdateManyArgs>(args: SelectSubset<T, ProjectUpdateUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ProjectUpdates and returns the data updated in the database.
     * @param {ProjectUpdateUpdateManyAndReturnArgs} args - Arguments to update many ProjectUpdates.
     * @example
     * // Update many ProjectUpdates
     * const projectUpdate = await prisma.projectUpdate.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ProjectUpdates and only return the `id`
     * const projectUpdateWithIdOnly = await prisma.projectUpdate.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ProjectUpdateUpdateManyAndReturnArgs>(args: SelectSubset<T, ProjectUpdateUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProjectUpdatePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ProjectUpdate.
     * @param {ProjectUpdateUpsertArgs} args - Arguments to update or create a ProjectUpdate.
     * @example
     * // Update or create a ProjectUpdate
     * const projectUpdate = await prisma.projectUpdate.upsert({
     *   create: {
     *     // ... data to create a ProjectUpdate
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ProjectUpdate we want to update
     *   }
     * })
     */
    upsert<T extends ProjectUpdateUpsertArgs>(args: SelectSubset<T, ProjectUpdateUpsertArgs<ExtArgs>>): Prisma__ProjectUpdateClient<$Result.GetResult<Prisma.$ProjectUpdatePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ProjectUpdates.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectUpdateCountArgs} args - Arguments to filter ProjectUpdates to count.
     * @example
     * // Count the number of ProjectUpdates
     * const count = await prisma.projectUpdate.count({
     *   where: {
     *     // ... the filter for the ProjectUpdates we want to count
     *   }
     * })
    **/
    count<T extends ProjectUpdateCountArgs>(
      args?: Subset<T, ProjectUpdateCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProjectUpdateCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ProjectUpdate.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectUpdateAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProjectUpdateAggregateArgs>(args: Subset<T, ProjectUpdateAggregateArgs>): Prisma.PrismaPromise<GetProjectUpdateAggregateType<T>>

    /**
     * Group by ProjectUpdate.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectUpdateGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProjectUpdateGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProjectUpdateGroupByArgs['orderBy'] }
        : { orderBy?: ProjectUpdateGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProjectUpdateGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProjectUpdateGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ProjectUpdate model
   */
  readonly fields: ProjectUpdateFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ProjectUpdate.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ProjectUpdateClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    project<T extends ProjectDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProjectDefaultArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    author<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    media<T extends ProjectUpdate$mediaArgs<ExtArgs> = {}>(args?: Subset<T, ProjectUpdate$mediaArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MediaPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ProjectUpdate model
   */
  interface ProjectUpdateFieldRefs {
    readonly id: FieldRef<"ProjectUpdate", 'String'>
    readonly projectId: FieldRef<"ProjectUpdate", 'String'>
    readonly authorId: FieldRef<"ProjectUpdate", 'String'>
    readonly notes: FieldRef<"ProjectUpdate", 'String'>
    readonly statusSnapshot: FieldRef<"ProjectUpdate", 'String'>
    readonly createdAt: FieldRef<"ProjectUpdate", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ProjectUpdate findUnique
   */
  export type ProjectUpdateFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectUpdate
     */
    select?: ProjectUpdateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProjectUpdate
     */
    omit?: ProjectUpdateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectUpdateInclude<ExtArgs> | null
    /**
     * Filter, which ProjectUpdate to fetch.
     */
    where: ProjectUpdateWhereUniqueInput
  }

  /**
   * ProjectUpdate findUniqueOrThrow
   */
  export type ProjectUpdateFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectUpdate
     */
    select?: ProjectUpdateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProjectUpdate
     */
    omit?: ProjectUpdateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectUpdateInclude<ExtArgs> | null
    /**
     * Filter, which ProjectUpdate to fetch.
     */
    where: ProjectUpdateWhereUniqueInput
  }

  /**
   * ProjectUpdate findFirst
   */
  export type ProjectUpdateFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectUpdate
     */
    select?: ProjectUpdateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProjectUpdate
     */
    omit?: ProjectUpdateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectUpdateInclude<ExtArgs> | null
    /**
     * Filter, which ProjectUpdate to fetch.
     */
    where?: ProjectUpdateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProjectUpdates to fetch.
     */
    orderBy?: ProjectUpdateOrderByWithRelationInput | ProjectUpdateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProjectUpdates.
     */
    cursor?: ProjectUpdateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProjectUpdates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProjectUpdates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProjectUpdates.
     */
    distinct?: ProjectUpdateScalarFieldEnum | ProjectUpdateScalarFieldEnum[]
  }

  /**
   * ProjectUpdate findFirstOrThrow
   */
  export type ProjectUpdateFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectUpdate
     */
    select?: ProjectUpdateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProjectUpdate
     */
    omit?: ProjectUpdateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectUpdateInclude<ExtArgs> | null
    /**
     * Filter, which ProjectUpdate to fetch.
     */
    where?: ProjectUpdateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProjectUpdates to fetch.
     */
    orderBy?: ProjectUpdateOrderByWithRelationInput | ProjectUpdateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProjectUpdates.
     */
    cursor?: ProjectUpdateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProjectUpdates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProjectUpdates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProjectUpdates.
     */
    distinct?: ProjectUpdateScalarFieldEnum | ProjectUpdateScalarFieldEnum[]
  }

  /**
   * ProjectUpdate findMany
   */
  export type ProjectUpdateFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectUpdate
     */
    select?: ProjectUpdateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProjectUpdate
     */
    omit?: ProjectUpdateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectUpdateInclude<ExtArgs> | null
    /**
     * Filter, which ProjectUpdates to fetch.
     */
    where?: ProjectUpdateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProjectUpdates to fetch.
     */
    orderBy?: ProjectUpdateOrderByWithRelationInput | ProjectUpdateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ProjectUpdates.
     */
    cursor?: ProjectUpdateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProjectUpdates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProjectUpdates.
     */
    skip?: number
    distinct?: ProjectUpdateScalarFieldEnum | ProjectUpdateScalarFieldEnum[]
  }

  /**
   * ProjectUpdate create
   */
  export type ProjectUpdateCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectUpdate
     */
    select?: ProjectUpdateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProjectUpdate
     */
    omit?: ProjectUpdateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectUpdateInclude<ExtArgs> | null
    /**
     * The data needed to create a ProjectUpdate.
     */
    data: XOR<ProjectUpdateCreateInput, ProjectUpdateUncheckedCreateInput>
  }

  /**
   * ProjectUpdate createMany
   */
  export type ProjectUpdateCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ProjectUpdates.
     */
    data: ProjectUpdateCreateManyInput | ProjectUpdateCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ProjectUpdate createManyAndReturn
   */
  export type ProjectUpdateCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectUpdate
     */
    select?: ProjectUpdateSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ProjectUpdate
     */
    omit?: ProjectUpdateOmit<ExtArgs> | null
    /**
     * The data used to create many ProjectUpdates.
     */
    data: ProjectUpdateCreateManyInput | ProjectUpdateCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectUpdateIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ProjectUpdate update
   */
  export type ProjectUpdateUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectUpdate
     */
    select?: ProjectUpdateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProjectUpdate
     */
    omit?: ProjectUpdateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectUpdateInclude<ExtArgs> | null
    /**
     * The data needed to update a ProjectUpdate.
     */
    data: XOR<ProjectUpdateUpdateInput, ProjectUpdateUncheckedUpdateInput>
    /**
     * Choose, which ProjectUpdate to update.
     */
    where: ProjectUpdateWhereUniqueInput
  }

  /**
   * ProjectUpdate updateMany
   */
  export type ProjectUpdateUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ProjectUpdates.
     */
    data: XOR<ProjectUpdateUpdateManyMutationInput, ProjectUpdateUncheckedUpdateManyInput>
    /**
     * Filter which ProjectUpdates to update
     */
    where?: ProjectUpdateWhereInput
    /**
     * Limit how many ProjectUpdates to update.
     */
    limit?: number
  }

  /**
   * ProjectUpdate updateManyAndReturn
   */
  export type ProjectUpdateUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectUpdate
     */
    select?: ProjectUpdateSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ProjectUpdate
     */
    omit?: ProjectUpdateOmit<ExtArgs> | null
    /**
     * The data used to update ProjectUpdates.
     */
    data: XOR<ProjectUpdateUpdateManyMutationInput, ProjectUpdateUncheckedUpdateManyInput>
    /**
     * Filter which ProjectUpdates to update
     */
    where?: ProjectUpdateWhereInput
    /**
     * Limit how many ProjectUpdates to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectUpdateIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ProjectUpdate upsert
   */
  export type ProjectUpdateUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectUpdate
     */
    select?: ProjectUpdateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProjectUpdate
     */
    omit?: ProjectUpdateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectUpdateInclude<ExtArgs> | null
    /**
     * The filter to search for the ProjectUpdate to update in case it exists.
     */
    where: ProjectUpdateWhereUniqueInput
    /**
     * In case the ProjectUpdate found by the `where` argument doesn't exist, create a new ProjectUpdate with this data.
     */
    create: XOR<ProjectUpdateCreateInput, ProjectUpdateUncheckedCreateInput>
    /**
     * In case the ProjectUpdate was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ProjectUpdateUpdateInput, ProjectUpdateUncheckedUpdateInput>
  }

  /**
   * ProjectUpdate delete
   */
  export type ProjectUpdateDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectUpdate
     */
    select?: ProjectUpdateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProjectUpdate
     */
    omit?: ProjectUpdateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectUpdateInclude<ExtArgs> | null
    /**
     * Filter which ProjectUpdate to delete.
     */
    where: ProjectUpdateWhereUniqueInput
  }

  /**
   * ProjectUpdate deleteMany
   */
  export type ProjectUpdateDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProjectUpdates to delete
     */
    where?: ProjectUpdateWhereInput
    /**
     * Limit how many ProjectUpdates to delete.
     */
    limit?: number
  }

  /**
   * ProjectUpdate.media
   */
  export type ProjectUpdate$mediaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Media
     */
    select?: MediaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Media
     */
    omit?: MediaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MediaInclude<ExtArgs> | null
    where?: MediaWhereInput
    orderBy?: MediaOrderByWithRelationInput | MediaOrderByWithRelationInput[]
    cursor?: MediaWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MediaScalarFieldEnum | MediaScalarFieldEnum[]
  }

  /**
   * ProjectUpdate without action
   */
  export type ProjectUpdateDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectUpdate
     */
    select?: ProjectUpdateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProjectUpdate
     */
    omit?: ProjectUpdateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectUpdateInclude<ExtArgs> | null
  }


  /**
   * Model Media
   */

  export type AggregateMedia = {
    _count: MediaCountAggregateOutputType | null
    _avg: MediaAvgAggregateOutputType | null
    _sum: MediaSumAggregateOutputType | null
    _min: MediaMinAggregateOutputType | null
    _max: MediaMaxAggregateOutputType | null
  }

  export type MediaAvgAggregateOutputType = {
    fileSize: number | null
    version: number | null
  }

  export type MediaSumAggregateOutputType = {
    fileSize: number | null
    version: number | null
  }

  export type MediaMinAggregateOutputType = {
    id: string | null
    projectId: string | null
    projectUpdateId: string | null
    paymentId: string | null
    type: $Enums.MediaType | null
    fileKey: string | null
    fileUrl: string | null
    mimeType: string | null
    fileSize: number | null
    createdById: string | null
    approvedBy: string | null
    approvedAt: Date | null
    version: number | null
    createdAt: Date | null
    queryId: string | null
  }

  export type MediaMaxAggregateOutputType = {
    id: string | null
    projectId: string | null
    projectUpdateId: string | null
    paymentId: string | null
    type: $Enums.MediaType | null
    fileKey: string | null
    fileUrl: string | null
    mimeType: string | null
    fileSize: number | null
    createdById: string | null
    approvedBy: string | null
    approvedAt: Date | null
    version: number | null
    createdAt: Date | null
    queryId: string | null
  }

  export type MediaCountAggregateOutputType = {
    id: number
    projectId: number
    projectUpdateId: number
    paymentId: number
    type: number
    fileKey: number
    fileUrl: number
    mimeType: number
    fileSize: number
    createdById: number
    approvedBy: number
    approvedAt: number
    version: number
    createdAt: number
    queryId: number
    _all: number
  }


  export type MediaAvgAggregateInputType = {
    fileSize?: true
    version?: true
  }

  export type MediaSumAggregateInputType = {
    fileSize?: true
    version?: true
  }

  export type MediaMinAggregateInputType = {
    id?: true
    projectId?: true
    projectUpdateId?: true
    paymentId?: true
    type?: true
    fileKey?: true
    fileUrl?: true
    mimeType?: true
    fileSize?: true
    createdById?: true
    approvedBy?: true
    approvedAt?: true
    version?: true
    createdAt?: true
    queryId?: true
  }

  export type MediaMaxAggregateInputType = {
    id?: true
    projectId?: true
    projectUpdateId?: true
    paymentId?: true
    type?: true
    fileKey?: true
    fileUrl?: true
    mimeType?: true
    fileSize?: true
    createdById?: true
    approvedBy?: true
    approvedAt?: true
    version?: true
    createdAt?: true
    queryId?: true
  }

  export type MediaCountAggregateInputType = {
    id?: true
    projectId?: true
    projectUpdateId?: true
    paymentId?: true
    type?: true
    fileKey?: true
    fileUrl?: true
    mimeType?: true
    fileSize?: true
    createdById?: true
    approvedBy?: true
    approvedAt?: true
    version?: true
    createdAt?: true
    queryId?: true
    _all?: true
  }

  export type MediaAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Media to aggregate.
     */
    where?: MediaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Media to fetch.
     */
    orderBy?: MediaOrderByWithRelationInput | MediaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MediaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Media from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Media.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Media
    **/
    _count?: true | MediaCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: MediaAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: MediaSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MediaMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MediaMaxAggregateInputType
  }

  export type GetMediaAggregateType<T extends MediaAggregateArgs> = {
        [P in keyof T & keyof AggregateMedia]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMedia[P]>
      : GetScalarType<T[P], AggregateMedia[P]>
  }




  export type MediaGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MediaWhereInput
    orderBy?: MediaOrderByWithAggregationInput | MediaOrderByWithAggregationInput[]
    by: MediaScalarFieldEnum[] | MediaScalarFieldEnum
    having?: MediaScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MediaCountAggregateInputType | true
    _avg?: MediaAvgAggregateInputType
    _sum?: MediaSumAggregateInputType
    _min?: MediaMinAggregateInputType
    _max?: MediaMaxAggregateInputType
  }

  export type MediaGroupByOutputType = {
    id: string
    projectId: string
    projectUpdateId: string | null
    paymentId: string | null
    type: $Enums.MediaType
    fileKey: string
    fileUrl: string
    mimeType: string
    fileSize: number
    createdById: string
    approvedBy: string | null
    approvedAt: Date | null
    version: number | null
    createdAt: Date
    queryId: string | null
    _count: MediaCountAggregateOutputType | null
    _avg: MediaAvgAggregateOutputType | null
    _sum: MediaSumAggregateOutputType | null
    _min: MediaMinAggregateOutputType | null
    _max: MediaMaxAggregateOutputType | null
  }

  type GetMediaGroupByPayload<T extends MediaGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MediaGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MediaGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MediaGroupByOutputType[P]>
            : GetScalarType<T[P], MediaGroupByOutputType[P]>
        }
      >
    >


  export type MediaSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    projectId?: boolean
    projectUpdateId?: boolean
    paymentId?: boolean
    type?: boolean
    fileKey?: boolean
    fileUrl?: boolean
    mimeType?: boolean
    fileSize?: boolean
    createdById?: boolean
    approvedBy?: boolean
    approvedAt?: boolean
    version?: boolean
    createdAt?: boolean
    queryId?: boolean
    project?: boolean | ProjectDefaultArgs<ExtArgs>
    projectUpdate?: boolean | Media$projectUpdateArgs<ExtArgs>
    payment?: boolean | Media$paymentArgs<ExtArgs>
    createdBy?: boolean | UserDefaultArgs<ExtArgs>
    inspectionResponses?: boolean | Media$inspectionResponsesArgs<ExtArgs>
    query?: boolean | Media$queryArgs<ExtArgs>
    _count?: boolean | MediaCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["media"]>

  export type MediaSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    projectId?: boolean
    projectUpdateId?: boolean
    paymentId?: boolean
    type?: boolean
    fileKey?: boolean
    fileUrl?: boolean
    mimeType?: boolean
    fileSize?: boolean
    createdById?: boolean
    approvedBy?: boolean
    approvedAt?: boolean
    version?: boolean
    createdAt?: boolean
    queryId?: boolean
    project?: boolean | ProjectDefaultArgs<ExtArgs>
    projectUpdate?: boolean | Media$projectUpdateArgs<ExtArgs>
    payment?: boolean | Media$paymentArgs<ExtArgs>
    createdBy?: boolean | UserDefaultArgs<ExtArgs>
    query?: boolean | Media$queryArgs<ExtArgs>
  }, ExtArgs["result"]["media"]>

  export type MediaSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    projectId?: boolean
    projectUpdateId?: boolean
    paymentId?: boolean
    type?: boolean
    fileKey?: boolean
    fileUrl?: boolean
    mimeType?: boolean
    fileSize?: boolean
    createdById?: boolean
    approvedBy?: boolean
    approvedAt?: boolean
    version?: boolean
    createdAt?: boolean
    queryId?: boolean
    project?: boolean | ProjectDefaultArgs<ExtArgs>
    projectUpdate?: boolean | Media$projectUpdateArgs<ExtArgs>
    payment?: boolean | Media$paymentArgs<ExtArgs>
    createdBy?: boolean | UserDefaultArgs<ExtArgs>
    query?: boolean | Media$queryArgs<ExtArgs>
  }, ExtArgs["result"]["media"]>

  export type MediaSelectScalar = {
    id?: boolean
    projectId?: boolean
    projectUpdateId?: boolean
    paymentId?: boolean
    type?: boolean
    fileKey?: boolean
    fileUrl?: boolean
    mimeType?: boolean
    fileSize?: boolean
    createdById?: boolean
    approvedBy?: boolean
    approvedAt?: boolean
    version?: boolean
    createdAt?: boolean
    queryId?: boolean
  }

  export type MediaOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "projectId" | "projectUpdateId" | "paymentId" | "type" | "fileKey" | "fileUrl" | "mimeType" | "fileSize" | "createdById" | "approvedBy" | "approvedAt" | "version" | "createdAt" | "queryId", ExtArgs["result"]["media"]>
  export type MediaInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    project?: boolean | ProjectDefaultArgs<ExtArgs>
    projectUpdate?: boolean | Media$projectUpdateArgs<ExtArgs>
    payment?: boolean | Media$paymentArgs<ExtArgs>
    createdBy?: boolean | UserDefaultArgs<ExtArgs>
    inspectionResponses?: boolean | Media$inspectionResponsesArgs<ExtArgs>
    query?: boolean | Media$queryArgs<ExtArgs>
    _count?: boolean | MediaCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type MediaIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    project?: boolean | ProjectDefaultArgs<ExtArgs>
    projectUpdate?: boolean | Media$projectUpdateArgs<ExtArgs>
    payment?: boolean | Media$paymentArgs<ExtArgs>
    createdBy?: boolean | UserDefaultArgs<ExtArgs>
    query?: boolean | Media$queryArgs<ExtArgs>
  }
  export type MediaIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    project?: boolean | ProjectDefaultArgs<ExtArgs>
    projectUpdate?: boolean | Media$projectUpdateArgs<ExtArgs>
    payment?: boolean | Media$paymentArgs<ExtArgs>
    createdBy?: boolean | UserDefaultArgs<ExtArgs>
    query?: boolean | Media$queryArgs<ExtArgs>
  }

  export type $MediaPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Media"
    objects: {
      project: Prisma.$ProjectPayload<ExtArgs>
      projectUpdate: Prisma.$ProjectUpdatePayload<ExtArgs> | null
      payment: Prisma.$PaymentPayload<ExtArgs> | null
      createdBy: Prisma.$UserPayload<ExtArgs>
      inspectionResponses: Prisma.$InspectionResponsePayload<ExtArgs>[]
      query: Prisma.$QueryPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      projectId: string
      projectUpdateId: string | null
      paymentId: string | null
      type: $Enums.MediaType
      fileKey: string
      fileUrl: string
      mimeType: string
      fileSize: number
      createdById: string
      approvedBy: string | null
      approvedAt: Date | null
      version: number | null
      createdAt: Date
      queryId: string | null
    }, ExtArgs["result"]["media"]>
    composites: {}
  }

  type MediaGetPayload<S extends boolean | null | undefined | MediaDefaultArgs> = $Result.GetResult<Prisma.$MediaPayload, S>

  type MediaCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<MediaFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: MediaCountAggregateInputType | true
    }

  export interface MediaDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Media'], meta: { name: 'Media' } }
    /**
     * Find zero or one Media that matches the filter.
     * @param {MediaFindUniqueArgs} args - Arguments to find a Media
     * @example
     * // Get one Media
     * const media = await prisma.media.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MediaFindUniqueArgs>(args: SelectSubset<T, MediaFindUniqueArgs<ExtArgs>>): Prisma__MediaClient<$Result.GetResult<Prisma.$MediaPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Media that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {MediaFindUniqueOrThrowArgs} args - Arguments to find a Media
     * @example
     * // Get one Media
     * const media = await prisma.media.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MediaFindUniqueOrThrowArgs>(args: SelectSubset<T, MediaFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MediaClient<$Result.GetResult<Prisma.$MediaPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Media that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MediaFindFirstArgs} args - Arguments to find a Media
     * @example
     * // Get one Media
     * const media = await prisma.media.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MediaFindFirstArgs>(args?: SelectSubset<T, MediaFindFirstArgs<ExtArgs>>): Prisma__MediaClient<$Result.GetResult<Prisma.$MediaPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Media that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MediaFindFirstOrThrowArgs} args - Arguments to find a Media
     * @example
     * // Get one Media
     * const media = await prisma.media.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MediaFindFirstOrThrowArgs>(args?: SelectSubset<T, MediaFindFirstOrThrowArgs<ExtArgs>>): Prisma__MediaClient<$Result.GetResult<Prisma.$MediaPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Media that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MediaFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Media
     * const media = await prisma.media.findMany()
     * 
     * // Get first 10 Media
     * const media = await prisma.media.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const mediaWithIdOnly = await prisma.media.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends MediaFindManyArgs>(args?: SelectSubset<T, MediaFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MediaPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Media.
     * @param {MediaCreateArgs} args - Arguments to create a Media.
     * @example
     * // Create one Media
     * const Media = await prisma.media.create({
     *   data: {
     *     // ... data to create a Media
     *   }
     * })
     * 
     */
    create<T extends MediaCreateArgs>(args: SelectSubset<T, MediaCreateArgs<ExtArgs>>): Prisma__MediaClient<$Result.GetResult<Prisma.$MediaPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Media.
     * @param {MediaCreateManyArgs} args - Arguments to create many Media.
     * @example
     * // Create many Media
     * const media = await prisma.media.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MediaCreateManyArgs>(args?: SelectSubset<T, MediaCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Media and returns the data saved in the database.
     * @param {MediaCreateManyAndReturnArgs} args - Arguments to create many Media.
     * @example
     * // Create many Media
     * const media = await prisma.media.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Media and only return the `id`
     * const mediaWithIdOnly = await prisma.media.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends MediaCreateManyAndReturnArgs>(args?: SelectSubset<T, MediaCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MediaPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Media.
     * @param {MediaDeleteArgs} args - Arguments to delete one Media.
     * @example
     * // Delete one Media
     * const Media = await prisma.media.delete({
     *   where: {
     *     // ... filter to delete one Media
     *   }
     * })
     * 
     */
    delete<T extends MediaDeleteArgs>(args: SelectSubset<T, MediaDeleteArgs<ExtArgs>>): Prisma__MediaClient<$Result.GetResult<Prisma.$MediaPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Media.
     * @param {MediaUpdateArgs} args - Arguments to update one Media.
     * @example
     * // Update one Media
     * const media = await prisma.media.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MediaUpdateArgs>(args: SelectSubset<T, MediaUpdateArgs<ExtArgs>>): Prisma__MediaClient<$Result.GetResult<Prisma.$MediaPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Media.
     * @param {MediaDeleteManyArgs} args - Arguments to filter Media to delete.
     * @example
     * // Delete a few Media
     * const { count } = await prisma.media.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MediaDeleteManyArgs>(args?: SelectSubset<T, MediaDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Media.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MediaUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Media
     * const media = await prisma.media.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MediaUpdateManyArgs>(args: SelectSubset<T, MediaUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Media and returns the data updated in the database.
     * @param {MediaUpdateManyAndReturnArgs} args - Arguments to update many Media.
     * @example
     * // Update many Media
     * const media = await prisma.media.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Media and only return the `id`
     * const mediaWithIdOnly = await prisma.media.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends MediaUpdateManyAndReturnArgs>(args: SelectSubset<T, MediaUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MediaPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Media.
     * @param {MediaUpsertArgs} args - Arguments to update or create a Media.
     * @example
     * // Update or create a Media
     * const media = await prisma.media.upsert({
     *   create: {
     *     // ... data to create a Media
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Media we want to update
     *   }
     * })
     */
    upsert<T extends MediaUpsertArgs>(args: SelectSubset<T, MediaUpsertArgs<ExtArgs>>): Prisma__MediaClient<$Result.GetResult<Prisma.$MediaPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Media.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MediaCountArgs} args - Arguments to filter Media to count.
     * @example
     * // Count the number of Media
     * const count = await prisma.media.count({
     *   where: {
     *     // ... the filter for the Media we want to count
     *   }
     * })
    **/
    count<T extends MediaCountArgs>(
      args?: Subset<T, MediaCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MediaCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Media.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MediaAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MediaAggregateArgs>(args: Subset<T, MediaAggregateArgs>): Prisma.PrismaPromise<GetMediaAggregateType<T>>

    /**
     * Group by Media.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MediaGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MediaGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MediaGroupByArgs['orderBy'] }
        : { orderBy?: MediaGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MediaGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMediaGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Media model
   */
  readonly fields: MediaFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Media.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MediaClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    project<T extends ProjectDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProjectDefaultArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    projectUpdate<T extends Media$projectUpdateArgs<ExtArgs> = {}>(args?: Subset<T, Media$projectUpdateArgs<ExtArgs>>): Prisma__ProjectUpdateClient<$Result.GetResult<Prisma.$ProjectUpdatePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    payment<T extends Media$paymentArgs<ExtArgs> = {}>(args?: Subset<T, Media$paymentArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    createdBy<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    inspectionResponses<T extends Media$inspectionResponsesArgs<ExtArgs> = {}>(args?: Subset<T, Media$inspectionResponsesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InspectionResponsePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    query<T extends Media$queryArgs<ExtArgs> = {}>(args?: Subset<T, Media$queryArgs<ExtArgs>>): Prisma__QueryClient<$Result.GetResult<Prisma.$QueryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Media model
   */
  interface MediaFieldRefs {
    readonly id: FieldRef<"Media", 'String'>
    readonly projectId: FieldRef<"Media", 'String'>
    readonly projectUpdateId: FieldRef<"Media", 'String'>
    readonly paymentId: FieldRef<"Media", 'String'>
    readonly type: FieldRef<"Media", 'MediaType'>
    readonly fileKey: FieldRef<"Media", 'String'>
    readonly fileUrl: FieldRef<"Media", 'String'>
    readonly mimeType: FieldRef<"Media", 'String'>
    readonly fileSize: FieldRef<"Media", 'Int'>
    readonly createdById: FieldRef<"Media", 'String'>
    readonly approvedBy: FieldRef<"Media", 'String'>
    readonly approvedAt: FieldRef<"Media", 'DateTime'>
    readonly version: FieldRef<"Media", 'Int'>
    readonly createdAt: FieldRef<"Media", 'DateTime'>
    readonly queryId: FieldRef<"Media", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Media findUnique
   */
  export type MediaFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Media
     */
    select?: MediaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Media
     */
    omit?: MediaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MediaInclude<ExtArgs> | null
    /**
     * Filter, which Media to fetch.
     */
    where: MediaWhereUniqueInput
  }

  /**
   * Media findUniqueOrThrow
   */
  export type MediaFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Media
     */
    select?: MediaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Media
     */
    omit?: MediaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MediaInclude<ExtArgs> | null
    /**
     * Filter, which Media to fetch.
     */
    where: MediaWhereUniqueInput
  }

  /**
   * Media findFirst
   */
  export type MediaFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Media
     */
    select?: MediaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Media
     */
    omit?: MediaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MediaInclude<ExtArgs> | null
    /**
     * Filter, which Media to fetch.
     */
    where?: MediaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Media to fetch.
     */
    orderBy?: MediaOrderByWithRelationInput | MediaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Media.
     */
    cursor?: MediaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Media from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Media.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Media.
     */
    distinct?: MediaScalarFieldEnum | MediaScalarFieldEnum[]
  }

  /**
   * Media findFirstOrThrow
   */
  export type MediaFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Media
     */
    select?: MediaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Media
     */
    omit?: MediaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MediaInclude<ExtArgs> | null
    /**
     * Filter, which Media to fetch.
     */
    where?: MediaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Media to fetch.
     */
    orderBy?: MediaOrderByWithRelationInput | MediaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Media.
     */
    cursor?: MediaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Media from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Media.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Media.
     */
    distinct?: MediaScalarFieldEnum | MediaScalarFieldEnum[]
  }

  /**
   * Media findMany
   */
  export type MediaFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Media
     */
    select?: MediaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Media
     */
    omit?: MediaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MediaInclude<ExtArgs> | null
    /**
     * Filter, which Media to fetch.
     */
    where?: MediaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Media to fetch.
     */
    orderBy?: MediaOrderByWithRelationInput | MediaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Media.
     */
    cursor?: MediaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Media from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Media.
     */
    skip?: number
    distinct?: MediaScalarFieldEnum | MediaScalarFieldEnum[]
  }

  /**
   * Media create
   */
  export type MediaCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Media
     */
    select?: MediaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Media
     */
    omit?: MediaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MediaInclude<ExtArgs> | null
    /**
     * The data needed to create a Media.
     */
    data: XOR<MediaCreateInput, MediaUncheckedCreateInput>
  }

  /**
   * Media createMany
   */
  export type MediaCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Media.
     */
    data: MediaCreateManyInput | MediaCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Media createManyAndReturn
   */
  export type MediaCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Media
     */
    select?: MediaSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Media
     */
    omit?: MediaOmit<ExtArgs> | null
    /**
     * The data used to create many Media.
     */
    data: MediaCreateManyInput | MediaCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MediaIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Media update
   */
  export type MediaUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Media
     */
    select?: MediaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Media
     */
    omit?: MediaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MediaInclude<ExtArgs> | null
    /**
     * The data needed to update a Media.
     */
    data: XOR<MediaUpdateInput, MediaUncheckedUpdateInput>
    /**
     * Choose, which Media to update.
     */
    where: MediaWhereUniqueInput
  }

  /**
   * Media updateMany
   */
  export type MediaUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Media.
     */
    data: XOR<MediaUpdateManyMutationInput, MediaUncheckedUpdateManyInput>
    /**
     * Filter which Media to update
     */
    where?: MediaWhereInput
    /**
     * Limit how many Media to update.
     */
    limit?: number
  }

  /**
   * Media updateManyAndReturn
   */
  export type MediaUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Media
     */
    select?: MediaSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Media
     */
    omit?: MediaOmit<ExtArgs> | null
    /**
     * The data used to update Media.
     */
    data: XOR<MediaUpdateManyMutationInput, MediaUncheckedUpdateManyInput>
    /**
     * Filter which Media to update
     */
    where?: MediaWhereInput
    /**
     * Limit how many Media to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MediaIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Media upsert
   */
  export type MediaUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Media
     */
    select?: MediaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Media
     */
    omit?: MediaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MediaInclude<ExtArgs> | null
    /**
     * The filter to search for the Media to update in case it exists.
     */
    where: MediaWhereUniqueInput
    /**
     * In case the Media found by the `where` argument doesn't exist, create a new Media with this data.
     */
    create: XOR<MediaCreateInput, MediaUncheckedCreateInput>
    /**
     * In case the Media was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MediaUpdateInput, MediaUncheckedUpdateInput>
  }

  /**
   * Media delete
   */
  export type MediaDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Media
     */
    select?: MediaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Media
     */
    omit?: MediaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MediaInclude<ExtArgs> | null
    /**
     * Filter which Media to delete.
     */
    where: MediaWhereUniqueInput
  }

  /**
   * Media deleteMany
   */
  export type MediaDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Media to delete
     */
    where?: MediaWhereInput
    /**
     * Limit how many Media to delete.
     */
    limit?: number
  }

  /**
   * Media.projectUpdate
   */
  export type Media$projectUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectUpdate
     */
    select?: ProjectUpdateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProjectUpdate
     */
    omit?: ProjectUpdateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectUpdateInclude<ExtArgs> | null
    where?: ProjectUpdateWhereInput
  }

  /**
   * Media.payment
   */
  export type Media$paymentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    where?: PaymentWhereInput
  }

  /**
   * Media.inspectionResponses
   */
  export type Media$inspectionResponsesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InspectionResponse
     */
    select?: InspectionResponseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InspectionResponse
     */
    omit?: InspectionResponseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InspectionResponseInclude<ExtArgs> | null
    where?: InspectionResponseWhereInput
    orderBy?: InspectionResponseOrderByWithRelationInput | InspectionResponseOrderByWithRelationInput[]
    cursor?: InspectionResponseWhereUniqueInput
    take?: number
    skip?: number
    distinct?: InspectionResponseScalarFieldEnum | InspectionResponseScalarFieldEnum[]
  }

  /**
   * Media.query
   */
  export type Media$queryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Query
     */
    select?: QuerySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Query
     */
    omit?: QueryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QueryInclude<ExtArgs> | null
    where?: QueryWhereInput
  }

  /**
   * Media without action
   */
  export type MediaDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Media
     */
    select?: MediaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Media
     */
    omit?: MediaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MediaInclude<ExtArgs> | null
  }


  /**
   * Model Payment
   */

  export type AggregatePayment = {
    _count: PaymentCountAggregateOutputType | null
    _avg: PaymentAvgAggregateOutputType | null
    _sum: PaymentSumAggregateOutputType | null
    _min: PaymentMinAggregateOutputType | null
    _max: PaymentMaxAggregateOutputType | null
  }

  export type PaymentAvgAggregateOutputType = {
    amount: Decimal | null
  }

  export type PaymentSumAggregateOutputType = {
    amount: Decimal | null
  }

  export type PaymentMinAggregateOutputType = {
    id: string | null
    projectId: string | null
    createdById: string | null
    amount: Decimal | null
    currency: string | null
    status: $Enums.PaymentStatus | null
    category: $Enums.PaymentCategory | null
    invoiceNumber: string | null
    paidAt: Date | null
    dueDate: Date | null
    notes: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PaymentMaxAggregateOutputType = {
    id: string | null
    projectId: string | null
    createdById: string | null
    amount: Decimal | null
    currency: string | null
    status: $Enums.PaymentStatus | null
    category: $Enums.PaymentCategory | null
    invoiceNumber: string | null
    paidAt: Date | null
    dueDate: Date | null
    notes: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PaymentCountAggregateOutputType = {
    id: number
    projectId: number
    createdById: number
    amount: number
    currency: number
    status: number
    category: number
    invoiceNumber: number
    paidAt: number
    dueDate: number
    notes: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type PaymentAvgAggregateInputType = {
    amount?: true
  }

  export type PaymentSumAggregateInputType = {
    amount?: true
  }

  export type PaymentMinAggregateInputType = {
    id?: true
    projectId?: true
    createdById?: true
    amount?: true
    currency?: true
    status?: true
    category?: true
    invoiceNumber?: true
    paidAt?: true
    dueDate?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PaymentMaxAggregateInputType = {
    id?: true
    projectId?: true
    createdById?: true
    amount?: true
    currency?: true
    status?: true
    category?: true
    invoiceNumber?: true
    paidAt?: true
    dueDate?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PaymentCountAggregateInputType = {
    id?: true
    projectId?: true
    createdById?: true
    amount?: true
    currency?: true
    status?: true
    category?: true
    invoiceNumber?: true
    paidAt?: true
    dueDate?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type PaymentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Payment to aggregate.
     */
    where?: PaymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Payments to fetch.
     */
    orderBy?: PaymentOrderByWithRelationInput | PaymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PaymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Payments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Payments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Payments
    **/
    _count?: true | PaymentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PaymentAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PaymentSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PaymentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PaymentMaxAggregateInputType
  }

  export type GetPaymentAggregateType<T extends PaymentAggregateArgs> = {
        [P in keyof T & keyof AggregatePayment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePayment[P]>
      : GetScalarType<T[P], AggregatePayment[P]>
  }




  export type PaymentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PaymentWhereInput
    orderBy?: PaymentOrderByWithAggregationInput | PaymentOrderByWithAggregationInput[]
    by: PaymentScalarFieldEnum[] | PaymentScalarFieldEnum
    having?: PaymentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PaymentCountAggregateInputType | true
    _avg?: PaymentAvgAggregateInputType
    _sum?: PaymentSumAggregateInputType
    _min?: PaymentMinAggregateInputType
    _max?: PaymentMaxAggregateInputType
  }

  export type PaymentGroupByOutputType = {
    id: string
    projectId: string
    createdById: string
    amount: Decimal
    currency: string
    status: $Enums.PaymentStatus
    category: $Enums.PaymentCategory | null
    invoiceNumber: string | null
    paidAt: Date | null
    dueDate: Date | null
    notes: string | null
    createdAt: Date
    updatedAt: Date
    _count: PaymentCountAggregateOutputType | null
    _avg: PaymentAvgAggregateOutputType | null
    _sum: PaymentSumAggregateOutputType | null
    _min: PaymentMinAggregateOutputType | null
    _max: PaymentMaxAggregateOutputType | null
  }

  type GetPaymentGroupByPayload<T extends PaymentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PaymentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PaymentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PaymentGroupByOutputType[P]>
            : GetScalarType<T[P], PaymentGroupByOutputType[P]>
        }
      >
    >


  export type PaymentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    projectId?: boolean
    createdById?: boolean
    amount?: boolean
    currency?: boolean
    status?: boolean
    category?: boolean
    invoiceNumber?: boolean
    paidAt?: boolean
    dueDate?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    project?: boolean | ProjectDefaultArgs<ExtArgs>
    createdBy?: boolean | UserDefaultArgs<ExtArgs>
    media?: boolean | Payment$mediaArgs<ExtArgs>
    _count?: boolean | PaymentCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["payment"]>

  export type PaymentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    projectId?: boolean
    createdById?: boolean
    amount?: boolean
    currency?: boolean
    status?: boolean
    category?: boolean
    invoiceNumber?: boolean
    paidAt?: boolean
    dueDate?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    project?: boolean | ProjectDefaultArgs<ExtArgs>
    createdBy?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["payment"]>

  export type PaymentSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    projectId?: boolean
    createdById?: boolean
    amount?: boolean
    currency?: boolean
    status?: boolean
    category?: boolean
    invoiceNumber?: boolean
    paidAt?: boolean
    dueDate?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    project?: boolean | ProjectDefaultArgs<ExtArgs>
    createdBy?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["payment"]>

  export type PaymentSelectScalar = {
    id?: boolean
    projectId?: boolean
    createdById?: boolean
    amount?: boolean
    currency?: boolean
    status?: boolean
    category?: boolean
    invoiceNumber?: boolean
    paidAt?: boolean
    dueDate?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type PaymentOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "projectId" | "createdById" | "amount" | "currency" | "status" | "category" | "invoiceNumber" | "paidAt" | "dueDate" | "notes" | "createdAt" | "updatedAt", ExtArgs["result"]["payment"]>
  export type PaymentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    project?: boolean | ProjectDefaultArgs<ExtArgs>
    createdBy?: boolean | UserDefaultArgs<ExtArgs>
    media?: boolean | Payment$mediaArgs<ExtArgs>
    _count?: boolean | PaymentCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type PaymentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    project?: boolean | ProjectDefaultArgs<ExtArgs>
    createdBy?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type PaymentIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    project?: boolean | ProjectDefaultArgs<ExtArgs>
    createdBy?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $PaymentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Payment"
    objects: {
      project: Prisma.$ProjectPayload<ExtArgs>
      createdBy: Prisma.$UserPayload<ExtArgs>
      media: Prisma.$MediaPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      projectId: string
      createdById: string
      amount: Prisma.Decimal
      currency: string
      status: $Enums.PaymentStatus
      category: $Enums.PaymentCategory | null
      invoiceNumber: string | null
      paidAt: Date | null
      dueDate: Date | null
      notes: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["payment"]>
    composites: {}
  }

  type PaymentGetPayload<S extends boolean | null | undefined | PaymentDefaultArgs> = $Result.GetResult<Prisma.$PaymentPayload, S>

  type PaymentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PaymentFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PaymentCountAggregateInputType | true
    }

  export interface PaymentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Payment'], meta: { name: 'Payment' } }
    /**
     * Find zero or one Payment that matches the filter.
     * @param {PaymentFindUniqueArgs} args - Arguments to find a Payment
     * @example
     * // Get one Payment
     * const payment = await prisma.payment.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PaymentFindUniqueArgs>(args: SelectSubset<T, PaymentFindUniqueArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Payment that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PaymentFindUniqueOrThrowArgs} args - Arguments to find a Payment
     * @example
     * // Get one Payment
     * const payment = await prisma.payment.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PaymentFindUniqueOrThrowArgs>(args: SelectSubset<T, PaymentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Payment that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentFindFirstArgs} args - Arguments to find a Payment
     * @example
     * // Get one Payment
     * const payment = await prisma.payment.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PaymentFindFirstArgs>(args?: SelectSubset<T, PaymentFindFirstArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Payment that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentFindFirstOrThrowArgs} args - Arguments to find a Payment
     * @example
     * // Get one Payment
     * const payment = await prisma.payment.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PaymentFindFirstOrThrowArgs>(args?: SelectSubset<T, PaymentFindFirstOrThrowArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Payments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Payments
     * const payments = await prisma.payment.findMany()
     * 
     * // Get first 10 Payments
     * const payments = await prisma.payment.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const paymentWithIdOnly = await prisma.payment.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PaymentFindManyArgs>(args?: SelectSubset<T, PaymentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Payment.
     * @param {PaymentCreateArgs} args - Arguments to create a Payment.
     * @example
     * // Create one Payment
     * const Payment = await prisma.payment.create({
     *   data: {
     *     // ... data to create a Payment
     *   }
     * })
     * 
     */
    create<T extends PaymentCreateArgs>(args: SelectSubset<T, PaymentCreateArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Payments.
     * @param {PaymentCreateManyArgs} args - Arguments to create many Payments.
     * @example
     * // Create many Payments
     * const payment = await prisma.payment.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PaymentCreateManyArgs>(args?: SelectSubset<T, PaymentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Payments and returns the data saved in the database.
     * @param {PaymentCreateManyAndReturnArgs} args - Arguments to create many Payments.
     * @example
     * // Create many Payments
     * const payment = await prisma.payment.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Payments and only return the `id`
     * const paymentWithIdOnly = await prisma.payment.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PaymentCreateManyAndReturnArgs>(args?: SelectSubset<T, PaymentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Payment.
     * @param {PaymentDeleteArgs} args - Arguments to delete one Payment.
     * @example
     * // Delete one Payment
     * const Payment = await prisma.payment.delete({
     *   where: {
     *     // ... filter to delete one Payment
     *   }
     * })
     * 
     */
    delete<T extends PaymentDeleteArgs>(args: SelectSubset<T, PaymentDeleteArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Payment.
     * @param {PaymentUpdateArgs} args - Arguments to update one Payment.
     * @example
     * // Update one Payment
     * const payment = await prisma.payment.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PaymentUpdateArgs>(args: SelectSubset<T, PaymentUpdateArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Payments.
     * @param {PaymentDeleteManyArgs} args - Arguments to filter Payments to delete.
     * @example
     * // Delete a few Payments
     * const { count } = await prisma.payment.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PaymentDeleteManyArgs>(args?: SelectSubset<T, PaymentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Payments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Payments
     * const payment = await prisma.payment.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PaymentUpdateManyArgs>(args: SelectSubset<T, PaymentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Payments and returns the data updated in the database.
     * @param {PaymentUpdateManyAndReturnArgs} args - Arguments to update many Payments.
     * @example
     * // Update many Payments
     * const payment = await prisma.payment.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Payments and only return the `id`
     * const paymentWithIdOnly = await prisma.payment.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PaymentUpdateManyAndReturnArgs>(args: SelectSubset<T, PaymentUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Payment.
     * @param {PaymentUpsertArgs} args - Arguments to update or create a Payment.
     * @example
     * // Update or create a Payment
     * const payment = await prisma.payment.upsert({
     *   create: {
     *     // ... data to create a Payment
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Payment we want to update
     *   }
     * })
     */
    upsert<T extends PaymentUpsertArgs>(args: SelectSubset<T, PaymentUpsertArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Payments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentCountArgs} args - Arguments to filter Payments to count.
     * @example
     * // Count the number of Payments
     * const count = await prisma.payment.count({
     *   where: {
     *     // ... the filter for the Payments we want to count
     *   }
     * })
    **/
    count<T extends PaymentCountArgs>(
      args?: Subset<T, PaymentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PaymentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Payment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PaymentAggregateArgs>(args: Subset<T, PaymentAggregateArgs>): Prisma.PrismaPromise<GetPaymentAggregateType<T>>

    /**
     * Group by Payment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PaymentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PaymentGroupByArgs['orderBy'] }
        : { orderBy?: PaymentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PaymentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPaymentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Payment model
   */
  readonly fields: PaymentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Payment.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PaymentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    project<T extends ProjectDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProjectDefaultArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    createdBy<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    media<T extends Payment$mediaArgs<ExtArgs> = {}>(args?: Subset<T, Payment$mediaArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MediaPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Payment model
   */
  interface PaymentFieldRefs {
    readonly id: FieldRef<"Payment", 'String'>
    readonly projectId: FieldRef<"Payment", 'String'>
    readonly createdById: FieldRef<"Payment", 'String'>
    readonly amount: FieldRef<"Payment", 'Decimal'>
    readonly currency: FieldRef<"Payment", 'String'>
    readonly status: FieldRef<"Payment", 'PaymentStatus'>
    readonly category: FieldRef<"Payment", 'PaymentCategory'>
    readonly invoiceNumber: FieldRef<"Payment", 'String'>
    readonly paidAt: FieldRef<"Payment", 'DateTime'>
    readonly dueDate: FieldRef<"Payment", 'DateTime'>
    readonly notes: FieldRef<"Payment", 'String'>
    readonly createdAt: FieldRef<"Payment", 'DateTime'>
    readonly updatedAt: FieldRef<"Payment", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Payment findUnique
   */
  export type PaymentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * Filter, which Payment to fetch.
     */
    where: PaymentWhereUniqueInput
  }

  /**
   * Payment findUniqueOrThrow
   */
  export type PaymentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * Filter, which Payment to fetch.
     */
    where: PaymentWhereUniqueInput
  }

  /**
   * Payment findFirst
   */
  export type PaymentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * Filter, which Payment to fetch.
     */
    where?: PaymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Payments to fetch.
     */
    orderBy?: PaymentOrderByWithRelationInput | PaymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Payments.
     */
    cursor?: PaymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Payments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Payments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Payments.
     */
    distinct?: PaymentScalarFieldEnum | PaymentScalarFieldEnum[]
  }

  /**
   * Payment findFirstOrThrow
   */
  export type PaymentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * Filter, which Payment to fetch.
     */
    where?: PaymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Payments to fetch.
     */
    orderBy?: PaymentOrderByWithRelationInput | PaymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Payments.
     */
    cursor?: PaymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Payments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Payments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Payments.
     */
    distinct?: PaymentScalarFieldEnum | PaymentScalarFieldEnum[]
  }

  /**
   * Payment findMany
   */
  export type PaymentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * Filter, which Payments to fetch.
     */
    where?: PaymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Payments to fetch.
     */
    orderBy?: PaymentOrderByWithRelationInput | PaymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Payments.
     */
    cursor?: PaymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Payments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Payments.
     */
    skip?: number
    distinct?: PaymentScalarFieldEnum | PaymentScalarFieldEnum[]
  }

  /**
   * Payment create
   */
  export type PaymentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * The data needed to create a Payment.
     */
    data: XOR<PaymentCreateInput, PaymentUncheckedCreateInput>
  }

  /**
   * Payment createMany
   */
  export type PaymentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Payments.
     */
    data: PaymentCreateManyInput | PaymentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Payment createManyAndReturn
   */
  export type PaymentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * The data used to create many Payments.
     */
    data: PaymentCreateManyInput | PaymentCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Payment update
   */
  export type PaymentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * The data needed to update a Payment.
     */
    data: XOR<PaymentUpdateInput, PaymentUncheckedUpdateInput>
    /**
     * Choose, which Payment to update.
     */
    where: PaymentWhereUniqueInput
  }

  /**
   * Payment updateMany
   */
  export type PaymentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Payments.
     */
    data: XOR<PaymentUpdateManyMutationInput, PaymentUncheckedUpdateManyInput>
    /**
     * Filter which Payments to update
     */
    where?: PaymentWhereInput
    /**
     * Limit how many Payments to update.
     */
    limit?: number
  }

  /**
   * Payment updateManyAndReturn
   */
  export type PaymentUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * The data used to update Payments.
     */
    data: XOR<PaymentUpdateManyMutationInput, PaymentUncheckedUpdateManyInput>
    /**
     * Filter which Payments to update
     */
    where?: PaymentWhereInput
    /**
     * Limit how many Payments to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Payment upsert
   */
  export type PaymentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * The filter to search for the Payment to update in case it exists.
     */
    where: PaymentWhereUniqueInput
    /**
     * In case the Payment found by the `where` argument doesn't exist, create a new Payment with this data.
     */
    create: XOR<PaymentCreateInput, PaymentUncheckedCreateInput>
    /**
     * In case the Payment was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PaymentUpdateInput, PaymentUncheckedUpdateInput>
  }

  /**
   * Payment delete
   */
  export type PaymentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * Filter which Payment to delete.
     */
    where: PaymentWhereUniqueInput
  }

  /**
   * Payment deleteMany
   */
  export type PaymentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Payments to delete
     */
    where?: PaymentWhereInput
    /**
     * Limit how many Payments to delete.
     */
    limit?: number
  }

  /**
   * Payment.media
   */
  export type Payment$mediaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Media
     */
    select?: MediaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Media
     */
    omit?: MediaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MediaInclude<ExtArgs> | null
    where?: MediaWhereInput
    orderBy?: MediaOrderByWithRelationInput | MediaOrderByWithRelationInput[]
    cursor?: MediaWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MediaScalarFieldEnum | MediaScalarFieldEnum[]
  }

  /**
   * Payment without action
   */
  export type PaymentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
  }


  /**
   * Model Notification
   */

  export type AggregateNotification = {
    _count: NotificationCountAggregateOutputType | null
    _min: NotificationMinAggregateOutputType | null
    _max: NotificationMaxAggregateOutputType | null
  }

  export type NotificationMinAggregateOutputType = {
    id: string | null
    userId: string | null
    title: string | null
    message: string | null
    type: string | null
    priority: $Enums.NotificationPriority | null
    actionUrl: string | null
    isRead: boolean | null
    createdAt: Date | null
  }

  export type NotificationMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    title: string | null
    message: string | null
    type: string | null
    priority: $Enums.NotificationPriority | null
    actionUrl: string | null
    isRead: boolean | null
    createdAt: Date | null
  }

  export type NotificationCountAggregateOutputType = {
    id: number
    userId: number
    title: number
    message: number
    type: number
    priority: number
    actionUrl: number
    isRead: number
    createdAt: number
    _all: number
  }


  export type NotificationMinAggregateInputType = {
    id?: true
    userId?: true
    title?: true
    message?: true
    type?: true
    priority?: true
    actionUrl?: true
    isRead?: true
    createdAt?: true
  }

  export type NotificationMaxAggregateInputType = {
    id?: true
    userId?: true
    title?: true
    message?: true
    type?: true
    priority?: true
    actionUrl?: true
    isRead?: true
    createdAt?: true
  }

  export type NotificationCountAggregateInputType = {
    id?: true
    userId?: true
    title?: true
    message?: true
    type?: true
    priority?: true
    actionUrl?: true
    isRead?: true
    createdAt?: true
    _all?: true
  }

  export type NotificationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Notification to aggregate.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Notifications
    **/
    _count?: true | NotificationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: NotificationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: NotificationMaxAggregateInputType
  }

  export type GetNotificationAggregateType<T extends NotificationAggregateArgs> = {
        [P in keyof T & keyof AggregateNotification]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateNotification[P]>
      : GetScalarType<T[P], AggregateNotification[P]>
  }




  export type NotificationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NotificationWhereInput
    orderBy?: NotificationOrderByWithAggregationInput | NotificationOrderByWithAggregationInput[]
    by: NotificationScalarFieldEnum[] | NotificationScalarFieldEnum
    having?: NotificationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: NotificationCountAggregateInputType | true
    _min?: NotificationMinAggregateInputType
    _max?: NotificationMaxAggregateInputType
  }

  export type NotificationGroupByOutputType = {
    id: string
    userId: string
    title: string
    message: string
    type: string
    priority: $Enums.NotificationPriority
    actionUrl: string | null
    isRead: boolean
    createdAt: Date
    _count: NotificationCountAggregateOutputType | null
    _min: NotificationMinAggregateOutputType | null
    _max: NotificationMaxAggregateOutputType | null
  }

  type GetNotificationGroupByPayload<T extends NotificationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<NotificationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof NotificationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], NotificationGroupByOutputType[P]>
            : GetScalarType<T[P], NotificationGroupByOutputType[P]>
        }
      >
    >


  export type NotificationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    title?: boolean
    message?: boolean
    type?: boolean
    priority?: boolean
    actionUrl?: boolean
    isRead?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["notification"]>

  export type NotificationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    title?: boolean
    message?: boolean
    type?: boolean
    priority?: boolean
    actionUrl?: boolean
    isRead?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["notification"]>

  export type NotificationSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    title?: boolean
    message?: boolean
    type?: boolean
    priority?: boolean
    actionUrl?: boolean
    isRead?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["notification"]>

  export type NotificationSelectScalar = {
    id?: boolean
    userId?: boolean
    title?: boolean
    message?: boolean
    type?: boolean
    priority?: boolean
    actionUrl?: boolean
    isRead?: boolean
    createdAt?: boolean
  }

  export type NotificationOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "title" | "message" | "type" | "priority" | "actionUrl" | "isRead" | "createdAt", ExtArgs["result"]["notification"]>
  export type NotificationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type NotificationIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type NotificationIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $NotificationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Notification"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      title: string
      message: string
      type: string
      priority: $Enums.NotificationPriority
      actionUrl: string | null
      isRead: boolean
      createdAt: Date
    }, ExtArgs["result"]["notification"]>
    composites: {}
  }

  type NotificationGetPayload<S extends boolean | null | undefined | NotificationDefaultArgs> = $Result.GetResult<Prisma.$NotificationPayload, S>

  type NotificationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<NotificationFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: NotificationCountAggregateInputType | true
    }

  export interface NotificationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Notification'], meta: { name: 'Notification' } }
    /**
     * Find zero or one Notification that matches the filter.
     * @param {NotificationFindUniqueArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends NotificationFindUniqueArgs>(args: SelectSubset<T, NotificationFindUniqueArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Notification that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {NotificationFindUniqueOrThrowArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends NotificationFindUniqueOrThrowArgs>(args: SelectSubset<T, NotificationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Notification that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationFindFirstArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends NotificationFindFirstArgs>(args?: SelectSubset<T, NotificationFindFirstArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Notification that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationFindFirstOrThrowArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends NotificationFindFirstOrThrowArgs>(args?: SelectSubset<T, NotificationFindFirstOrThrowArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Notifications that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Notifications
     * const notifications = await prisma.notification.findMany()
     * 
     * // Get first 10 Notifications
     * const notifications = await prisma.notification.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const notificationWithIdOnly = await prisma.notification.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends NotificationFindManyArgs>(args?: SelectSubset<T, NotificationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Notification.
     * @param {NotificationCreateArgs} args - Arguments to create a Notification.
     * @example
     * // Create one Notification
     * const Notification = await prisma.notification.create({
     *   data: {
     *     // ... data to create a Notification
     *   }
     * })
     * 
     */
    create<T extends NotificationCreateArgs>(args: SelectSubset<T, NotificationCreateArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Notifications.
     * @param {NotificationCreateManyArgs} args - Arguments to create many Notifications.
     * @example
     * // Create many Notifications
     * const notification = await prisma.notification.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends NotificationCreateManyArgs>(args?: SelectSubset<T, NotificationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Notifications and returns the data saved in the database.
     * @param {NotificationCreateManyAndReturnArgs} args - Arguments to create many Notifications.
     * @example
     * // Create many Notifications
     * const notification = await prisma.notification.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Notifications and only return the `id`
     * const notificationWithIdOnly = await prisma.notification.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends NotificationCreateManyAndReturnArgs>(args?: SelectSubset<T, NotificationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Notification.
     * @param {NotificationDeleteArgs} args - Arguments to delete one Notification.
     * @example
     * // Delete one Notification
     * const Notification = await prisma.notification.delete({
     *   where: {
     *     // ... filter to delete one Notification
     *   }
     * })
     * 
     */
    delete<T extends NotificationDeleteArgs>(args: SelectSubset<T, NotificationDeleteArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Notification.
     * @param {NotificationUpdateArgs} args - Arguments to update one Notification.
     * @example
     * // Update one Notification
     * const notification = await prisma.notification.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends NotificationUpdateArgs>(args: SelectSubset<T, NotificationUpdateArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Notifications.
     * @param {NotificationDeleteManyArgs} args - Arguments to filter Notifications to delete.
     * @example
     * // Delete a few Notifications
     * const { count } = await prisma.notification.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends NotificationDeleteManyArgs>(args?: SelectSubset<T, NotificationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Notifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Notifications
     * const notification = await prisma.notification.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends NotificationUpdateManyArgs>(args: SelectSubset<T, NotificationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Notifications and returns the data updated in the database.
     * @param {NotificationUpdateManyAndReturnArgs} args - Arguments to update many Notifications.
     * @example
     * // Update many Notifications
     * const notification = await prisma.notification.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Notifications and only return the `id`
     * const notificationWithIdOnly = await prisma.notification.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends NotificationUpdateManyAndReturnArgs>(args: SelectSubset<T, NotificationUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Notification.
     * @param {NotificationUpsertArgs} args - Arguments to update or create a Notification.
     * @example
     * // Update or create a Notification
     * const notification = await prisma.notification.upsert({
     *   create: {
     *     // ... data to create a Notification
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Notification we want to update
     *   }
     * })
     */
    upsert<T extends NotificationUpsertArgs>(args: SelectSubset<T, NotificationUpsertArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Notifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationCountArgs} args - Arguments to filter Notifications to count.
     * @example
     * // Count the number of Notifications
     * const count = await prisma.notification.count({
     *   where: {
     *     // ... the filter for the Notifications we want to count
     *   }
     * })
    **/
    count<T extends NotificationCountArgs>(
      args?: Subset<T, NotificationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], NotificationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Notification.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends NotificationAggregateArgs>(args: Subset<T, NotificationAggregateArgs>): Prisma.PrismaPromise<GetNotificationAggregateType<T>>

    /**
     * Group by Notification.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends NotificationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: NotificationGroupByArgs['orderBy'] }
        : { orderBy?: NotificationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, NotificationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetNotificationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Notification model
   */
  readonly fields: NotificationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Notification.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__NotificationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Notification model
   */
  interface NotificationFieldRefs {
    readonly id: FieldRef<"Notification", 'String'>
    readonly userId: FieldRef<"Notification", 'String'>
    readonly title: FieldRef<"Notification", 'String'>
    readonly message: FieldRef<"Notification", 'String'>
    readonly type: FieldRef<"Notification", 'String'>
    readonly priority: FieldRef<"Notification", 'NotificationPriority'>
    readonly actionUrl: FieldRef<"Notification", 'String'>
    readonly isRead: FieldRef<"Notification", 'Boolean'>
    readonly createdAt: FieldRef<"Notification", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Notification findUnique
   */
  export type NotificationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where: NotificationWhereUniqueInput
  }

  /**
   * Notification findUniqueOrThrow
   */
  export type NotificationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where: NotificationWhereUniqueInput
  }

  /**
   * Notification findFirst
   */
  export type NotificationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Notifications.
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Notifications.
     */
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * Notification findFirstOrThrow
   */
  export type NotificationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Notifications.
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Notifications.
     */
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * Notification findMany
   */
  export type NotificationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notifications to fetch.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Notifications.
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * Notification create
   */
  export type NotificationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * The data needed to create a Notification.
     */
    data: XOR<NotificationCreateInput, NotificationUncheckedCreateInput>
  }

  /**
   * Notification createMany
   */
  export type NotificationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Notifications.
     */
    data: NotificationCreateManyInput | NotificationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Notification createManyAndReturn
   */
  export type NotificationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * The data used to create many Notifications.
     */
    data: NotificationCreateManyInput | NotificationCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Notification update
   */
  export type NotificationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * The data needed to update a Notification.
     */
    data: XOR<NotificationUpdateInput, NotificationUncheckedUpdateInput>
    /**
     * Choose, which Notification to update.
     */
    where: NotificationWhereUniqueInput
  }

  /**
   * Notification updateMany
   */
  export type NotificationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Notifications.
     */
    data: XOR<NotificationUpdateManyMutationInput, NotificationUncheckedUpdateManyInput>
    /**
     * Filter which Notifications to update
     */
    where?: NotificationWhereInput
    /**
     * Limit how many Notifications to update.
     */
    limit?: number
  }

  /**
   * Notification updateManyAndReturn
   */
  export type NotificationUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * The data used to update Notifications.
     */
    data: XOR<NotificationUpdateManyMutationInput, NotificationUncheckedUpdateManyInput>
    /**
     * Filter which Notifications to update
     */
    where?: NotificationWhereInput
    /**
     * Limit how many Notifications to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Notification upsert
   */
  export type NotificationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * The filter to search for the Notification to update in case it exists.
     */
    where: NotificationWhereUniqueInput
    /**
     * In case the Notification found by the `where` argument doesn't exist, create a new Notification with this data.
     */
    create: XOR<NotificationCreateInput, NotificationUncheckedCreateInput>
    /**
     * In case the Notification was found with the provided `where` argument, update it with this data.
     */
    update: XOR<NotificationUpdateInput, NotificationUncheckedUpdateInput>
  }

  /**
   * Notification delete
   */
  export type NotificationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter which Notification to delete.
     */
    where: NotificationWhereUniqueInput
  }

  /**
   * Notification deleteMany
   */
  export type NotificationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Notifications to delete
     */
    where?: NotificationWhereInput
    /**
     * Limit how many Notifications to delete.
     */
    limit?: number
  }

  /**
   * Notification without action
   */
  export type NotificationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
  }


  /**
   * Model NotificationPreference
   */

  export type AggregateNotificationPreference = {
    _count: NotificationPreferenceCountAggregateOutputType | null
    _min: NotificationPreferenceMinAggregateOutputType | null
    _max: NotificationPreferenceMaxAggregateOutputType | null
  }

  export type NotificationPreferenceMinAggregateOutputType = {
    id: string | null
    userId: string | null
    inspectionSubmitted: boolean | null
    paymentOverdue: boolean | null
    newAssignment: boolean | null
    queryCreated: boolean | null
    drawingApproved: boolean | null
    emailEnabled: boolean | null
    inAppEnabled: boolean | null
    updatedAt: Date | null
  }

  export type NotificationPreferenceMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    inspectionSubmitted: boolean | null
    paymentOverdue: boolean | null
    newAssignment: boolean | null
    queryCreated: boolean | null
    drawingApproved: boolean | null
    emailEnabled: boolean | null
    inAppEnabled: boolean | null
    updatedAt: Date | null
  }

  export type NotificationPreferenceCountAggregateOutputType = {
    id: number
    userId: number
    inspectionSubmitted: number
    paymentOverdue: number
    newAssignment: number
    queryCreated: number
    drawingApproved: number
    emailEnabled: number
    inAppEnabled: number
    updatedAt: number
    _all: number
  }


  export type NotificationPreferenceMinAggregateInputType = {
    id?: true
    userId?: true
    inspectionSubmitted?: true
    paymentOverdue?: true
    newAssignment?: true
    queryCreated?: true
    drawingApproved?: true
    emailEnabled?: true
    inAppEnabled?: true
    updatedAt?: true
  }

  export type NotificationPreferenceMaxAggregateInputType = {
    id?: true
    userId?: true
    inspectionSubmitted?: true
    paymentOverdue?: true
    newAssignment?: true
    queryCreated?: true
    drawingApproved?: true
    emailEnabled?: true
    inAppEnabled?: true
    updatedAt?: true
  }

  export type NotificationPreferenceCountAggregateInputType = {
    id?: true
    userId?: true
    inspectionSubmitted?: true
    paymentOverdue?: true
    newAssignment?: true
    queryCreated?: true
    drawingApproved?: true
    emailEnabled?: true
    inAppEnabled?: true
    updatedAt?: true
    _all?: true
  }

  export type NotificationPreferenceAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which NotificationPreference to aggregate.
     */
    where?: NotificationPreferenceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NotificationPreferences to fetch.
     */
    orderBy?: NotificationPreferenceOrderByWithRelationInput | NotificationPreferenceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: NotificationPreferenceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NotificationPreferences from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NotificationPreferences.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned NotificationPreferences
    **/
    _count?: true | NotificationPreferenceCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: NotificationPreferenceMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: NotificationPreferenceMaxAggregateInputType
  }

  export type GetNotificationPreferenceAggregateType<T extends NotificationPreferenceAggregateArgs> = {
        [P in keyof T & keyof AggregateNotificationPreference]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateNotificationPreference[P]>
      : GetScalarType<T[P], AggregateNotificationPreference[P]>
  }




  export type NotificationPreferenceGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NotificationPreferenceWhereInput
    orderBy?: NotificationPreferenceOrderByWithAggregationInput | NotificationPreferenceOrderByWithAggregationInput[]
    by: NotificationPreferenceScalarFieldEnum[] | NotificationPreferenceScalarFieldEnum
    having?: NotificationPreferenceScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: NotificationPreferenceCountAggregateInputType | true
    _min?: NotificationPreferenceMinAggregateInputType
    _max?: NotificationPreferenceMaxAggregateInputType
  }

  export type NotificationPreferenceGroupByOutputType = {
    id: string
    userId: string
    inspectionSubmitted: boolean
    paymentOverdue: boolean
    newAssignment: boolean
    queryCreated: boolean
    drawingApproved: boolean
    emailEnabled: boolean
    inAppEnabled: boolean
    updatedAt: Date
    _count: NotificationPreferenceCountAggregateOutputType | null
    _min: NotificationPreferenceMinAggregateOutputType | null
    _max: NotificationPreferenceMaxAggregateOutputType | null
  }

  type GetNotificationPreferenceGroupByPayload<T extends NotificationPreferenceGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<NotificationPreferenceGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof NotificationPreferenceGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], NotificationPreferenceGroupByOutputType[P]>
            : GetScalarType<T[P], NotificationPreferenceGroupByOutputType[P]>
        }
      >
    >


  export type NotificationPreferenceSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    inspectionSubmitted?: boolean
    paymentOverdue?: boolean
    newAssignment?: boolean
    queryCreated?: boolean
    drawingApproved?: boolean
    emailEnabled?: boolean
    inAppEnabled?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["notificationPreference"]>

  export type NotificationPreferenceSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    inspectionSubmitted?: boolean
    paymentOverdue?: boolean
    newAssignment?: boolean
    queryCreated?: boolean
    drawingApproved?: boolean
    emailEnabled?: boolean
    inAppEnabled?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["notificationPreference"]>

  export type NotificationPreferenceSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    inspectionSubmitted?: boolean
    paymentOverdue?: boolean
    newAssignment?: boolean
    queryCreated?: boolean
    drawingApproved?: boolean
    emailEnabled?: boolean
    inAppEnabled?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["notificationPreference"]>

  export type NotificationPreferenceSelectScalar = {
    id?: boolean
    userId?: boolean
    inspectionSubmitted?: boolean
    paymentOverdue?: boolean
    newAssignment?: boolean
    queryCreated?: boolean
    drawingApproved?: boolean
    emailEnabled?: boolean
    inAppEnabled?: boolean
    updatedAt?: boolean
  }

  export type NotificationPreferenceOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "inspectionSubmitted" | "paymentOverdue" | "newAssignment" | "queryCreated" | "drawingApproved" | "emailEnabled" | "inAppEnabled" | "updatedAt", ExtArgs["result"]["notificationPreference"]>
  export type NotificationPreferenceInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type NotificationPreferenceIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type NotificationPreferenceIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $NotificationPreferencePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "NotificationPreference"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      inspectionSubmitted: boolean
      paymentOverdue: boolean
      newAssignment: boolean
      queryCreated: boolean
      drawingApproved: boolean
      emailEnabled: boolean
      inAppEnabled: boolean
      updatedAt: Date
    }, ExtArgs["result"]["notificationPreference"]>
    composites: {}
  }

  type NotificationPreferenceGetPayload<S extends boolean | null | undefined | NotificationPreferenceDefaultArgs> = $Result.GetResult<Prisma.$NotificationPreferencePayload, S>

  type NotificationPreferenceCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<NotificationPreferenceFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: NotificationPreferenceCountAggregateInputType | true
    }

  export interface NotificationPreferenceDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['NotificationPreference'], meta: { name: 'NotificationPreference' } }
    /**
     * Find zero or one NotificationPreference that matches the filter.
     * @param {NotificationPreferenceFindUniqueArgs} args - Arguments to find a NotificationPreference
     * @example
     * // Get one NotificationPreference
     * const notificationPreference = await prisma.notificationPreference.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends NotificationPreferenceFindUniqueArgs>(args: SelectSubset<T, NotificationPreferenceFindUniqueArgs<ExtArgs>>): Prisma__NotificationPreferenceClient<$Result.GetResult<Prisma.$NotificationPreferencePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one NotificationPreference that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {NotificationPreferenceFindUniqueOrThrowArgs} args - Arguments to find a NotificationPreference
     * @example
     * // Get one NotificationPreference
     * const notificationPreference = await prisma.notificationPreference.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends NotificationPreferenceFindUniqueOrThrowArgs>(args: SelectSubset<T, NotificationPreferenceFindUniqueOrThrowArgs<ExtArgs>>): Prisma__NotificationPreferenceClient<$Result.GetResult<Prisma.$NotificationPreferencePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first NotificationPreference that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationPreferenceFindFirstArgs} args - Arguments to find a NotificationPreference
     * @example
     * // Get one NotificationPreference
     * const notificationPreference = await prisma.notificationPreference.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends NotificationPreferenceFindFirstArgs>(args?: SelectSubset<T, NotificationPreferenceFindFirstArgs<ExtArgs>>): Prisma__NotificationPreferenceClient<$Result.GetResult<Prisma.$NotificationPreferencePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first NotificationPreference that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationPreferenceFindFirstOrThrowArgs} args - Arguments to find a NotificationPreference
     * @example
     * // Get one NotificationPreference
     * const notificationPreference = await prisma.notificationPreference.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends NotificationPreferenceFindFirstOrThrowArgs>(args?: SelectSubset<T, NotificationPreferenceFindFirstOrThrowArgs<ExtArgs>>): Prisma__NotificationPreferenceClient<$Result.GetResult<Prisma.$NotificationPreferencePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more NotificationPreferences that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationPreferenceFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all NotificationPreferences
     * const notificationPreferences = await prisma.notificationPreference.findMany()
     * 
     * // Get first 10 NotificationPreferences
     * const notificationPreferences = await prisma.notificationPreference.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const notificationPreferenceWithIdOnly = await prisma.notificationPreference.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends NotificationPreferenceFindManyArgs>(args?: SelectSubset<T, NotificationPreferenceFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPreferencePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a NotificationPreference.
     * @param {NotificationPreferenceCreateArgs} args - Arguments to create a NotificationPreference.
     * @example
     * // Create one NotificationPreference
     * const NotificationPreference = await prisma.notificationPreference.create({
     *   data: {
     *     // ... data to create a NotificationPreference
     *   }
     * })
     * 
     */
    create<T extends NotificationPreferenceCreateArgs>(args: SelectSubset<T, NotificationPreferenceCreateArgs<ExtArgs>>): Prisma__NotificationPreferenceClient<$Result.GetResult<Prisma.$NotificationPreferencePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many NotificationPreferences.
     * @param {NotificationPreferenceCreateManyArgs} args - Arguments to create many NotificationPreferences.
     * @example
     * // Create many NotificationPreferences
     * const notificationPreference = await prisma.notificationPreference.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends NotificationPreferenceCreateManyArgs>(args?: SelectSubset<T, NotificationPreferenceCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many NotificationPreferences and returns the data saved in the database.
     * @param {NotificationPreferenceCreateManyAndReturnArgs} args - Arguments to create many NotificationPreferences.
     * @example
     * // Create many NotificationPreferences
     * const notificationPreference = await prisma.notificationPreference.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many NotificationPreferences and only return the `id`
     * const notificationPreferenceWithIdOnly = await prisma.notificationPreference.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends NotificationPreferenceCreateManyAndReturnArgs>(args?: SelectSubset<T, NotificationPreferenceCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPreferencePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a NotificationPreference.
     * @param {NotificationPreferenceDeleteArgs} args - Arguments to delete one NotificationPreference.
     * @example
     * // Delete one NotificationPreference
     * const NotificationPreference = await prisma.notificationPreference.delete({
     *   where: {
     *     // ... filter to delete one NotificationPreference
     *   }
     * })
     * 
     */
    delete<T extends NotificationPreferenceDeleteArgs>(args: SelectSubset<T, NotificationPreferenceDeleteArgs<ExtArgs>>): Prisma__NotificationPreferenceClient<$Result.GetResult<Prisma.$NotificationPreferencePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one NotificationPreference.
     * @param {NotificationPreferenceUpdateArgs} args - Arguments to update one NotificationPreference.
     * @example
     * // Update one NotificationPreference
     * const notificationPreference = await prisma.notificationPreference.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends NotificationPreferenceUpdateArgs>(args: SelectSubset<T, NotificationPreferenceUpdateArgs<ExtArgs>>): Prisma__NotificationPreferenceClient<$Result.GetResult<Prisma.$NotificationPreferencePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more NotificationPreferences.
     * @param {NotificationPreferenceDeleteManyArgs} args - Arguments to filter NotificationPreferences to delete.
     * @example
     * // Delete a few NotificationPreferences
     * const { count } = await prisma.notificationPreference.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends NotificationPreferenceDeleteManyArgs>(args?: SelectSubset<T, NotificationPreferenceDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more NotificationPreferences.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationPreferenceUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many NotificationPreferences
     * const notificationPreference = await prisma.notificationPreference.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends NotificationPreferenceUpdateManyArgs>(args: SelectSubset<T, NotificationPreferenceUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more NotificationPreferences and returns the data updated in the database.
     * @param {NotificationPreferenceUpdateManyAndReturnArgs} args - Arguments to update many NotificationPreferences.
     * @example
     * // Update many NotificationPreferences
     * const notificationPreference = await prisma.notificationPreference.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more NotificationPreferences and only return the `id`
     * const notificationPreferenceWithIdOnly = await prisma.notificationPreference.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends NotificationPreferenceUpdateManyAndReturnArgs>(args: SelectSubset<T, NotificationPreferenceUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPreferencePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one NotificationPreference.
     * @param {NotificationPreferenceUpsertArgs} args - Arguments to update or create a NotificationPreference.
     * @example
     * // Update or create a NotificationPreference
     * const notificationPreference = await prisma.notificationPreference.upsert({
     *   create: {
     *     // ... data to create a NotificationPreference
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the NotificationPreference we want to update
     *   }
     * })
     */
    upsert<T extends NotificationPreferenceUpsertArgs>(args: SelectSubset<T, NotificationPreferenceUpsertArgs<ExtArgs>>): Prisma__NotificationPreferenceClient<$Result.GetResult<Prisma.$NotificationPreferencePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of NotificationPreferences.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationPreferenceCountArgs} args - Arguments to filter NotificationPreferences to count.
     * @example
     * // Count the number of NotificationPreferences
     * const count = await prisma.notificationPreference.count({
     *   where: {
     *     // ... the filter for the NotificationPreferences we want to count
     *   }
     * })
    **/
    count<T extends NotificationPreferenceCountArgs>(
      args?: Subset<T, NotificationPreferenceCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], NotificationPreferenceCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a NotificationPreference.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationPreferenceAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends NotificationPreferenceAggregateArgs>(args: Subset<T, NotificationPreferenceAggregateArgs>): Prisma.PrismaPromise<GetNotificationPreferenceAggregateType<T>>

    /**
     * Group by NotificationPreference.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationPreferenceGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends NotificationPreferenceGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: NotificationPreferenceGroupByArgs['orderBy'] }
        : { orderBy?: NotificationPreferenceGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, NotificationPreferenceGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetNotificationPreferenceGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the NotificationPreference model
   */
  readonly fields: NotificationPreferenceFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for NotificationPreference.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__NotificationPreferenceClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the NotificationPreference model
   */
  interface NotificationPreferenceFieldRefs {
    readonly id: FieldRef<"NotificationPreference", 'String'>
    readonly userId: FieldRef<"NotificationPreference", 'String'>
    readonly inspectionSubmitted: FieldRef<"NotificationPreference", 'Boolean'>
    readonly paymentOverdue: FieldRef<"NotificationPreference", 'Boolean'>
    readonly newAssignment: FieldRef<"NotificationPreference", 'Boolean'>
    readonly queryCreated: FieldRef<"NotificationPreference", 'Boolean'>
    readonly drawingApproved: FieldRef<"NotificationPreference", 'Boolean'>
    readonly emailEnabled: FieldRef<"NotificationPreference", 'Boolean'>
    readonly inAppEnabled: FieldRef<"NotificationPreference", 'Boolean'>
    readonly updatedAt: FieldRef<"NotificationPreference", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * NotificationPreference findUnique
   */
  export type NotificationPreferenceFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationPreference
     */
    select?: NotificationPreferenceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NotificationPreference
     */
    omit?: NotificationPreferenceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationPreferenceInclude<ExtArgs> | null
    /**
     * Filter, which NotificationPreference to fetch.
     */
    where: NotificationPreferenceWhereUniqueInput
  }

  /**
   * NotificationPreference findUniqueOrThrow
   */
  export type NotificationPreferenceFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationPreference
     */
    select?: NotificationPreferenceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NotificationPreference
     */
    omit?: NotificationPreferenceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationPreferenceInclude<ExtArgs> | null
    /**
     * Filter, which NotificationPreference to fetch.
     */
    where: NotificationPreferenceWhereUniqueInput
  }

  /**
   * NotificationPreference findFirst
   */
  export type NotificationPreferenceFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationPreference
     */
    select?: NotificationPreferenceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NotificationPreference
     */
    omit?: NotificationPreferenceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationPreferenceInclude<ExtArgs> | null
    /**
     * Filter, which NotificationPreference to fetch.
     */
    where?: NotificationPreferenceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NotificationPreferences to fetch.
     */
    orderBy?: NotificationPreferenceOrderByWithRelationInput | NotificationPreferenceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for NotificationPreferences.
     */
    cursor?: NotificationPreferenceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NotificationPreferences from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NotificationPreferences.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of NotificationPreferences.
     */
    distinct?: NotificationPreferenceScalarFieldEnum | NotificationPreferenceScalarFieldEnum[]
  }

  /**
   * NotificationPreference findFirstOrThrow
   */
  export type NotificationPreferenceFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationPreference
     */
    select?: NotificationPreferenceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NotificationPreference
     */
    omit?: NotificationPreferenceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationPreferenceInclude<ExtArgs> | null
    /**
     * Filter, which NotificationPreference to fetch.
     */
    where?: NotificationPreferenceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NotificationPreferences to fetch.
     */
    orderBy?: NotificationPreferenceOrderByWithRelationInput | NotificationPreferenceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for NotificationPreferences.
     */
    cursor?: NotificationPreferenceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NotificationPreferences from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NotificationPreferences.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of NotificationPreferences.
     */
    distinct?: NotificationPreferenceScalarFieldEnum | NotificationPreferenceScalarFieldEnum[]
  }

  /**
   * NotificationPreference findMany
   */
  export type NotificationPreferenceFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationPreference
     */
    select?: NotificationPreferenceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NotificationPreference
     */
    omit?: NotificationPreferenceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationPreferenceInclude<ExtArgs> | null
    /**
     * Filter, which NotificationPreferences to fetch.
     */
    where?: NotificationPreferenceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NotificationPreferences to fetch.
     */
    orderBy?: NotificationPreferenceOrderByWithRelationInput | NotificationPreferenceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing NotificationPreferences.
     */
    cursor?: NotificationPreferenceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NotificationPreferences from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NotificationPreferences.
     */
    skip?: number
    distinct?: NotificationPreferenceScalarFieldEnum | NotificationPreferenceScalarFieldEnum[]
  }

  /**
   * NotificationPreference create
   */
  export type NotificationPreferenceCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationPreference
     */
    select?: NotificationPreferenceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NotificationPreference
     */
    omit?: NotificationPreferenceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationPreferenceInclude<ExtArgs> | null
    /**
     * The data needed to create a NotificationPreference.
     */
    data: XOR<NotificationPreferenceCreateInput, NotificationPreferenceUncheckedCreateInput>
  }

  /**
   * NotificationPreference createMany
   */
  export type NotificationPreferenceCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many NotificationPreferences.
     */
    data: NotificationPreferenceCreateManyInput | NotificationPreferenceCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * NotificationPreference createManyAndReturn
   */
  export type NotificationPreferenceCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationPreference
     */
    select?: NotificationPreferenceSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the NotificationPreference
     */
    omit?: NotificationPreferenceOmit<ExtArgs> | null
    /**
     * The data used to create many NotificationPreferences.
     */
    data: NotificationPreferenceCreateManyInput | NotificationPreferenceCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationPreferenceIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * NotificationPreference update
   */
  export type NotificationPreferenceUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationPreference
     */
    select?: NotificationPreferenceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NotificationPreference
     */
    omit?: NotificationPreferenceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationPreferenceInclude<ExtArgs> | null
    /**
     * The data needed to update a NotificationPreference.
     */
    data: XOR<NotificationPreferenceUpdateInput, NotificationPreferenceUncheckedUpdateInput>
    /**
     * Choose, which NotificationPreference to update.
     */
    where: NotificationPreferenceWhereUniqueInput
  }

  /**
   * NotificationPreference updateMany
   */
  export type NotificationPreferenceUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update NotificationPreferences.
     */
    data: XOR<NotificationPreferenceUpdateManyMutationInput, NotificationPreferenceUncheckedUpdateManyInput>
    /**
     * Filter which NotificationPreferences to update
     */
    where?: NotificationPreferenceWhereInput
    /**
     * Limit how many NotificationPreferences to update.
     */
    limit?: number
  }

  /**
   * NotificationPreference updateManyAndReturn
   */
  export type NotificationPreferenceUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationPreference
     */
    select?: NotificationPreferenceSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the NotificationPreference
     */
    omit?: NotificationPreferenceOmit<ExtArgs> | null
    /**
     * The data used to update NotificationPreferences.
     */
    data: XOR<NotificationPreferenceUpdateManyMutationInput, NotificationPreferenceUncheckedUpdateManyInput>
    /**
     * Filter which NotificationPreferences to update
     */
    where?: NotificationPreferenceWhereInput
    /**
     * Limit how many NotificationPreferences to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationPreferenceIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * NotificationPreference upsert
   */
  export type NotificationPreferenceUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationPreference
     */
    select?: NotificationPreferenceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NotificationPreference
     */
    omit?: NotificationPreferenceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationPreferenceInclude<ExtArgs> | null
    /**
     * The filter to search for the NotificationPreference to update in case it exists.
     */
    where: NotificationPreferenceWhereUniqueInput
    /**
     * In case the NotificationPreference found by the `where` argument doesn't exist, create a new NotificationPreference with this data.
     */
    create: XOR<NotificationPreferenceCreateInput, NotificationPreferenceUncheckedCreateInput>
    /**
     * In case the NotificationPreference was found with the provided `where` argument, update it with this data.
     */
    update: XOR<NotificationPreferenceUpdateInput, NotificationPreferenceUncheckedUpdateInput>
  }

  /**
   * NotificationPreference delete
   */
  export type NotificationPreferenceDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationPreference
     */
    select?: NotificationPreferenceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NotificationPreference
     */
    omit?: NotificationPreferenceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationPreferenceInclude<ExtArgs> | null
    /**
     * Filter which NotificationPreference to delete.
     */
    where: NotificationPreferenceWhereUniqueInput
  }

  /**
   * NotificationPreference deleteMany
   */
  export type NotificationPreferenceDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which NotificationPreferences to delete
     */
    where?: NotificationPreferenceWhereInput
    /**
     * Limit how many NotificationPreferences to delete.
     */
    limit?: number
  }

  /**
   * NotificationPreference without action
   */
  export type NotificationPreferenceDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationPreference
     */
    select?: NotificationPreferenceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NotificationPreference
     */
    omit?: NotificationPreferenceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationPreferenceInclude<ExtArgs> | null
  }


  /**
   * Model Milestone
   */

  export type AggregateMilestone = {
    _count: MilestoneCountAggregateOutputType | null
    _avg: MilestoneAvgAggregateOutputType | null
    _sum: MilestoneSumAggregateOutputType | null
    _min: MilestoneMinAggregateOutputType | null
    _max: MilestoneMaxAggregateOutputType | null
  }

  export type MilestoneAvgAggregateOutputType = {
    order: number | null
  }

  export type MilestoneSumAggregateOutputType = {
    order: number | null
  }

  export type MilestoneMinAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    order: number | null
    isActive: boolean | null
    projectId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type MilestoneMaxAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    order: number | null
    isActive: boolean | null
    projectId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type MilestoneCountAggregateOutputType = {
    id: number
    name: number
    description: number
    order: number
    isActive: number
    projectId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type MilestoneAvgAggregateInputType = {
    order?: true
  }

  export type MilestoneSumAggregateInputType = {
    order?: true
  }

  export type MilestoneMinAggregateInputType = {
    id?: true
    name?: true
    description?: true
    order?: true
    isActive?: true
    projectId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type MilestoneMaxAggregateInputType = {
    id?: true
    name?: true
    description?: true
    order?: true
    isActive?: true
    projectId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type MilestoneCountAggregateInputType = {
    id?: true
    name?: true
    description?: true
    order?: true
    isActive?: true
    projectId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type MilestoneAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Milestone to aggregate.
     */
    where?: MilestoneWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Milestones to fetch.
     */
    orderBy?: MilestoneOrderByWithRelationInput | MilestoneOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MilestoneWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Milestones from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Milestones.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Milestones
    **/
    _count?: true | MilestoneCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: MilestoneAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: MilestoneSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MilestoneMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MilestoneMaxAggregateInputType
  }

  export type GetMilestoneAggregateType<T extends MilestoneAggregateArgs> = {
        [P in keyof T & keyof AggregateMilestone]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMilestone[P]>
      : GetScalarType<T[P], AggregateMilestone[P]>
  }




  export type MilestoneGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MilestoneWhereInput
    orderBy?: MilestoneOrderByWithAggregationInput | MilestoneOrderByWithAggregationInput[]
    by: MilestoneScalarFieldEnum[] | MilestoneScalarFieldEnum
    having?: MilestoneScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MilestoneCountAggregateInputType | true
    _avg?: MilestoneAvgAggregateInputType
    _sum?: MilestoneSumAggregateInputType
    _min?: MilestoneMinAggregateInputType
    _max?: MilestoneMaxAggregateInputType
  }

  export type MilestoneGroupByOutputType = {
    id: string
    name: string
    description: string | null
    order: number
    isActive: boolean
    projectId: string
    createdAt: Date
    updatedAt: Date
    _count: MilestoneCountAggregateOutputType | null
    _avg: MilestoneAvgAggregateOutputType | null
    _sum: MilestoneSumAggregateOutputType | null
    _min: MilestoneMinAggregateOutputType | null
    _max: MilestoneMaxAggregateOutputType | null
  }

  type GetMilestoneGroupByPayload<T extends MilestoneGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MilestoneGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MilestoneGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MilestoneGroupByOutputType[P]>
            : GetScalarType<T[P], MilestoneGroupByOutputType[P]>
        }
      >
    >


  export type MilestoneSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    order?: boolean
    isActive?: boolean
    projectId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    project?: boolean | ProjectDefaultArgs<ExtArgs>
    checklistItems?: boolean | Milestone$checklistItemsArgs<ExtArgs>
    inspections?: boolean | Milestone$inspectionsArgs<ExtArgs>
    _count?: boolean | MilestoneCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["milestone"]>

  export type MilestoneSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    order?: boolean
    isActive?: boolean
    projectId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    project?: boolean | ProjectDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["milestone"]>

  export type MilestoneSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    order?: boolean
    isActive?: boolean
    projectId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    project?: boolean | ProjectDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["milestone"]>

  export type MilestoneSelectScalar = {
    id?: boolean
    name?: boolean
    description?: boolean
    order?: boolean
    isActive?: boolean
    projectId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type MilestoneOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "description" | "order" | "isActive" | "projectId" | "createdAt" | "updatedAt", ExtArgs["result"]["milestone"]>
  export type MilestoneInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    project?: boolean | ProjectDefaultArgs<ExtArgs>
    checklistItems?: boolean | Milestone$checklistItemsArgs<ExtArgs>
    inspections?: boolean | Milestone$inspectionsArgs<ExtArgs>
    _count?: boolean | MilestoneCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type MilestoneIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    project?: boolean | ProjectDefaultArgs<ExtArgs>
  }
  export type MilestoneIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    project?: boolean | ProjectDefaultArgs<ExtArgs>
  }

  export type $MilestonePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Milestone"
    objects: {
      project: Prisma.$ProjectPayload<ExtArgs>
      checklistItems: Prisma.$ChecklistItemPayload<ExtArgs>[]
      inspections: Prisma.$InspectionPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      description: string | null
      order: number
      isActive: boolean
      projectId: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["milestone"]>
    composites: {}
  }

  type MilestoneGetPayload<S extends boolean | null | undefined | MilestoneDefaultArgs> = $Result.GetResult<Prisma.$MilestonePayload, S>

  type MilestoneCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<MilestoneFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: MilestoneCountAggregateInputType | true
    }

  export interface MilestoneDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Milestone'], meta: { name: 'Milestone' } }
    /**
     * Find zero or one Milestone that matches the filter.
     * @param {MilestoneFindUniqueArgs} args - Arguments to find a Milestone
     * @example
     * // Get one Milestone
     * const milestone = await prisma.milestone.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MilestoneFindUniqueArgs>(args: SelectSubset<T, MilestoneFindUniqueArgs<ExtArgs>>): Prisma__MilestoneClient<$Result.GetResult<Prisma.$MilestonePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Milestone that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {MilestoneFindUniqueOrThrowArgs} args - Arguments to find a Milestone
     * @example
     * // Get one Milestone
     * const milestone = await prisma.milestone.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MilestoneFindUniqueOrThrowArgs>(args: SelectSubset<T, MilestoneFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MilestoneClient<$Result.GetResult<Prisma.$MilestonePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Milestone that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MilestoneFindFirstArgs} args - Arguments to find a Milestone
     * @example
     * // Get one Milestone
     * const milestone = await prisma.milestone.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MilestoneFindFirstArgs>(args?: SelectSubset<T, MilestoneFindFirstArgs<ExtArgs>>): Prisma__MilestoneClient<$Result.GetResult<Prisma.$MilestonePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Milestone that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MilestoneFindFirstOrThrowArgs} args - Arguments to find a Milestone
     * @example
     * // Get one Milestone
     * const milestone = await prisma.milestone.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MilestoneFindFirstOrThrowArgs>(args?: SelectSubset<T, MilestoneFindFirstOrThrowArgs<ExtArgs>>): Prisma__MilestoneClient<$Result.GetResult<Prisma.$MilestonePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Milestones that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MilestoneFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Milestones
     * const milestones = await prisma.milestone.findMany()
     * 
     * // Get first 10 Milestones
     * const milestones = await prisma.milestone.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const milestoneWithIdOnly = await prisma.milestone.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends MilestoneFindManyArgs>(args?: SelectSubset<T, MilestoneFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MilestonePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Milestone.
     * @param {MilestoneCreateArgs} args - Arguments to create a Milestone.
     * @example
     * // Create one Milestone
     * const Milestone = await prisma.milestone.create({
     *   data: {
     *     // ... data to create a Milestone
     *   }
     * })
     * 
     */
    create<T extends MilestoneCreateArgs>(args: SelectSubset<T, MilestoneCreateArgs<ExtArgs>>): Prisma__MilestoneClient<$Result.GetResult<Prisma.$MilestonePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Milestones.
     * @param {MilestoneCreateManyArgs} args - Arguments to create many Milestones.
     * @example
     * // Create many Milestones
     * const milestone = await prisma.milestone.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MilestoneCreateManyArgs>(args?: SelectSubset<T, MilestoneCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Milestones and returns the data saved in the database.
     * @param {MilestoneCreateManyAndReturnArgs} args - Arguments to create many Milestones.
     * @example
     * // Create many Milestones
     * const milestone = await prisma.milestone.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Milestones and only return the `id`
     * const milestoneWithIdOnly = await prisma.milestone.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends MilestoneCreateManyAndReturnArgs>(args?: SelectSubset<T, MilestoneCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MilestonePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Milestone.
     * @param {MilestoneDeleteArgs} args - Arguments to delete one Milestone.
     * @example
     * // Delete one Milestone
     * const Milestone = await prisma.milestone.delete({
     *   where: {
     *     // ... filter to delete one Milestone
     *   }
     * })
     * 
     */
    delete<T extends MilestoneDeleteArgs>(args: SelectSubset<T, MilestoneDeleteArgs<ExtArgs>>): Prisma__MilestoneClient<$Result.GetResult<Prisma.$MilestonePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Milestone.
     * @param {MilestoneUpdateArgs} args - Arguments to update one Milestone.
     * @example
     * // Update one Milestone
     * const milestone = await prisma.milestone.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MilestoneUpdateArgs>(args: SelectSubset<T, MilestoneUpdateArgs<ExtArgs>>): Prisma__MilestoneClient<$Result.GetResult<Prisma.$MilestonePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Milestones.
     * @param {MilestoneDeleteManyArgs} args - Arguments to filter Milestones to delete.
     * @example
     * // Delete a few Milestones
     * const { count } = await prisma.milestone.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MilestoneDeleteManyArgs>(args?: SelectSubset<T, MilestoneDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Milestones.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MilestoneUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Milestones
     * const milestone = await prisma.milestone.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MilestoneUpdateManyArgs>(args: SelectSubset<T, MilestoneUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Milestones and returns the data updated in the database.
     * @param {MilestoneUpdateManyAndReturnArgs} args - Arguments to update many Milestones.
     * @example
     * // Update many Milestones
     * const milestone = await prisma.milestone.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Milestones and only return the `id`
     * const milestoneWithIdOnly = await prisma.milestone.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends MilestoneUpdateManyAndReturnArgs>(args: SelectSubset<T, MilestoneUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MilestonePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Milestone.
     * @param {MilestoneUpsertArgs} args - Arguments to update or create a Milestone.
     * @example
     * // Update or create a Milestone
     * const milestone = await prisma.milestone.upsert({
     *   create: {
     *     // ... data to create a Milestone
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Milestone we want to update
     *   }
     * })
     */
    upsert<T extends MilestoneUpsertArgs>(args: SelectSubset<T, MilestoneUpsertArgs<ExtArgs>>): Prisma__MilestoneClient<$Result.GetResult<Prisma.$MilestonePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Milestones.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MilestoneCountArgs} args - Arguments to filter Milestones to count.
     * @example
     * // Count the number of Milestones
     * const count = await prisma.milestone.count({
     *   where: {
     *     // ... the filter for the Milestones we want to count
     *   }
     * })
    **/
    count<T extends MilestoneCountArgs>(
      args?: Subset<T, MilestoneCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MilestoneCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Milestone.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MilestoneAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MilestoneAggregateArgs>(args: Subset<T, MilestoneAggregateArgs>): Prisma.PrismaPromise<GetMilestoneAggregateType<T>>

    /**
     * Group by Milestone.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MilestoneGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MilestoneGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MilestoneGroupByArgs['orderBy'] }
        : { orderBy?: MilestoneGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MilestoneGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMilestoneGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Milestone model
   */
  readonly fields: MilestoneFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Milestone.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MilestoneClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    project<T extends ProjectDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProjectDefaultArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    checklistItems<T extends Milestone$checklistItemsArgs<ExtArgs> = {}>(args?: Subset<T, Milestone$checklistItemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChecklistItemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    inspections<T extends Milestone$inspectionsArgs<ExtArgs> = {}>(args?: Subset<T, Milestone$inspectionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InspectionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Milestone model
   */
  interface MilestoneFieldRefs {
    readonly id: FieldRef<"Milestone", 'String'>
    readonly name: FieldRef<"Milestone", 'String'>
    readonly description: FieldRef<"Milestone", 'String'>
    readonly order: FieldRef<"Milestone", 'Int'>
    readonly isActive: FieldRef<"Milestone", 'Boolean'>
    readonly projectId: FieldRef<"Milestone", 'String'>
    readonly createdAt: FieldRef<"Milestone", 'DateTime'>
    readonly updatedAt: FieldRef<"Milestone", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Milestone findUnique
   */
  export type MilestoneFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Milestone
     */
    select?: MilestoneSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Milestone
     */
    omit?: MilestoneOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MilestoneInclude<ExtArgs> | null
    /**
     * Filter, which Milestone to fetch.
     */
    where: MilestoneWhereUniqueInput
  }

  /**
   * Milestone findUniqueOrThrow
   */
  export type MilestoneFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Milestone
     */
    select?: MilestoneSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Milestone
     */
    omit?: MilestoneOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MilestoneInclude<ExtArgs> | null
    /**
     * Filter, which Milestone to fetch.
     */
    where: MilestoneWhereUniqueInput
  }

  /**
   * Milestone findFirst
   */
  export type MilestoneFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Milestone
     */
    select?: MilestoneSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Milestone
     */
    omit?: MilestoneOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MilestoneInclude<ExtArgs> | null
    /**
     * Filter, which Milestone to fetch.
     */
    where?: MilestoneWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Milestones to fetch.
     */
    orderBy?: MilestoneOrderByWithRelationInput | MilestoneOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Milestones.
     */
    cursor?: MilestoneWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Milestones from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Milestones.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Milestones.
     */
    distinct?: MilestoneScalarFieldEnum | MilestoneScalarFieldEnum[]
  }

  /**
   * Milestone findFirstOrThrow
   */
  export type MilestoneFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Milestone
     */
    select?: MilestoneSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Milestone
     */
    omit?: MilestoneOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MilestoneInclude<ExtArgs> | null
    /**
     * Filter, which Milestone to fetch.
     */
    where?: MilestoneWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Milestones to fetch.
     */
    orderBy?: MilestoneOrderByWithRelationInput | MilestoneOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Milestones.
     */
    cursor?: MilestoneWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Milestones from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Milestones.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Milestones.
     */
    distinct?: MilestoneScalarFieldEnum | MilestoneScalarFieldEnum[]
  }

  /**
   * Milestone findMany
   */
  export type MilestoneFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Milestone
     */
    select?: MilestoneSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Milestone
     */
    omit?: MilestoneOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MilestoneInclude<ExtArgs> | null
    /**
     * Filter, which Milestones to fetch.
     */
    where?: MilestoneWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Milestones to fetch.
     */
    orderBy?: MilestoneOrderByWithRelationInput | MilestoneOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Milestones.
     */
    cursor?: MilestoneWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Milestones from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Milestones.
     */
    skip?: number
    distinct?: MilestoneScalarFieldEnum | MilestoneScalarFieldEnum[]
  }

  /**
   * Milestone create
   */
  export type MilestoneCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Milestone
     */
    select?: MilestoneSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Milestone
     */
    omit?: MilestoneOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MilestoneInclude<ExtArgs> | null
    /**
     * The data needed to create a Milestone.
     */
    data: XOR<MilestoneCreateInput, MilestoneUncheckedCreateInput>
  }

  /**
   * Milestone createMany
   */
  export type MilestoneCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Milestones.
     */
    data: MilestoneCreateManyInput | MilestoneCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Milestone createManyAndReturn
   */
  export type MilestoneCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Milestone
     */
    select?: MilestoneSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Milestone
     */
    omit?: MilestoneOmit<ExtArgs> | null
    /**
     * The data used to create many Milestones.
     */
    data: MilestoneCreateManyInput | MilestoneCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MilestoneIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Milestone update
   */
  export type MilestoneUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Milestone
     */
    select?: MilestoneSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Milestone
     */
    omit?: MilestoneOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MilestoneInclude<ExtArgs> | null
    /**
     * The data needed to update a Milestone.
     */
    data: XOR<MilestoneUpdateInput, MilestoneUncheckedUpdateInput>
    /**
     * Choose, which Milestone to update.
     */
    where: MilestoneWhereUniqueInput
  }

  /**
   * Milestone updateMany
   */
  export type MilestoneUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Milestones.
     */
    data: XOR<MilestoneUpdateManyMutationInput, MilestoneUncheckedUpdateManyInput>
    /**
     * Filter which Milestones to update
     */
    where?: MilestoneWhereInput
    /**
     * Limit how many Milestones to update.
     */
    limit?: number
  }

  /**
   * Milestone updateManyAndReturn
   */
  export type MilestoneUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Milestone
     */
    select?: MilestoneSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Milestone
     */
    omit?: MilestoneOmit<ExtArgs> | null
    /**
     * The data used to update Milestones.
     */
    data: XOR<MilestoneUpdateManyMutationInput, MilestoneUncheckedUpdateManyInput>
    /**
     * Filter which Milestones to update
     */
    where?: MilestoneWhereInput
    /**
     * Limit how many Milestones to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MilestoneIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Milestone upsert
   */
  export type MilestoneUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Milestone
     */
    select?: MilestoneSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Milestone
     */
    omit?: MilestoneOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MilestoneInclude<ExtArgs> | null
    /**
     * The filter to search for the Milestone to update in case it exists.
     */
    where: MilestoneWhereUniqueInput
    /**
     * In case the Milestone found by the `where` argument doesn't exist, create a new Milestone with this data.
     */
    create: XOR<MilestoneCreateInput, MilestoneUncheckedCreateInput>
    /**
     * In case the Milestone was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MilestoneUpdateInput, MilestoneUncheckedUpdateInput>
  }

  /**
   * Milestone delete
   */
  export type MilestoneDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Milestone
     */
    select?: MilestoneSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Milestone
     */
    omit?: MilestoneOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MilestoneInclude<ExtArgs> | null
    /**
     * Filter which Milestone to delete.
     */
    where: MilestoneWhereUniqueInput
  }

  /**
   * Milestone deleteMany
   */
  export type MilestoneDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Milestones to delete
     */
    where?: MilestoneWhereInput
    /**
     * Limit how many Milestones to delete.
     */
    limit?: number
  }

  /**
   * Milestone.checklistItems
   */
  export type Milestone$checklistItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChecklistItem
     */
    select?: ChecklistItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChecklistItem
     */
    omit?: ChecklistItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChecklistItemInclude<ExtArgs> | null
    where?: ChecklistItemWhereInput
    orderBy?: ChecklistItemOrderByWithRelationInput | ChecklistItemOrderByWithRelationInput[]
    cursor?: ChecklistItemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ChecklistItemScalarFieldEnum | ChecklistItemScalarFieldEnum[]
  }

  /**
   * Milestone.inspections
   */
  export type Milestone$inspectionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Inspection
     */
    select?: InspectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Inspection
     */
    omit?: InspectionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InspectionInclude<ExtArgs> | null
    where?: InspectionWhereInput
    orderBy?: InspectionOrderByWithRelationInput | InspectionOrderByWithRelationInput[]
    cursor?: InspectionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: InspectionScalarFieldEnum | InspectionScalarFieldEnum[]
  }

  /**
   * Milestone without action
   */
  export type MilestoneDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Milestone
     */
    select?: MilestoneSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Milestone
     */
    omit?: MilestoneOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MilestoneInclude<ExtArgs> | null
  }


  /**
   * Model ChecklistItem
   */

  export type AggregateChecklistItem = {
    _count: ChecklistItemCountAggregateOutputType | null
    _avg: ChecklistItemAvgAggregateOutputType | null
    _sum: ChecklistItemSumAggregateOutputType | null
    _min: ChecklistItemMinAggregateOutputType | null
    _max: ChecklistItemMaxAggregateOutputType | null
  }

  export type ChecklistItemAvgAggregateOutputType = {
    order: number | null
  }

  export type ChecklistItemSumAggregateOutputType = {
    order: number | null
  }

  export type ChecklistItemMinAggregateOutputType = {
    id: string | null
    title: string | null
    description: string | null
    order: number | null
    isRequired: boolean | null
    isPhotoRequired: boolean | null
    milestoneId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ChecklistItemMaxAggregateOutputType = {
    id: string | null
    title: string | null
    description: string | null
    order: number | null
    isRequired: boolean | null
    isPhotoRequired: boolean | null
    milestoneId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ChecklistItemCountAggregateOutputType = {
    id: number
    title: number
    description: number
    order: number
    isRequired: number
    isPhotoRequired: number
    milestoneId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ChecklistItemAvgAggregateInputType = {
    order?: true
  }

  export type ChecklistItemSumAggregateInputType = {
    order?: true
  }

  export type ChecklistItemMinAggregateInputType = {
    id?: true
    title?: true
    description?: true
    order?: true
    isRequired?: true
    isPhotoRequired?: true
    milestoneId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ChecklistItemMaxAggregateInputType = {
    id?: true
    title?: true
    description?: true
    order?: true
    isRequired?: true
    isPhotoRequired?: true
    milestoneId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ChecklistItemCountAggregateInputType = {
    id?: true
    title?: true
    description?: true
    order?: true
    isRequired?: true
    isPhotoRequired?: true
    milestoneId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ChecklistItemAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ChecklistItem to aggregate.
     */
    where?: ChecklistItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ChecklistItems to fetch.
     */
    orderBy?: ChecklistItemOrderByWithRelationInput | ChecklistItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ChecklistItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ChecklistItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ChecklistItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ChecklistItems
    **/
    _count?: true | ChecklistItemCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ChecklistItemAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ChecklistItemSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ChecklistItemMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ChecklistItemMaxAggregateInputType
  }

  export type GetChecklistItemAggregateType<T extends ChecklistItemAggregateArgs> = {
        [P in keyof T & keyof AggregateChecklistItem]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateChecklistItem[P]>
      : GetScalarType<T[P], AggregateChecklistItem[P]>
  }




  export type ChecklistItemGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ChecklistItemWhereInput
    orderBy?: ChecklistItemOrderByWithAggregationInput | ChecklistItemOrderByWithAggregationInput[]
    by: ChecklistItemScalarFieldEnum[] | ChecklistItemScalarFieldEnum
    having?: ChecklistItemScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ChecklistItemCountAggregateInputType | true
    _avg?: ChecklistItemAvgAggregateInputType
    _sum?: ChecklistItemSumAggregateInputType
    _min?: ChecklistItemMinAggregateInputType
    _max?: ChecklistItemMaxAggregateInputType
  }

  export type ChecklistItemGroupByOutputType = {
    id: string
    title: string
    description: string | null
    order: number
    isRequired: boolean
    isPhotoRequired: boolean
    milestoneId: string
    createdAt: Date
    updatedAt: Date
    _count: ChecklistItemCountAggregateOutputType | null
    _avg: ChecklistItemAvgAggregateOutputType | null
    _sum: ChecklistItemSumAggregateOutputType | null
    _min: ChecklistItemMinAggregateOutputType | null
    _max: ChecklistItemMaxAggregateOutputType | null
  }

  type GetChecklistItemGroupByPayload<T extends ChecklistItemGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ChecklistItemGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ChecklistItemGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ChecklistItemGroupByOutputType[P]>
            : GetScalarType<T[P], ChecklistItemGroupByOutputType[P]>
        }
      >
    >


  export type ChecklistItemSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    description?: boolean
    order?: boolean
    isRequired?: boolean
    isPhotoRequired?: boolean
    milestoneId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    milestone?: boolean | MilestoneDefaultArgs<ExtArgs>
    responses?: boolean | ChecklistItem$responsesArgs<ExtArgs>
    _count?: boolean | ChecklistItemCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["checklistItem"]>

  export type ChecklistItemSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    description?: boolean
    order?: boolean
    isRequired?: boolean
    isPhotoRequired?: boolean
    milestoneId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    milestone?: boolean | MilestoneDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["checklistItem"]>

  export type ChecklistItemSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    description?: boolean
    order?: boolean
    isRequired?: boolean
    isPhotoRequired?: boolean
    milestoneId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    milestone?: boolean | MilestoneDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["checklistItem"]>

  export type ChecklistItemSelectScalar = {
    id?: boolean
    title?: boolean
    description?: boolean
    order?: boolean
    isRequired?: boolean
    isPhotoRequired?: boolean
    milestoneId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ChecklistItemOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "title" | "description" | "order" | "isRequired" | "isPhotoRequired" | "milestoneId" | "createdAt" | "updatedAt", ExtArgs["result"]["checklistItem"]>
  export type ChecklistItemInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    milestone?: boolean | MilestoneDefaultArgs<ExtArgs>
    responses?: boolean | ChecklistItem$responsesArgs<ExtArgs>
    _count?: boolean | ChecklistItemCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ChecklistItemIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    milestone?: boolean | MilestoneDefaultArgs<ExtArgs>
  }
  export type ChecklistItemIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    milestone?: boolean | MilestoneDefaultArgs<ExtArgs>
  }

  export type $ChecklistItemPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ChecklistItem"
    objects: {
      milestone: Prisma.$MilestonePayload<ExtArgs>
      responses: Prisma.$InspectionResponsePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      title: string
      description: string | null
      order: number
      isRequired: boolean
      isPhotoRequired: boolean
      milestoneId: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["checklistItem"]>
    composites: {}
  }

  type ChecklistItemGetPayload<S extends boolean | null | undefined | ChecklistItemDefaultArgs> = $Result.GetResult<Prisma.$ChecklistItemPayload, S>

  type ChecklistItemCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ChecklistItemFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ChecklistItemCountAggregateInputType | true
    }

  export interface ChecklistItemDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ChecklistItem'], meta: { name: 'ChecklistItem' } }
    /**
     * Find zero or one ChecklistItem that matches the filter.
     * @param {ChecklistItemFindUniqueArgs} args - Arguments to find a ChecklistItem
     * @example
     * // Get one ChecklistItem
     * const checklistItem = await prisma.checklistItem.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ChecklistItemFindUniqueArgs>(args: SelectSubset<T, ChecklistItemFindUniqueArgs<ExtArgs>>): Prisma__ChecklistItemClient<$Result.GetResult<Prisma.$ChecklistItemPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ChecklistItem that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ChecklistItemFindUniqueOrThrowArgs} args - Arguments to find a ChecklistItem
     * @example
     * // Get one ChecklistItem
     * const checklistItem = await prisma.checklistItem.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ChecklistItemFindUniqueOrThrowArgs>(args: SelectSubset<T, ChecklistItemFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ChecklistItemClient<$Result.GetResult<Prisma.$ChecklistItemPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ChecklistItem that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChecklistItemFindFirstArgs} args - Arguments to find a ChecklistItem
     * @example
     * // Get one ChecklistItem
     * const checklistItem = await prisma.checklistItem.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ChecklistItemFindFirstArgs>(args?: SelectSubset<T, ChecklistItemFindFirstArgs<ExtArgs>>): Prisma__ChecklistItemClient<$Result.GetResult<Prisma.$ChecklistItemPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ChecklistItem that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChecklistItemFindFirstOrThrowArgs} args - Arguments to find a ChecklistItem
     * @example
     * // Get one ChecklistItem
     * const checklistItem = await prisma.checklistItem.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ChecklistItemFindFirstOrThrowArgs>(args?: SelectSubset<T, ChecklistItemFindFirstOrThrowArgs<ExtArgs>>): Prisma__ChecklistItemClient<$Result.GetResult<Prisma.$ChecklistItemPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ChecklistItems that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChecklistItemFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ChecklistItems
     * const checklistItems = await prisma.checklistItem.findMany()
     * 
     * // Get first 10 ChecklistItems
     * const checklistItems = await prisma.checklistItem.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const checklistItemWithIdOnly = await prisma.checklistItem.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ChecklistItemFindManyArgs>(args?: SelectSubset<T, ChecklistItemFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChecklistItemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ChecklistItem.
     * @param {ChecklistItemCreateArgs} args - Arguments to create a ChecklistItem.
     * @example
     * // Create one ChecklistItem
     * const ChecklistItem = await prisma.checklistItem.create({
     *   data: {
     *     // ... data to create a ChecklistItem
     *   }
     * })
     * 
     */
    create<T extends ChecklistItemCreateArgs>(args: SelectSubset<T, ChecklistItemCreateArgs<ExtArgs>>): Prisma__ChecklistItemClient<$Result.GetResult<Prisma.$ChecklistItemPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ChecklistItems.
     * @param {ChecklistItemCreateManyArgs} args - Arguments to create many ChecklistItems.
     * @example
     * // Create many ChecklistItems
     * const checklistItem = await prisma.checklistItem.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ChecklistItemCreateManyArgs>(args?: SelectSubset<T, ChecklistItemCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ChecklistItems and returns the data saved in the database.
     * @param {ChecklistItemCreateManyAndReturnArgs} args - Arguments to create many ChecklistItems.
     * @example
     * // Create many ChecklistItems
     * const checklistItem = await prisma.checklistItem.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ChecklistItems and only return the `id`
     * const checklistItemWithIdOnly = await prisma.checklistItem.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ChecklistItemCreateManyAndReturnArgs>(args?: SelectSubset<T, ChecklistItemCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChecklistItemPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ChecklistItem.
     * @param {ChecklistItemDeleteArgs} args - Arguments to delete one ChecklistItem.
     * @example
     * // Delete one ChecklistItem
     * const ChecklistItem = await prisma.checklistItem.delete({
     *   where: {
     *     // ... filter to delete one ChecklistItem
     *   }
     * })
     * 
     */
    delete<T extends ChecklistItemDeleteArgs>(args: SelectSubset<T, ChecklistItemDeleteArgs<ExtArgs>>): Prisma__ChecklistItemClient<$Result.GetResult<Prisma.$ChecklistItemPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ChecklistItem.
     * @param {ChecklistItemUpdateArgs} args - Arguments to update one ChecklistItem.
     * @example
     * // Update one ChecklistItem
     * const checklistItem = await prisma.checklistItem.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ChecklistItemUpdateArgs>(args: SelectSubset<T, ChecklistItemUpdateArgs<ExtArgs>>): Prisma__ChecklistItemClient<$Result.GetResult<Prisma.$ChecklistItemPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ChecklistItems.
     * @param {ChecklistItemDeleteManyArgs} args - Arguments to filter ChecklistItems to delete.
     * @example
     * // Delete a few ChecklistItems
     * const { count } = await prisma.checklistItem.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ChecklistItemDeleteManyArgs>(args?: SelectSubset<T, ChecklistItemDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ChecklistItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChecklistItemUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ChecklistItems
     * const checklistItem = await prisma.checklistItem.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ChecklistItemUpdateManyArgs>(args: SelectSubset<T, ChecklistItemUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ChecklistItems and returns the data updated in the database.
     * @param {ChecklistItemUpdateManyAndReturnArgs} args - Arguments to update many ChecklistItems.
     * @example
     * // Update many ChecklistItems
     * const checklistItem = await prisma.checklistItem.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ChecklistItems and only return the `id`
     * const checklistItemWithIdOnly = await prisma.checklistItem.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ChecklistItemUpdateManyAndReturnArgs>(args: SelectSubset<T, ChecklistItemUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChecklistItemPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ChecklistItem.
     * @param {ChecklistItemUpsertArgs} args - Arguments to update or create a ChecklistItem.
     * @example
     * // Update or create a ChecklistItem
     * const checklistItem = await prisma.checklistItem.upsert({
     *   create: {
     *     // ... data to create a ChecklistItem
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ChecklistItem we want to update
     *   }
     * })
     */
    upsert<T extends ChecklistItemUpsertArgs>(args: SelectSubset<T, ChecklistItemUpsertArgs<ExtArgs>>): Prisma__ChecklistItemClient<$Result.GetResult<Prisma.$ChecklistItemPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ChecklistItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChecklistItemCountArgs} args - Arguments to filter ChecklistItems to count.
     * @example
     * // Count the number of ChecklistItems
     * const count = await prisma.checklistItem.count({
     *   where: {
     *     // ... the filter for the ChecklistItems we want to count
     *   }
     * })
    **/
    count<T extends ChecklistItemCountArgs>(
      args?: Subset<T, ChecklistItemCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ChecklistItemCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ChecklistItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChecklistItemAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ChecklistItemAggregateArgs>(args: Subset<T, ChecklistItemAggregateArgs>): Prisma.PrismaPromise<GetChecklistItemAggregateType<T>>

    /**
     * Group by ChecklistItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChecklistItemGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ChecklistItemGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ChecklistItemGroupByArgs['orderBy'] }
        : { orderBy?: ChecklistItemGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ChecklistItemGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetChecklistItemGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ChecklistItem model
   */
  readonly fields: ChecklistItemFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ChecklistItem.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ChecklistItemClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    milestone<T extends MilestoneDefaultArgs<ExtArgs> = {}>(args?: Subset<T, MilestoneDefaultArgs<ExtArgs>>): Prisma__MilestoneClient<$Result.GetResult<Prisma.$MilestonePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    responses<T extends ChecklistItem$responsesArgs<ExtArgs> = {}>(args?: Subset<T, ChecklistItem$responsesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InspectionResponsePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ChecklistItem model
   */
  interface ChecklistItemFieldRefs {
    readonly id: FieldRef<"ChecklistItem", 'String'>
    readonly title: FieldRef<"ChecklistItem", 'String'>
    readonly description: FieldRef<"ChecklistItem", 'String'>
    readonly order: FieldRef<"ChecklistItem", 'Int'>
    readonly isRequired: FieldRef<"ChecklistItem", 'Boolean'>
    readonly isPhotoRequired: FieldRef<"ChecklistItem", 'Boolean'>
    readonly milestoneId: FieldRef<"ChecklistItem", 'String'>
    readonly createdAt: FieldRef<"ChecklistItem", 'DateTime'>
    readonly updatedAt: FieldRef<"ChecklistItem", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ChecklistItem findUnique
   */
  export type ChecklistItemFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChecklistItem
     */
    select?: ChecklistItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChecklistItem
     */
    omit?: ChecklistItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChecklistItemInclude<ExtArgs> | null
    /**
     * Filter, which ChecklistItem to fetch.
     */
    where: ChecklistItemWhereUniqueInput
  }

  /**
   * ChecklistItem findUniqueOrThrow
   */
  export type ChecklistItemFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChecklistItem
     */
    select?: ChecklistItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChecklistItem
     */
    omit?: ChecklistItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChecklistItemInclude<ExtArgs> | null
    /**
     * Filter, which ChecklistItem to fetch.
     */
    where: ChecklistItemWhereUniqueInput
  }

  /**
   * ChecklistItem findFirst
   */
  export type ChecklistItemFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChecklistItem
     */
    select?: ChecklistItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChecklistItem
     */
    omit?: ChecklistItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChecklistItemInclude<ExtArgs> | null
    /**
     * Filter, which ChecklistItem to fetch.
     */
    where?: ChecklistItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ChecklistItems to fetch.
     */
    orderBy?: ChecklistItemOrderByWithRelationInput | ChecklistItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ChecklistItems.
     */
    cursor?: ChecklistItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ChecklistItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ChecklistItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ChecklistItems.
     */
    distinct?: ChecklistItemScalarFieldEnum | ChecklistItemScalarFieldEnum[]
  }

  /**
   * ChecklistItem findFirstOrThrow
   */
  export type ChecklistItemFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChecklistItem
     */
    select?: ChecklistItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChecklistItem
     */
    omit?: ChecklistItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChecklistItemInclude<ExtArgs> | null
    /**
     * Filter, which ChecklistItem to fetch.
     */
    where?: ChecklistItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ChecklistItems to fetch.
     */
    orderBy?: ChecklistItemOrderByWithRelationInput | ChecklistItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ChecklistItems.
     */
    cursor?: ChecklistItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ChecklistItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ChecklistItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ChecklistItems.
     */
    distinct?: ChecklistItemScalarFieldEnum | ChecklistItemScalarFieldEnum[]
  }

  /**
   * ChecklistItem findMany
   */
  export type ChecklistItemFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChecklistItem
     */
    select?: ChecklistItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChecklistItem
     */
    omit?: ChecklistItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChecklistItemInclude<ExtArgs> | null
    /**
     * Filter, which ChecklistItems to fetch.
     */
    where?: ChecklistItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ChecklistItems to fetch.
     */
    orderBy?: ChecklistItemOrderByWithRelationInput | ChecklistItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ChecklistItems.
     */
    cursor?: ChecklistItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ChecklistItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ChecklistItems.
     */
    skip?: number
    distinct?: ChecklistItemScalarFieldEnum | ChecklistItemScalarFieldEnum[]
  }

  /**
   * ChecklistItem create
   */
  export type ChecklistItemCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChecklistItem
     */
    select?: ChecklistItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChecklistItem
     */
    omit?: ChecklistItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChecklistItemInclude<ExtArgs> | null
    /**
     * The data needed to create a ChecklistItem.
     */
    data: XOR<ChecklistItemCreateInput, ChecklistItemUncheckedCreateInput>
  }

  /**
   * ChecklistItem createMany
   */
  export type ChecklistItemCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ChecklistItems.
     */
    data: ChecklistItemCreateManyInput | ChecklistItemCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ChecklistItem createManyAndReturn
   */
  export type ChecklistItemCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChecklistItem
     */
    select?: ChecklistItemSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ChecklistItem
     */
    omit?: ChecklistItemOmit<ExtArgs> | null
    /**
     * The data used to create many ChecklistItems.
     */
    data: ChecklistItemCreateManyInput | ChecklistItemCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChecklistItemIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ChecklistItem update
   */
  export type ChecklistItemUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChecklistItem
     */
    select?: ChecklistItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChecklistItem
     */
    omit?: ChecklistItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChecklistItemInclude<ExtArgs> | null
    /**
     * The data needed to update a ChecklistItem.
     */
    data: XOR<ChecklistItemUpdateInput, ChecklistItemUncheckedUpdateInput>
    /**
     * Choose, which ChecklistItem to update.
     */
    where: ChecklistItemWhereUniqueInput
  }

  /**
   * ChecklistItem updateMany
   */
  export type ChecklistItemUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ChecklistItems.
     */
    data: XOR<ChecklistItemUpdateManyMutationInput, ChecklistItemUncheckedUpdateManyInput>
    /**
     * Filter which ChecklistItems to update
     */
    where?: ChecklistItemWhereInput
    /**
     * Limit how many ChecklistItems to update.
     */
    limit?: number
  }

  /**
   * ChecklistItem updateManyAndReturn
   */
  export type ChecklistItemUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChecklistItem
     */
    select?: ChecklistItemSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ChecklistItem
     */
    omit?: ChecklistItemOmit<ExtArgs> | null
    /**
     * The data used to update ChecklistItems.
     */
    data: XOR<ChecklistItemUpdateManyMutationInput, ChecklistItemUncheckedUpdateManyInput>
    /**
     * Filter which ChecklistItems to update
     */
    where?: ChecklistItemWhereInput
    /**
     * Limit how many ChecklistItems to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChecklistItemIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ChecklistItem upsert
   */
  export type ChecklistItemUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChecklistItem
     */
    select?: ChecklistItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChecklistItem
     */
    omit?: ChecklistItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChecklistItemInclude<ExtArgs> | null
    /**
     * The filter to search for the ChecklistItem to update in case it exists.
     */
    where: ChecklistItemWhereUniqueInput
    /**
     * In case the ChecklistItem found by the `where` argument doesn't exist, create a new ChecklistItem with this data.
     */
    create: XOR<ChecklistItemCreateInput, ChecklistItemUncheckedCreateInput>
    /**
     * In case the ChecklistItem was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ChecklistItemUpdateInput, ChecklistItemUncheckedUpdateInput>
  }

  /**
   * ChecklistItem delete
   */
  export type ChecklistItemDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChecklistItem
     */
    select?: ChecklistItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChecklistItem
     */
    omit?: ChecklistItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChecklistItemInclude<ExtArgs> | null
    /**
     * Filter which ChecklistItem to delete.
     */
    where: ChecklistItemWhereUniqueInput
  }

  /**
   * ChecklistItem deleteMany
   */
  export type ChecklistItemDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ChecklistItems to delete
     */
    where?: ChecklistItemWhereInput
    /**
     * Limit how many ChecklistItems to delete.
     */
    limit?: number
  }

  /**
   * ChecklistItem.responses
   */
  export type ChecklistItem$responsesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InspectionResponse
     */
    select?: InspectionResponseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InspectionResponse
     */
    omit?: InspectionResponseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InspectionResponseInclude<ExtArgs> | null
    where?: InspectionResponseWhereInput
    orderBy?: InspectionResponseOrderByWithRelationInput | InspectionResponseOrderByWithRelationInput[]
    cursor?: InspectionResponseWhereUniqueInput
    take?: number
    skip?: number
    distinct?: InspectionResponseScalarFieldEnum | InspectionResponseScalarFieldEnum[]
  }

  /**
   * ChecklistItem without action
   */
  export type ChecklistItemDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChecklistItem
     */
    select?: ChecklistItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChecklistItem
     */
    omit?: ChecklistItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChecklistItemInclude<ExtArgs> | null
  }


  /**
   * Model Inspection
   */

  export type AggregateInspection = {
    _count: InspectionCountAggregateOutputType | null
    _min: InspectionMinAggregateOutputType | null
    _max: InspectionMaxAggregateOutputType | null
  }

  export type InspectionMinAggregateOutputType = {
    id: string | null
    status: $Enums.InspectionStatus | null
    projectId: string | null
    milestoneId: string | null
    engineerId: string | null
    reviewedById: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type InspectionMaxAggregateOutputType = {
    id: string | null
    status: $Enums.InspectionStatus | null
    projectId: string | null
    milestoneId: string | null
    engineerId: string | null
    reviewedById: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type InspectionCountAggregateOutputType = {
    id: number
    status: number
    projectId: number
    milestoneId: number
    engineerId: number
    reviewedById: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type InspectionMinAggregateInputType = {
    id?: true
    status?: true
    projectId?: true
    milestoneId?: true
    engineerId?: true
    reviewedById?: true
    createdAt?: true
    updatedAt?: true
  }

  export type InspectionMaxAggregateInputType = {
    id?: true
    status?: true
    projectId?: true
    milestoneId?: true
    engineerId?: true
    reviewedById?: true
    createdAt?: true
    updatedAt?: true
  }

  export type InspectionCountAggregateInputType = {
    id?: true
    status?: true
    projectId?: true
    milestoneId?: true
    engineerId?: true
    reviewedById?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type InspectionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Inspection to aggregate.
     */
    where?: InspectionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Inspections to fetch.
     */
    orderBy?: InspectionOrderByWithRelationInput | InspectionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: InspectionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Inspections from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Inspections.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Inspections
    **/
    _count?: true | InspectionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: InspectionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: InspectionMaxAggregateInputType
  }

  export type GetInspectionAggregateType<T extends InspectionAggregateArgs> = {
        [P in keyof T & keyof AggregateInspection]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateInspection[P]>
      : GetScalarType<T[P], AggregateInspection[P]>
  }




  export type InspectionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InspectionWhereInput
    orderBy?: InspectionOrderByWithAggregationInput | InspectionOrderByWithAggregationInput[]
    by: InspectionScalarFieldEnum[] | InspectionScalarFieldEnum
    having?: InspectionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: InspectionCountAggregateInputType | true
    _min?: InspectionMinAggregateInputType
    _max?: InspectionMaxAggregateInputType
  }

  export type InspectionGroupByOutputType = {
    id: string
    status: $Enums.InspectionStatus
    projectId: string
    milestoneId: string
    engineerId: string
    reviewedById: string | null
    createdAt: Date
    updatedAt: Date
    _count: InspectionCountAggregateOutputType | null
    _min: InspectionMinAggregateOutputType | null
    _max: InspectionMaxAggregateOutputType | null
  }

  type GetInspectionGroupByPayload<T extends InspectionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<InspectionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof InspectionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], InspectionGroupByOutputType[P]>
            : GetScalarType<T[P], InspectionGroupByOutputType[P]>
        }
      >
    >


  export type InspectionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    status?: boolean
    projectId?: boolean
    milestoneId?: boolean
    engineerId?: boolean
    reviewedById?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    project?: boolean | ProjectDefaultArgs<ExtArgs>
    milestone?: boolean | MilestoneDefaultArgs<ExtArgs>
    engineer?: boolean | UserDefaultArgs<ExtArgs>
    responses?: boolean | Inspection$responsesArgs<ExtArgs>
    reviewedBy?: boolean | Inspection$reviewedByArgs<ExtArgs>
    _count?: boolean | InspectionCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["inspection"]>

  export type InspectionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    status?: boolean
    projectId?: boolean
    milestoneId?: boolean
    engineerId?: boolean
    reviewedById?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    project?: boolean | ProjectDefaultArgs<ExtArgs>
    milestone?: boolean | MilestoneDefaultArgs<ExtArgs>
    engineer?: boolean | UserDefaultArgs<ExtArgs>
    reviewedBy?: boolean | Inspection$reviewedByArgs<ExtArgs>
  }, ExtArgs["result"]["inspection"]>

  export type InspectionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    status?: boolean
    projectId?: boolean
    milestoneId?: boolean
    engineerId?: boolean
    reviewedById?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    project?: boolean | ProjectDefaultArgs<ExtArgs>
    milestone?: boolean | MilestoneDefaultArgs<ExtArgs>
    engineer?: boolean | UserDefaultArgs<ExtArgs>
    reviewedBy?: boolean | Inspection$reviewedByArgs<ExtArgs>
  }, ExtArgs["result"]["inspection"]>

  export type InspectionSelectScalar = {
    id?: boolean
    status?: boolean
    projectId?: boolean
    milestoneId?: boolean
    engineerId?: boolean
    reviewedById?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type InspectionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "status" | "projectId" | "milestoneId" | "engineerId" | "reviewedById" | "createdAt" | "updatedAt", ExtArgs["result"]["inspection"]>
  export type InspectionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    project?: boolean | ProjectDefaultArgs<ExtArgs>
    milestone?: boolean | MilestoneDefaultArgs<ExtArgs>
    engineer?: boolean | UserDefaultArgs<ExtArgs>
    responses?: boolean | Inspection$responsesArgs<ExtArgs>
    reviewedBy?: boolean | Inspection$reviewedByArgs<ExtArgs>
    _count?: boolean | InspectionCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type InspectionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    project?: boolean | ProjectDefaultArgs<ExtArgs>
    milestone?: boolean | MilestoneDefaultArgs<ExtArgs>
    engineer?: boolean | UserDefaultArgs<ExtArgs>
    reviewedBy?: boolean | Inspection$reviewedByArgs<ExtArgs>
  }
  export type InspectionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    project?: boolean | ProjectDefaultArgs<ExtArgs>
    milestone?: boolean | MilestoneDefaultArgs<ExtArgs>
    engineer?: boolean | UserDefaultArgs<ExtArgs>
    reviewedBy?: boolean | Inspection$reviewedByArgs<ExtArgs>
  }

  export type $InspectionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Inspection"
    objects: {
      project: Prisma.$ProjectPayload<ExtArgs>
      milestone: Prisma.$MilestonePayload<ExtArgs>
      engineer: Prisma.$UserPayload<ExtArgs>
      responses: Prisma.$InspectionResponsePayload<ExtArgs>[]
      reviewedBy: Prisma.$UserPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      status: $Enums.InspectionStatus
      projectId: string
      milestoneId: string
      engineerId: string
      reviewedById: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["inspection"]>
    composites: {}
  }

  type InspectionGetPayload<S extends boolean | null | undefined | InspectionDefaultArgs> = $Result.GetResult<Prisma.$InspectionPayload, S>

  type InspectionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<InspectionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: InspectionCountAggregateInputType | true
    }

  export interface InspectionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Inspection'], meta: { name: 'Inspection' } }
    /**
     * Find zero or one Inspection that matches the filter.
     * @param {InspectionFindUniqueArgs} args - Arguments to find a Inspection
     * @example
     * // Get one Inspection
     * const inspection = await prisma.inspection.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends InspectionFindUniqueArgs>(args: SelectSubset<T, InspectionFindUniqueArgs<ExtArgs>>): Prisma__InspectionClient<$Result.GetResult<Prisma.$InspectionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Inspection that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {InspectionFindUniqueOrThrowArgs} args - Arguments to find a Inspection
     * @example
     * // Get one Inspection
     * const inspection = await prisma.inspection.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends InspectionFindUniqueOrThrowArgs>(args: SelectSubset<T, InspectionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__InspectionClient<$Result.GetResult<Prisma.$InspectionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Inspection that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InspectionFindFirstArgs} args - Arguments to find a Inspection
     * @example
     * // Get one Inspection
     * const inspection = await prisma.inspection.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends InspectionFindFirstArgs>(args?: SelectSubset<T, InspectionFindFirstArgs<ExtArgs>>): Prisma__InspectionClient<$Result.GetResult<Prisma.$InspectionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Inspection that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InspectionFindFirstOrThrowArgs} args - Arguments to find a Inspection
     * @example
     * // Get one Inspection
     * const inspection = await prisma.inspection.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends InspectionFindFirstOrThrowArgs>(args?: SelectSubset<T, InspectionFindFirstOrThrowArgs<ExtArgs>>): Prisma__InspectionClient<$Result.GetResult<Prisma.$InspectionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Inspections that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InspectionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Inspections
     * const inspections = await prisma.inspection.findMany()
     * 
     * // Get first 10 Inspections
     * const inspections = await prisma.inspection.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const inspectionWithIdOnly = await prisma.inspection.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends InspectionFindManyArgs>(args?: SelectSubset<T, InspectionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InspectionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Inspection.
     * @param {InspectionCreateArgs} args - Arguments to create a Inspection.
     * @example
     * // Create one Inspection
     * const Inspection = await prisma.inspection.create({
     *   data: {
     *     // ... data to create a Inspection
     *   }
     * })
     * 
     */
    create<T extends InspectionCreateArgs>(args: SelectSubset<T, InspectionCreateArgs<ExtArgs>>): Prisma__InspectionClient<$Result.GetResult<Prisma.$InspectionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Inspections.
     * @param {InspectionCreateManyArgs} args - Arguments to create many Inspections.
     * @example
     * // Create many Inspections
     * const inspection = await prisma.inspection.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends InspectionCreateManyArgs>(args?: SelectSubset<T, InspectionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Inspections and returns the data saved in the database.
     * @param {InspectionCreateManyAndReturnArgs} args - Arguments to create many Inspections.
     * @example
     * // Create many Inspections
     * const inspection = await prisma.inspection.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Inspections and only return the `id`
     * const inspectionWithIdOnly = await prisma.inspection.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends InspectionCreateManyAndReturnArgs>(args?: SelectSubset<T, InspectionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InspectionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Inspection.
     * @param {InspectionDeleteArgs} args - Arguments to delete one Inspection.
     * @example
     * // Delete one Inspection
     * const Inspection = await prisma.inspection.delete({
     *   where: {
     *     // ... filter to delete one Inspection
     *   }
     * })
     * 
     */
    delete<T extends InspectionDeleteArgs>(args: SelectSubset<T, InspectionDeleteArgs<ExtArgs>>): Prisma__InspectionClient<$Result.GetResult<Prisma.$InspectionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Inspection.
     * @param {InspectionUpdateArgs} args - Arguments to update one Inspection.
     * @example
     * // Update one Inspection
     * const inspection = await prisma.inspection.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends InspectionUpdateArgs>(args: SelectSubset<T, InspectionUpdateArgs<ExtArgs>>): Prisma__InspectionClient<$Result.GetResult<Prisma.$InspectionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Inspections.
     * @param {InspectionDeleteManyArgs} args - Arguments to filter Inspections to delete.
     * @example
     * // Delete a few Inspections
     * const { count } = await prisma.inspection.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends InspectionDeleteManyArgs>(args?: SelectSubset<T, InspectionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Inspections.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InspectionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Inspections
     * const inspection = await prisma.inspection.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends InspectionUpdateManyArgs>(args: SelectSubset<T, InspectionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Inspections and returns the data updated in the database.
     * @param {InspectionUpdateManyAndReturnArgs} args - Arguments to update many Inspections.
     * @example
     * // Update many Inspections
     * const inspection = await prisma.inspection.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Inspections and only return the `id`
     * const inspectionWithIdOnly = await prisma.inspection.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends InspectionUpdateManyAndReturnArgs>(args: SelectSubset<T, InspectionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InspectionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Inspection.
     * @param {InspectionUpsertArgs} args - Arguments to update or create a Inspection.
     * @example
     * // Update or create a Inspection
     * const inspection = await prisma.inspection.upsert({
     *   create: {
     *     // ... data to create a Inspection
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Inspection we want to update
     *   }
     * })
     */
    upsert<T extends InspectionUpsertArgs>(args: SelectSubset<T, InspectionUpsertArgs<ExtArgs>>): Prisma__InspectionClient<$Result.GetResult<Prisma.$InspectionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Inspections.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InspectionCountArgs} args - Arguments to filter Inspections to count.
     * @example
     * // Count the number of Inspections
     * const count = await prisma.inspection.count({
     *   where: {
     *     // ... the filter for the Inspections we want to count
     *   }
     * })
    **/
    count<T extends InspectionCountArgs>(
      args?: Subset<T, InspectionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], InspectionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Inspection.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InspectionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends InspectionAggregateArgs>(args: Subset<T, InspectionAggregateArgs>): Prisma.PrismaPromise<GetInspectionAggregateType<T>>

    /**
     * Group by Inspection.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InspectionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends InspectionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: InspectionGroupByArgs['orderBy'] }
        : { orderBy?: InspectionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, InspectionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetInspectionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Inspection model
   */
  readonly fields: InspectionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Inspection.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__InspectionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    project<T extends ProjectDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProjectDefaultArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    milestone<T extends MilestoneDefaultArgs<ExtArgs> = {}>(args?: Subset<T, MilestoneDefaultArgs<ExtArgs>>): Prisma__MilestoneClient<$Result.GetResult<Prisma.$MilestonePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    engineer<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    responses<T extends Inspection$responsesArgs<ExtArgs> = {}>(args?: Subset<T, Inspection$responsesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InspectionResponsePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    reviewedBy<T extends Inspection$reviewedByArgs<ExtArgs> = {}>(args?: Subset<T, Inspection$reviewedByArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Inspection model
   */
  interface InspectionFieldRefs {
    readonly id: FieldRef<"Inspection", 'String'>
    readonly status: FieldRef<"Inspection", 'InspectionStatus'>
    readonly projectId: FieldRef<"Inspection", 'String'>
    readonly milestoneId: FieldRef<"Inspection", 'String'>
    readonly engineerId: FieldRef<"Inspection", 'String'>
    readonly reviewedById: FieldRef<"Inspection", 'String'>
    readonly createdAt: FieldRef<"Inspection", 'DateTime'>
    readonly updatedAt: FieldRef<"Inspection", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Inspection findUnique
   */
  export type InspectionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Inspection
     */
    select?: InspectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Inspection
     */
    omit?: InspectionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InspectionInclude<ExtArgs> | null
    /**
     * Filter, which Inspection to fetch.
     */
    where: InspectionWhereUniqueInput
  }

  /**
   * Inspection findUniqueOrThrow
   */
  export type InspectionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Inspection
     */
    select?: InspectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Inspection
     */
    omit?: InspectionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InspectionInclude<ExtArgs> | null
    /**
     * Filter, which Inspection to fetch.
     */
    where: InspectionWhereUniqueInput
  }

  /**
   * Inspection findFirst
   */
  export type InspectionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Inspection
     */
    select?: InspectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Inspection
     */
    omit?: InspectionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InspectionInclude<ExtArgs> | null
    /**
     * Filter, which Inspection to fetch.
     */
    where?: InspectionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Inspections to fetch.
     */
    orderBy?: InspectionOrderByWithRelationInput | InspectionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Inspections.
     */
    cursor?: InspectionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Inspections from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Inspections.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Inspections.
     */
    distinct?: InspectionScalarFieldEnum | InspectionScalarFieldEnum[]
  }

  /**
   * Inspection findFirstOrThrow
   */
  export type InspectionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Inspection
     */
    select?: InspectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Inspection
     */
    omit?: InspectionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InspectionInclude<ExtArgs> | null
    /**
     * Filter, which Inspection to fetch.
     */
    where?: InspectionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Inspections to fetch.
     */
    orderBy?: InspectionOrderByWithRelationInput | InspectionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Inspections.
     */
    cursor?: InspectionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Inspections from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Inspections.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Inspections.
     */
    distinct?: InspectionScalarFieldEnum | InspectionScalarFieldEnum[]
  }

  /**
   * Inspection findMany
   */
  export type InspectionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Inspection
     */
    select?: InspectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Inspection
     */
    omit?: InspectionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InspectionInclude<ExtArgs> | null
    /**
     * Filter, which Inspections to fetch.
     */
    where?: InspectionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Inspections to fetch.
     */
    orderBy?: InspectionOrderByWithRelationInput | InspectionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Inspections.
     */
    cursor?: InspectionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Inspections from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Inspections.
     */
    skip?: number
    distinct?: InspectionScalarFieldEnum | InspectionScalarFieldEnum[]
  }

  /**
   * Inspection create
   */
  export type InspectionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Inspection
     */
    select?: InspectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Inspection
     */
    omit?: InspectionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InspectionInclude<ExtArgs> | null
    /**
     * The data needed to create a Inspection.
     */
    data: XOR<InspectionCreateInput, InspectionUncheckedCreateInput>
  }

  /**
   * Inspection createMany
   */
  export type InspectionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Inspections.
     */
    data: InspectionCreateManyInput | InspectionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Inspection createManyAndReturn
   */
  export type InspectionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Inspection
     */
    select?: InspectionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Inspection
     */
    omit?: InspectionOmit<ExtArgs> | null
    /**
     * The data used to create many Inspections.
     */
    data: InspectionCreateManyInput | InspectionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InspectionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Inspection update
   */
  export type InspectionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Inspection
     */
    select?: InspectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Inspection
     */
    omit?: InspectionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InspectionInclude<ExtArgs> | null
    /**
     * The data needed to update a Inspection.
     */
    data: XOR<InspectionUpdateInput, InspectionUncheckedUpdateInput>
    /**
     * Choose, which Inspection to update.
     */
    where: InspectionWhereUniqueInput
  }

  /**
   * Inspection updateMany
   */
  export type InspectionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Inspections.
     */
    data: XOR<InspectionUpdateManyMutationInput, InspectionUncheckedUpdateManyInput>
    /**
     * Filter which Inspections to update
     */
    where?: InspectionWhereInput
    /**
     * Limit how many Inspections to update.
     */
    limit?: number
  }

  /**
   * Inspection updateManyAndReturn
   */
  export type InspectionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Inspection
     */
    select?: InspectionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Inspection
     */
    omit?: InspectionOmit<ExtArgs> | null
    /**
     * The data used to update Inspections.
     */
    data: XOR<InspectionUpdateManyMutationInput, InspectionUncheckedUpdateManyInput>
    /**
     * Filter which Inspections to update
     */
    where?: InspectionWhereInput
    /**
     * Limit how many Inspections to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InspectionIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Inspection upsert
   */
  export type InspectionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Inspection
     */
    select?: InspectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Inspection
     */
    omit?: InspectionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InspectionInclude<ExtArgs> | null
    /**
     * The filter to search for the Inspection to update in case it exists.
     */
    where: InspectionWhereUniqueInput
    /**
     * In case the Inspection found by the `where` argument doesn't exist, create a new Inspection with this data.
     */
    create: XOR<InspectionCreateInput, InspectionUncheckedCreateInput>
    /**
     * In case the Inspection was found with the provided `where` argument, update it with this data.
     */
    update: XOR<InspectionUpdateInput, InspectionUncheckedUpdateInput>
  }

  /**
   * Inspection delete
   */
  export type InspectionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Inspection
     */
    select?: InspectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Inspection
     */
    omit?: InspectionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InspectionInclude<ExtArgs> | null
    /**
     * Filter which Inspection to delete.
     */
    where: InspectionWhereUniqueInput
  }

  /**
   * Inspection deleteMany
   */
  export type InspectionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Inspections to delete
     */
    where?: InspectionWhereInput
    /**
     * Limit how many Inspections to delete.
     */
    limit?: number
  }

  /**
   * Inspection.responses
   */
  export type Inspection$responsesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InspectionResponse
     */
    select?: InspectionResponseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InspectionResponse
     */
    omit?: InspectionResponseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InspectionResponseInclude<ExtArgs> | null
    where?: InspectionResponseWhereInput
    orderBy?: InspectionResponseOrderByWithRelationInput | InspectionResponseOrderByWithRelationInput[]
    cursor?: InspectionResponseWhereUniqueInput
    take?: number
    skip?: number
    distinct?: InspectionResponseScalarFieldEnum | InspectionResponseScalarFieldEnum[]
  }

  /**
   * Inspection.reviewedBy
   */
  export type Inspection$reviewedByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * Inspection without action
   */
  export type InspectionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Inspection
     */
    select?: InspectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Inspection
     */
    omit?: InspectionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InspectionInclude<ExtArgs> | null
  }


  /**
   * Model InspectionResponse
   */

  export type AggregateInspectionResponse = {
    _count: InspectionResponseCountAggregateOutputType | null
    _min: InspectionResponseMinAggregateOutputType | null
    _max: InspectionResponseMaxAggregateOutputType | null
  }

  export type InspectionResponseMinAggregateOutputType = {
    id: string | null
    result: $Enums.ChecklistResult | null
    remark: string | null
    inspectionId: string | null
    checklistItemId: string | null
    mediaId: string | null
  }

  export type InspectionResponseMaxAggregateOutputType = {
    id: string | null
    result: $Enums.ChecklistResult | null
    remark: string | null
    inspectionId: string | null
    checklistItemId: string | null
    mediaId: string | null
  }

  export type InspectionResponseCountAggregateOutputType = {
    id: number
    result: number
    remark: number
    inspectionId: number
    checklistItemId: number
    mediaId: number
    _all: number
  }


  export type InspectionResponseMinAggregateInputType = {
    id?: true
    result?: true
    remark?: true
    inspectionId?: true
    checklistItemId?: true
    mediaId?: true
  }

  export type InspectionResponseMaxAggregateInputType = {
    id?: true
    result?: true
    remark?: true
    inspectionId?: true
    checklistItemId?: true
    mediaId?: true
  }

  export type InspectionResponseCountAggregateInputType = {
    id?: true
    result?: true
    remark?: true
    inspectionId?: true
    checklistItemId?: true
    mediaId?: true
    _all?: true
  }

  export type InspectionResponseAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which InspectionResponse to aggregate.
     */
    where?: InspectionResponseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InspectionResponses to fetch.
     */
    orderBy?: InspectionResponseOrderByWithRelationInput | InspectionResponseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: InspectionResponseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InspectionResponses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InspectionResponses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned InspectionResponses
    **/
    _count?: true | InspectionResponseCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: InspectionResponseMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: InspectionResponseMaxAggregateInputType
  }

  export type GetInspectionResponseAggregateType<T extends InspectionResponseAggregateArgs> = {
        [P in keyof T & keyof AggregateInspectionResponse]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateInspectionResponse[P]>
      : GetScalarType<T[P], AggregateInspectionResponse[P]>
  }




  export type InspectionResponseGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InspectionResponseWhereInput
    orderBy?: InspectionResponseOrderByWithAggregationInput | InspectionResponseOrderByWithAggregationInput[]
    by: InspectionResponseScalarFieldEnum[] | InspectionResponseScalarFieldEnum
    having?: InspectionResponseScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: InspectionResponseCountAggregateInputType | true
    _min?: InspectionResponseMinAggregateInputType
    _max?: InspectionResponseMaxAggregateInputType
  }

  export type InspectionResponseGroupByOutputType = {
    id: string
    result: $Enums.ChecklistResult
    remark: string | null
    inspectionId: string
    checklistItemId: string
    mediaId: string | null
    _count: InspectionResponseCountAggregateOutputType | null
    _min: InspectionResponseMinAggregateOutputType | null
    _max: InspectionResponseMaxAggregateOutputType | null
  }

  type GetInspectionResponseGroupByPayload<T extends InspectionResponseGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<InspectionResponseGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof InspectionResponseGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], InspectionResponseGroupByOutputType[P]>
            : GetScalarType<T[P], InspectionResponseGroupByOutputType[P]>
        }
      >
    >


  export type InspectionResponseSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    result?: boolean
    remark?: boolean
    inspectionId?: boolean
    checklistItemId?: boolean
    mediaId?: boolean
    inspection?: boolean | InspectionDefaultArgs<ExtArgs>
    checklistItem?: boolean | ChecklistItemDefaultArgs<ExtArgs>
    media?: boolean | InspectionResponse$mediaArgs<ExtArgs>
  }, ExtArgs["result"]["inspectionResponse"]>

  export type InspectionResponseSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    result?: boolean
    remark?: boolean
    inspectionId?: boolean
    checklistItemId?: boolean
    mediaId?: boolean
    inspection?: boolean | InspectionDefaultArgs<ExtArgs>
    checklistItem?: boolean | ChecklistItemDefaultArgs<ExtArgs>
    media?: boolean | InspectionResponse$mediaArgs<ExtArgs>
  }, ExtArgs["result"]["inspectionResponse"]>

  export type InspectionResponseSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    result?: boolean
    remark?: boolean
    inspectionId?: boolean
    checklistItemId?: boolean
    mediaId?: boolean
    inspection?: boolean | InspectionDefaultArgs<ExtArgs>
    checklistItem?: boolean | ChecklistItemDefaultArgs<ExtArgs>
    media?: boolean | InspectionResponse$mediaArgs<ExtArgs>
  }, ExtArgs["result"]["inspectionResponse"]>

  export type InspectionResponseSelectScalar = {
    id?: boolean
    result?: boolean
    remark?: boolean
    inspectionId?: boolean
    checklistItemId?: boolean
    mediaId?: boolean
  }

  export type InspectionResponseOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "result" | "remark" | "inspectionId" | "checklistItemId" | "mediaId", ExtArgs["result"]["inspectionResponse"]>
  export type InspectionResponseInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    inspection?: boolean | InspectionDefaultArgs<ExtArgs>
    checklistItem?: boolean | ChecklistItemDefaultArgs<ExtArgs>
    media?: boolean | InspectionResponse$mediaArgs<ExtArgs>
  }
  export type InspectionResponseIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    inspection?: boolean | InspectionDefaultArgs<ExtArgs>
    checklistItem?: boolean | ChecklistItemDefaultArgs<ExtArgs>
    media?: boolean | InspectionResponse$mediaArgs<ExtArgs>
  }
  export type InspectionResponseIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    inspection?: boolean | InspectionDefaultArgs<ExtArgs>
    checklistItem?: boolean | ChecklistItemDefaultArgs<ExtArgs>
    media?: boolean | InspectionResponse$mediaArgs<ExtArgs>
  }

  export type $InspectionResponsePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "InspectionResponse"
    objects: {
      inspection: Prisma.$InspectionPayload<ExtArgs>
      checklistItem: Prisma.$ChecklistItemPayload<ExtArgs>
      media: Prisma.$MediaPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      result: $Enums.ChecklistResult
      remark: string | null
      inspectionId: string
      checklistItemId: string
      mediaId: string | null
    }, ExtArgs["result"]["inspectionResponse"]>
    composites: {}
  }

  type InspectionResponseGetPayload<S extends boolean | null | undefined | InspectionResponseDefaultArgs> = $Result.GetResult<Prisma.$InspectionResponsePayload, S>

  type InspectionResponseCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<InspectionResponseFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: InspectionResponseCountAggregateInputType | true
    }

  export interface InspectionResponseDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['InspectionResponse'], meta: { name: 'InspectionResponse' } }
    /**
     * Find zero or one InspectionResponse that matches the filter.
     * @param {InspectionResponseFindUniqueArgs} args - Arguments to find a InspectionResponse
     * @example
     * // Get one InspectionResponse
     * const inspectionResponse = await prisma.inspectionResponse.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends InspectionResponseFindUniqueArgs>(args: SelectSubset<T, InspectionResponseFindUniqueArgs<ExtArgs>>): Prisma__InspectionResponseClient<$Result.GetResult<Prisma.$InspectionResponsePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one InspectionResponse that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {InspectionResponseFindUniqueOrThrowArgs} args - Arguments to find a InspectionResponse
     * @example
     * // Get one InspectionResponse
     * const inspectionResponse = await prisma.inspectionResponse.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends InspectionResponseFindUniqueOrThrowArgs>(args: SelectSubset<T, InspectionResponseFindUniqueOrThrowArgs<ExtArgs>>): Prisma__InspectionResponseClient<$Result.GetResult<Prisma.$InspectionResponsePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first InspectionResponse that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InspectionResponseFindFirstArgs} args - Arguments to find a InspectionResponse
     * @example
     * // Get one InspectionResponse
     * const inspectionResponse = await prisma.inspectionResponse.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends InspectionResponseFindFirstArgs>(args?: SelectSubset<T, InspectionResponseFindFirstArgs<ExtArgs>>): Prisma__InspectionResponseClient<$Result.GetResult<Prisma.$InspectionResponsePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first InspectionResponse that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InspectionResponseFindFirstOrThrowArgs} args - Arguments to find a InspectionResponse
     * @example
     * // Get one InspectionResponse
     * const inspectionResponse = await prisma.inspectionResponse.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends InspectionResponseFindFirstOrThrowArgs>(args?: SelectSubset<T, InspectionResponseFindFirstOrThrowArgs<ExtArgs>>): Prisma__InspectionResponseClient<$Result.GetResult<Prisma.$InspectionResponsePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more InspectionResponses that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InspectionResponseFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all InspectionResponses
     * const inspectionResponses = await prisma.inspectionResponse.findMany()
     * 
     * // Get first 10 InspectionResponses
     * const inspectionResponses = await prisma.inspectionResponse.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const inspectionResponseWithIdOnly = await prisma.inspectionResponse.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends InspectionResponseFindManyArgs>(args?: SelectSubset<T, InspectionResponseFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InspectionResponsePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a InspectionResponse.
     * @param {InspectionResponseCreateArgs} args - Arguments to create a InspectionResponse.
     * @example
     * // Create one InspectionResponse
     * const InspectionResponse = await prisma.inspectionResponse.create({
     *   data: {
     *     // ... data to create a InspectionResponse
     *   }
     * })
     * 
     */
    create<T extends InspectionResponseCreateArgs>(args: SelectSubset<T, InspectionResponseCreateArgs<ExtArgs>>): Prisma__InspectionResponseClient<$Result.GetResult<Prisma.$InspectionResponsePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many InspectionResponses.
     * @param {InspectionResponseCreateManyArgs} args - Arguments to create many InspectionResponses.
     * @example
     * // Create many InspectionResponses
     * const inspectionResponse = await prisma.inspectionResponse.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends InspectionResponseCreateManyArgs>(args?: SelectSubset<T, InspectionResponseCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many InspectionResponses and returns the data saved in the database.
     * @param {InspectionResponseCreateManyAndReturnArgs} args - Arguments to create many InspectionResponses.
     * @example
     * // Create many InspectionResponses
     * const inspectionResponse = await prisma.inspectionResponse.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many InspectionResponses and only return the `id`
     * const inspectionResponseWithIdOnly = await prisma.inspectionResponse.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends InspectionResponseCreateManyAndReturnArgs>(args?: SelectSubset<T, InspectionResponseCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InspectionResponsePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a InspectionResponse.
     * @param {InspectionResponseDeleteArgs} args - Arguments to delete one InspectionResponse.
     * @example
     * // Delete one InspectionResponse
     * const InspectionResponse = await prisma.inspectionResponse.delete({
     *   where: {
     *     // ... filter to delete one InspectionResponse
     *   }
     * })
     * 
     */
    delete<T extends InspectionResponseDeleteArgs>(args: SelectSubset<T, InspectionResponseDeleteArgs<ExtArgs>>): Prisma__InspectionResponseClient<$Result.GetResult<Prisma.$InspectionResponsePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one InspectionResponse.
     * @param {InspectionResponseUpdateArgs} args - Arguments to update one InspectionResponse.
     * @example
     * // Update one InspectionResponse
     * const inspectionResponse = await prisma.inspectionResponse.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends InspectionResponseUpdateArgs>(args: SelectSubset<T, InspectionResponseUpdateArgs<ExtArgs>>): Prisma__InspectionResponseClient<$Result.GetResult<Prisma.$InspectionResponsePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more InspectionResponses.
     * @param {InspectionResponseDeleteManyArgs} args - Arguments to filter InspectionResponses to delete.
     * @example
     * // Delete a few InspectionResponses
     * const { count } = await prisma.inspectionResponse.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends InspectionResponseDeleteManyArgs>(args?: SelectSubset<T, InspectionResponseDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more InspectionResponses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InspectionResponseUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many InspectionResponses
     * const inspectionResponse = await prisma.inspectionResponse.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends InspectionResponseUpdateManyArgs>(args: SelectSubset<T, InspectionResponseUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more InspectionResponses and returns the data updated in the database.
     * @param {InspectionResponseUpdateManyAndReturnArgs} args - Arguments to update many InspectionResponses.
     * @example
     * // Update many InspectionResponses
     * const inspectionResponse = await prisma.inspectionResponse.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more InspectionResponses and only return the `id`
     * const inspectionResponseWithIdOnly = await prisma.inspectionResponse.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends InspectionResponseUpdateManyAndReturnArgs>(args: SelectSubset<T, InspectionResponseUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InspectionResponsePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one InspectionResponse.
     * @param {InspectionResponseUpsertArgs} args - Arguments to update or create a InspectionResponse.
     * @example
     * // Update or create a InspectionResponse
     * const inspectionResponse = await prisma.inspectionResponse.upsert({
     *   create: {
     *     // ... data to create a InspectionResponse
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the InspectionResponse we want to update
     *   }
     * })
     */
    upsert<T extends InspectionResponseUpsertArgs>(args: SelectSubset<T, InspectionResponseUpsertArgs<ExtArgs>>): Prisma__InspectionResponseClient<$Result.GetResult<Prisma.$InspectionResponsePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of InspectionResponses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InspectionResponseCountArgs} args - Arguments to filter InspectionResponses to count.
     * @example
     * // Count the number of InspectionResponses
     * const count = await prisma.inspectionResponse.count({
     *   where: {
     *     // ... the filter for the InspectionResponses we want to count
     *   }
     * })
    **/
    count<T extends InspectionResponseCountArgs>(
      args?: Subset<T, InspectionResponseCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], InspectionResponseCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a InspectionResponse.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InspectionResponseAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends InspectionResponseAggregateArgs>(args: Subset<T, InspectionResponseAggregateArgs>): Prisma.PrismaPromise<GetInspectionResponseAggregateType<T>>

    /**
     * Group by InspectionResponse.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InspectionResponseGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends InspectionResponseGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: InspectionResponseGroupByArgs['orderBy'] }
        : { orderBy?: InspectionResponseGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, InspectionResponseGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetInspectionResponseGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the InspectionResponse model
   */
  readonly fields: InspectionResponseFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for InspectionResponse.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__InspectionResponseClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    inspection<T extends InspectionDefaultArgs<ExtArgs> = {}>(args?: Subset<T, InspectionDefaultArgs<ExtArgs>>): Prisma__InspectionClient<$Result.GetResult<Prisma.$InspectionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    checklistItem<T extends ChecklistItemDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ChecklistItemDefaultArgs<ExtArgs>>): Prisma__ChecklistItemClient<$Result.GetResult<Prisma.$ChecklistItemPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    media<T extends InspectionResponse$mediaArgs<ExtArgs> = {}>(args?: Subset<T, InspectionResponse$mediaArgs<ExtArgs>>): Prisma__MediaClient<$Result.GetResult<Prisma.$MediaPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the InspectionResponse model
   */
  interface InspectionResponseFieldRefs {
    readonly id: FieldRef<"InspectionResponse", 'String'>
    readonly result: FieldRef<"InspectionResponse", 'ChecklistResult'>
    readonly remark: FieldRef<"InspectionResponse", 'String'>
    readonly inspectionId: FieldRef<"InspectionResponse", 'String'>
    readonly checklistItemId: FieldRef<"InspectionResponse", 'String'>
    readonly mediaId: FieldRef<"InspectionResponse", 'String'>
  }
    

  // Custom InputTypes
  /**
   * InspectionResponse findUnique
   */
  export type InspectionResponseFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InspectionResponse
     */
    select?: InspectionResponseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InspectionResponse
     */
    omit?: InspectionResponseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InspectionResponseInclude<ExtArgs> | null
    /**
     * Filter, which InspectionResponse to fetch.
     */
    where: InspectionResponseWhereUniqueInput
  }

  /**
   * InspectionResponse findUniqueOrThrow
   */
  export type InspectionResponseFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InspectionResponse
     */
    select?: InspectionResponseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InspectionResponse
     */
    omit?: InspectionResponseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InspectionResponseInclude<ExtArgs> | null
    /**
     * Filter, which InspectionResponse to fetch.
     */
    where: InspectionResponseWhereUniqueInput
  }

  /**
   * InspectionResponse findFirst
   */
  export type InspectionResponseFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InspectionResponse
     */
    select?: InspectionResponseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InspectionResponse
     */
    omit?: InspectionResponseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InspectionResponseInclude<ExtArgs> | null
    /**
     * Filter, which InspectionResponse to fetch.
     */
    where?: InspectionResponseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InspectionResponses to fetch.
     */
    orderBy?: InspectionResponseOrderByWithRelationInput | InspectionResponseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for InspectionResponses.
     */
    cursor?: InspectionResponseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InspectionResponses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InspectionResponses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of InspectionResponses.
     */
    distinct?: InspectionResponseScalarFieldEnum | InspectionResponseScalarFieldEnum[]
  }

  /**
   * InspectionResponse findFirstOrThrow
   */
  export type InspectionResponseFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InspectionResponse
     */
    select?: InspectionResponseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InspectionResponse
     */
    omit?: InspectionResponseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InspectionResponseInclude<ExtArgs> | null
    /**
     * Filter, which InspectionResponse to fetch.
     */
    where?: InspectionResponseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InspectionResponses to fetch.
     */
    orderBy?: InspectionResponseOrderByWithRelationInput | InspectionResponseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for InspectionResponses.
     */
    cursor?: InspectionResponseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InspectionResponses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InspectionResponses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of InspectionResponses.
     */
    distinct?: InspectionResponseScalarFieldEnum | InspectionResponseScalarFieldEnum[]
  }

  /**
   * InspectionResponse findMany
   */
  export type InspectionResponseFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InspectionResponse
     */
    select?: InspectionResponseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InspectionResponse
     */
    omit?: InspectionResponseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InspectionResponseInclude<ExtArgs> | null
    /**
     * Filter, which InspectionResponses to fetch.
     */
    where?: InspectionResponseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InspectionResponses to fetch.
     */
    orderBy?: InspectionResponseOrderByWithRelationInput | InspectionResponseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing InspectionResponses.
     */
    cursor?: InspectionResponseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InspectionResponses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InspectionResponses.
     */
    skip?: number
    distinct?: InspectionResponseScalarFieldEnum | InspectionResponseScalarFieldEnum[]
  }

  /**
   * InspectionResponse create
   */
  export type InspectionResponseCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InspectionResponse
     */
    select?: InspectionResponseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InspectionResponse
     */
    omit?: InspectionResponseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InspectionResponseInclude<ExtArgs> | null
    /**
     * The data needed to create a InspectionResponse.
     */
    data: XOR<InspectionResponseCreateInput, InspectionResponseUncheckedCreateInput>
  }

  /**
   * InspectionResponse createMany
   */
  export type InspectionResponseCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many InspectionResponses.
     */
    data: InspectionResponseCreateManyInput | InspectionResponseCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * InspectionResponse createManyAndReturn
   */
  export type InspectionResponseCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InspectionResponse
     */
    select?: InspectionResponseSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the InspectionResponse
     */
    omit?: InspectionResponseOmit<ExtArgs> | null
    /**
     * The data used to create many InspectionResponses.
     */
    data: InspectionResponseCreateManyInput | InspectionResponseCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InspectionResponseIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * InspectionResponse update
   */
  export type InspectionResponseUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InspectionResponse
     */
    select?: InspectionResponseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InspectionResponse
     */
    omit?: InspectionResponseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InspectionResponseInclude<ExtArgs> | null
    /**
     * The data needed to update a InspectionResponse.
     */
    data: XOR<InspectionResponseUpdateInput, InspectionResponseUncheckedUpdateInput>
    /**
     * Choose, which InspectionResponse to update.
     */
    where: InspectionResponseWhereUniqueInput
  }

  /**
   * InspectionResponse updateMany
   */
  export type InspectionResponseUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update InspectionResponses.
     */
    data: XOR<InspectionResponseUpdateManyMutationInput, InspectionResponseUncheckedUpdateManyInput>
    /**
     * Filter which InspectionResponses to update
     */
    where?: InspectionResponseWhereInput
    /**
     * Limit how many InspectionResponses to update.
     */
    limit?: number
  }

  /**
   * InspectionResponse updateManyAndReturn
   */
  export type InspectionResponseUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InspectionResponse
     */
    select?: InspectionResponseSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the InspectionResponse
     */
    omit?: InspectionResponseOmit<ExtArgs> | null
    /**
     * The data used to update InspectionResponses.
     */
    data: XOR<InspectionResponseUpdateManyMutationInput, InspectionResponseUncheckedUpdateManyInput>
    /**
     * Filter which InspectionResponses to update
     */
    where?: InspectionResponseWhereInput
    /**
     * Limit how many InspectionResponses to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InspectionResponseIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * InspectionResponse upsert
   */
  export type InspectionResponseUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InspectionResponse
     */
    select?: InspectionResponseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InspectionResponse
     */
    omit?: InspectionResponseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InspectionResponseInclude<ExtArgs> | null
    /**
     * The filter to search for the InspectionResponse to update in case it exists.
     */
    where: InspectionResponseWhereUniqueInput
    /**
     * In case the InspectionResponse found by the `where` argument doesn't exist, create a new InspectionResponse with this data.
     */
    create: XOR<InspectionResponseCreateInput, InspectionResponseUncheckedCreateInput>
    /**
     * In case the InspectionResponse was found with the provided `where` argument, update it with this data.
     */
    update: XOR<InspectionResponseUpdateInput, InspectionResponseUncheckedUpdateInput>
  }

  /**
   * InspectionResponse delete
   */
  export type InspectionResponseDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InspectionResponse
     */
    select?: InspectionResponseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InspectionResponse
     */
    omit?: InspectionResponseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InspectionResponseInclude<ExtArgs> | null
    /**
     * Filter which InspectionResponse to delete.
     */
    where: InspectionResponseWhereUniqueInput
  }

  /**
   * InspectionResponse deleteMany
   */
  export type InspectionResponseDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which InspectionResponses to delete
     */
    where?: InspectionResponseWhereInput
    /**
     * Limit how many InspectionResponses to delete.
     */
    limit?: number
  }

  /**
   * InspectionResponse.media
   */
  export type InspectionResponse$mediaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Media
     */
    select?: MediaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Media
     */
    omit?: MediaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MediaInclude<ExtArgs> | null
    where?: MediaWhereInput
  }

  /**
   * InspectionResponse without action
   */
  export type InspectionResponseDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InspectionResponse
     */
    select?: InspectionResponseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InspectionResponse
     */
    omit?: InspectionResponseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InspectionResponseInclude<ExtArgs> | null
  }


  /**
   * Model Query
   */

  export type AggregateQuery = {
    _count: QueryCountAggregateOutputType | null
    _min: QueryMinAggregateOutputType | null
    _max: QueryMaxAggregateOutputType | null
  }

  export type QueryMinAggregateOutputType = {
    id: string | null
    projectId: string | null
    authorId: string | null
    title: string | null
    description: string | null
    status: $Enums.QueryStatus | null
    priority: $Enums.QueryPriority | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type QueryMaxAggregateOutputType = {
    id: string | null
    projectId: string | null
    authorId: string | null
    title: string | null
    description: string | null
    status: $Enums.QueryStatus | null
    priority: $Enums.QueryPriority | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type QueryCountAggregateOutputType = {
    id: number
    projectId: number
    authorId: number
    title: number
    description: number
    status: number
    priority: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type QueryMinAggregateInputType = {
    id?: true
    projectId?: true
    authorId?: true
    title?: true
    description?: true
    status?: true
    priority?: true
    createdAt?: true
    updatedAt?: true
  }

  export type QueryMaxAggregateInputType = {
    id?: true
    projectId?: true
    authorId?: true
    title?: true
    description?: true
    status?: true
    priority?: true
    createdAt?: true
    updatedAt?: true
  }

  export type QueryCountAggregateInputType = {
    id?: true
    projectId?: true
    authorId?: true
    title?: true
    description?: true
    status?: true
    priority?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type QueryAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Query to aggregate.
     */
    where?: QueryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Queries to fetch.
     */
    orderBy?: QueryOrderByWithRelationInput | QueryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: QueryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Queries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Queries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Queries
    **/
    _count?: true | QueryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: QueryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: QueryMaxAggregateInputType
  }

  export type GetQueryAggregateType<T extends QueryAggregateArgs> = {
        [P in keyof T & keyof AggregateQuery]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateQuery[P]>
      : GetScalarType<T[P], AggregateQuery[P]>
  }




  export type QueryGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: QueryWhereInput
    orderBy?: QueryOrderByWithAggregationInput | QueryOrderByWithAggregationInput[]
    by: QueryScalarFieldEnum[] | QueryScalarFieldEnum
    having?: QueryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: QueryCountAggregateInputType | true
    _min?: QueryMinAggregateInputType
    _max?: QueryMaxAggregateInputType
  }

  export type QueryGroupByOutputType = {
    id: string
    projectId: string
    authorId: string
    title: string
    description: string
    status: $Enums.QueryStatus
    priority: $Enums.QueryPriority
    createdAt: Date
    updatedAt: Date
    _count: QueryCountAggregateOutputType | null
    _min: QueryMinAggregateOutputType | null
    _max: QueryMaxAggregateOutputType | null
  }

  type GetQueryGroupByPayload<T extends QueryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<QueryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof QueryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], QueryGroupByOutputType[P]>
            : GetScalarType<T[P], QueryGroupByOutputType[P]>
        }
      >
    >


  export type QuerySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    projectId?: boolean
    authorId?: boolean
    title?: boolean
    description?: boolean
    status?: boolean
    priority?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    project?: boolean | ProjectDefaultArgs<ExtArgs>
    author?: boolean | UserDefaultArgs<ExtArgs>
    attachments?: boolean | Query$attachmentsArgs<ExtArgs>
    responses?: boolean | Query$responsesArgs<ExtArgs>
    _count?: boolean | QueryCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["query"]>

  export type QuerySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    projectId?: boolean
    authorId?: boolean
    title?: boolean
    description?: boolean
    status?: boolean
    priority?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    project?: boolean | ProjectDefaultArgs<ExtArgs>
    author?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["query"]>

  export type QuerySelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    projectId?: boolean
    authorId?: boolean
    title?: boolean
    description?: boolean
    status?: boolean
    priority?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    project?: boolean | ProjectDefaultArgs<ExtArgs>
    author?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["query"]>

  export type QuerySelectScalar = {
    id?: boolean
    projectId?: boolean
    authorId?: boolean
    title?: boolean
    description?: boolean
    status?: boolean
    priority?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type QueryOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "projectId" | "authorId" | "title" | "description" | "status" | "priority" | "createdAt" | "updatedAt", ExtArgs["result"]["query"]>
  export type QueryInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    project?: boolean | ProjectDefaultArgs<ExtArgs>
    author?: boolean | UserDefaultArgs<ExtArgs>
    attachments?: boolean | Query$attachmentsArgs<ExtArgs>
    responses?: boolean | Query$responsesArgs<ExtArgs>
    _count?: boolean | QueryCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type QueryIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    project?: boolean | ProjectDefaultArgs<ExtArgs>
    author?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type QueryIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    project?: boolean | ProjectDefaultArgs<ExtArgs>
    author?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $QueryPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Query"
    objects: {
      project: Prisma.$ProjectPayload<ExtArgs>
      author: Prisma.$UserPayload<ExtArgs>
      attachments: Prisma.$MediaPayload<ExtArgs>[]
      responses: Prisma.$QueryResponsePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      projectId: string
      authorId: string
      title: string
      description: string
      status: $Enums.QueryStatus
      priority: $Enums.QueryPriority
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["query"]>
    composites: {}
  }

  type QueryGetPayload<S extends boolean | null | undefined | QueryDefaultArgs> = $Result.GetResult<Prisma.$QueryPayload, S>

  type QueryCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<QueryFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: QueryCountAggregateInputType | true
    }

  export interface QueryDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Query'], meta: { name: 'Query' } }
    /**
     * Find zero or one Query that matches the filter.
     * @param {QueryFindUniqueArgs} args - Arguments to find a Query
     * @example
     * // Get one Query
     * const query = await prisma.query.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends QueryFindUniqueArgs>(args: SelectSubset<T, QueryFindUniqueArgs<ExtArgs>>): Prisma__QueryClient<$Result.GetResult<Prisma.$QueryPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Query that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {QueryFindUniqueOrThrowArgs} args - Arguments to find a Query
     * @example
     * // Get one Query
     * const query = await prisma.query.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends QueryFindUniqueOrThrowArgs>(args: SelectSubset<T, QueryFindUniqueOrThrowArgs<ExtArgs>>): Prisma__QueryClient<$Result.GetResult<Prisma.$QueryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Query that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QueryFindFirstArgs} args - Arguments to find a Query
     * @example
     * // Get one Query
     * const query = await prisma.query.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends QueryFindFirstArgs>(args?: SelectSubset<T, QueryFindFirstArgs<ExtArgs>>): Prisma__QueryClient<$Result.GetResult<Prisma.$QueryPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Query that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QueryFindFirstOrThrowArgs} args - Arguments to find a Query
     * @example
     * // Get one Query
     * const query = await prisma.query.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends QueryFindFirstOrThrowArgs>(args?: SelectSubset<T, QueryFindFirstOrThrowArgs<ExtArgs>>): Prisma__QueryClient<$Result.GetResult<Prisma.$QueryPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Queries that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QueryFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Queries
     * const queries = await prisma.query.findMany()
     * 
     * // Get first 10 Queries
     * const queries = await prisma.query.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const queryWithIdOnly = await prisma.query.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends QueryFindManyArgs>(args?: SelectSubset<T, QueryFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QueryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Query.
     * @param {QueryCreateArgs} args - Arguments to create a Query.
     * @example
     * // Create one Query
     * const Query = await prisma.query.create({
     *   data: {
     *     // ... data to create a Query
     *   }
     * })
     * 
     */
    create<T extends QueryCreateArgs>(args: SelectSubset<T, QueryCreateArgs<ExtArgs>>): Prisma__QueryClient<$Result.GetResult<Prisma.$QueryPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Queries.
     * @param {QueryCreateManyArgs} args - Arguments to create many Queries.
     * @example
     * // Create many Queries
     * const query = await prisma.query.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends QueryCreateManyArgs>(args?: SelectSubset<T, QueryCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Queries and returns the data saved in the database.
     * @param {QueryCreateManyAndReturnArgs} args - Arguments to create many Queries.
     * @example
     * // Create many Queries
     * const query = await prisma.query.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Queries and only return the `id`
     * const queryWithIdOnly = await prisma.query.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends QueryCreateManyAndReturnArgs>(args?: SelectSubset<T, QueryCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QueryPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Query.
     * @param {QueryDeleteArgs} args - Arguments to delete one Query.
     * @example
     * // Delete one Query
     * const Query = await prisma.query.delete({
     *   where: {
     *     // ... filter to delete one Query
     *   }
     * })
     * 
     */
    delete<T extends QueryDeleteArgs>(args: SelectSubset<T, QueryDeleteArgs<ExtArgs>>): Prisma__QueryClient<$Result.GetResult<Prisma.$QueryPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Query.
     * @param {QueryUpdateArgs} args - Arguments to update one Query.
     * @example
     * // Update one Query
     * const query = await prisma.query.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends QueryUpdateArgs>(args: SelectSubset<T, QueryUpdateArgs<ExtArgs>>): Prisma__QueryClient<$Result.GetResult<Prisma.$QueryPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Queries.
     * @param {QueryDeleteManyArgs} args - Arguments to filter Queries to delete.
     * @example
     * // Delete a few Queries
     * const { count } = await prisma.query.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends QueryDeleteManyArgs>(args?: SelectSubset<T, QueryDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Queries.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QueryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Queries
     * const query = await prisma.query.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends QueryUpdateManyArgs>(args: SelectSubset<T, QueryUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Queries and returns the data updated in the database.
     * @param {QueryUpdateManyAndReturnArgs} args - Arguments to update many Queries.
     * @example
     * // Update many Queries
     * const query = await prisma.query.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Queries and only return the `id`
     * const queryWithIdOnly = await prisma.query.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends QueryUpdateManyAndReturnArgs>(args: SelectSubset<T, QueryUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QueryPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Query.
     * @param {QueryUpsertArgs} args - Arguments to update or create a Query.
     * @example
     * // Update or create a Query
     * const query = await prisma.query.upsert({
     *   create: {
     *     // ... data to create a Query
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Query we want to update
     *   }
     * })
     */
    upsert<T extends QueryUpsertArgs>(args: SelectSubset<T, QueryUpsertArgs<ExtArgs>>): Prisma__QueryClient<$Result.GetResult<Prisma.$QueryPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Queries.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QueryCountArgs} args - Arguments to filter Queries to count.
     * @example
     * // Count the number of Queries
     * const count = await prisma.query.count({
     *   where: {
     *     // ... the filter for the Queries we want to count
     *   }
     * })
    **/
    count<T extends QueryCountArgs>(
      args?: Subset<T, QueryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], QueryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Query.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QueryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends QueryAggregateArgs>(args: Subset<T, QueryAggregateArgs>): Prisma.PrismaPromise<GetQueryAggregateType<T>>

    /**
     * Group by Query.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QueryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends QueryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: QueryGroupByArgs['orderBy'] }
        : { orderBy?: QueryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, QueryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetQueryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Query model
   */
  readonly fields: QueryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Query.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__QueryClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    project<T extends ProjectDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProjectDefaultArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    author<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    attachments<T extends Query$attachmentsArgs<ExtArgs> = {}>(args?: Subset<T, Query$attachmentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MediaPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    responses<T extends Query$responsesArgs<ExtArgs> = {}>(args?: Subset<T, Query$responsesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QueryResponsePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Query model
   */
  interface QueryFieldRefs {
    readonly id: FieldRef<"Query", 'String'>
    readonly projectId: FieldRef<"Query", 'String'>
    readonly authorId: FieldRef<"Query", 'String'>
    readonly title: FieldRef<"Query", 'String'>
    readonly description: FieldRef<"Query", 'String'>
    readonly status: FieldRef<"Query", 'QueryStatus'>
    readonly priority: FieldRef<"Query", 'QueryPriority'>
    readonly createdAt: FieldRef<"Query", 'DateTime'>
    readonly updatedAt: FieldRef<"Query", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Query findUnique
   */
  export type QueryFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Query
     */
    select?: QuerySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Query
     */
    omit?: QueryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QueryInclude<ExtArgs> | null
    /**
     * Filter, which Query to fetch.
     */
    where: QueryWhereUniqueInput
  }

  /**
   * Query findUniqueOrThrow
   */
  export type QueryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Query
     */
    select?: QuerySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Query
     */
    omit?: QueryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QueryInclude<ExtArgs> | null
    /**
     * Filter, which Query to fetch.
     */
    where: QueryWhereUniqueInput
  }

  /**
   * Query findFirst
   */
  export type QueryFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Query
     */
    select?: QuerySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Query
     */
    omit?: QueryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QueryInclude<ExtArgs> | null
    /**
     * Filter, which Query to fetch.
     */
    where?: QueryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Queries to fetch.
     */
    orderBy?: QueryOrderByWithRelationInput | QueryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Queries.
     */
    cursor?: QueryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Queries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Queries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Queries.
     */
    distinct?: QueryScalarFieldEnum | QueryScalarFieldEnum[]
  }

  /**
   * Query findFirstOrThrow
   */
  export type QueryFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Query
     */
    select?: QuerySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Query
     */
    omit?: QueryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QueryInclude<ExtArgs> | null
    /**
     * Filter, which Query to fetch.
     */
    where?: QueryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Queries to fetch.
     */
    orderBy?: QueryOrderByWithRelationInput | QueryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Queries.
     */
    cursor?: QueryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Queries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Queries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Queries.
     */
    distinct?: QueryScalarFieldEnum | QueryScalarFieldEnum[]
  }

  /**
   * Query findMany
   */
  export type QueryFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Query
     */
    select?: QuerySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Query
     */
    omit?: QueryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QueryInclude<ExtArgs> | null
    /**
     * Filter, which Queries to fetch.
     */
    where?: QueryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Queries to fetch.
     */
    orderBy?: QueryOrderByWithRelationInput | QueryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Queries.
     */
    cursor?: QueryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Queries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Queries.
     */
    skip?: number
    distinct?: QueryScalarFieldEnum | QueryScalarFieldEnum[]
  }

  /**
   * Query create
   */
  export type QueryCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Query
     */
    select?: QuerySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Query
     */
    omit?: QueryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QueryInclude<ExtArgs> | null
    /**
     * The data needed to create a Query.
     */
    data: XOR<QueryCreateInput, QueryUncheckedCreateInput>
  }

  /**
   * Query createMany
   */
  export type QueryCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Queries.
     */
    data: QueryCreateManyInput | QueryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Query createManyAndReturn
   */
  export type QueryCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Query
     */
    select?: QuerySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Query
     */
    omit?: QueryOmit<ExtArgs> | null
    /**
     * The data used to create many Queries.
     */
    data: QueryCreateManyInput | QueryCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QueryIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Query update
   */
  export type QueryUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Query
     */
    select?: QuerySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Query
     */
    omit?: QueryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QueryInclude<ExtArgs> | null
    /**
     * The data needed to update a Query.
     */
    data: XOR<QueryUpdateInput, QueryUncheckedUpdateInput>
    /**
     * Choose, which Query to update.
     */
    where: QueryWhereUniqueInput
  }

  /**
   * Query updateMany
   */
  export type QueryUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Queries.
     */
    data: XOR<QueryUpdateManyMutationInput, QueryUncheckedUpdateManyInput>
    /**
     * Filter which Queries to update
     */
    where?: QueryWhereInput
    /**
     * Limit how many Queries to update.
     */
    limit?: number
  }

  /**
   * Query updateManyAndReturn
   */
  export type QueryUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Query
     */
    select?: QuerySelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Query
     */
    omit?: QueryOmit<ExtArgs> | null
    /**
     * The data used to update Queries.
     */
    data: XOR<QueryUpdateManyMutationInput, QueryUncheckedUpdateManyInput>
    /**
     * Filter which Queries to update
     */
    where?: QueryWhereInput
    /**
     * Limit how many Queries to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QueryIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Query upsert
   */
  export type QueryUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Query
     */
    select?: QuerySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Query
     */
    omit?: QueryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QueryInclude<ExtArgs> | null
    /**
     * The filter to search for the Query to update in case it exists.
     */
    where: QueryWhereUniqueInput
    /**
     * In case the Query found by the `where` argument doesn't exist, create a new Query with this data.
     */
    create: XOR<QueryCreateInput, QueryUncheckedCreateInput>
    /**
     * In case the Query was found with the provided `where` argument, update it with this data.
     */
    update: XOR<QueryUpdateInput, QueryUncheckedUpdateInput>
  }

  /**
   * Query delete
   */
  export type QueryDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Query
     */
    select?: QuerySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Query
     */
    omit?: QueryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QueryInclude<ExtArgs> | null
    /**
     * Filter which Query to delete.
     */
    where: QueryWhereUniqueInput
  }

  /**
   * Query deleteMany
   */
  export type QueryDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Queries to delete
     */
    where?: QueryWhereInput
    /**
     * Limit how many Queries to delete.
     */
    limit?: number
  }

  /**
   * Query.attachments
   */
  export type Query$attachmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Media
     */
    select?: MediaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Media
     */
    omit?: MediaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MediaInclude<ExtArgs> | null
    where?: MediaWhereInput
    orderBy?: MediaOrderByWithRelationInput | MediaOrderByWithRelationInput[]
    cursor?: MediaWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MediaScalarFieldEnum | MediaScalarFieldEnum[]
  }

  /**
   * Query.responses
   */
  export type Query$responsesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QueryResponse
     */
    select?: QueryResponseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QueryResponse
     */
    omit?: QueryResponseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QueryResponseInclude<ExtArgs> | null
    where?: QueryResponseWhereInput
    orderBy?: QueryResponseOrderByWithRelationInput | QueryResponseOrderByWithRelationInput[]
    cursor?: QueryResponseWhereUniqueInput
    take?: number
    skip?: number
    distinct?: QueryResponseScalarFieldEnum | QueryResponseScalarFieldEnum[]
  }

  /**
   * Query without action
   */
  export type QueryDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Query
     */
    select?: QuerySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Query
     */
    omit?: QueryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QueryInclude<ExtArgs> | null
  }


  /**
   * Model QueryResponse
   */

  export type AggregateQueryResponse = {
    _count: QueryResponseCountAggregateOutputType | null
    _min: QueryResponseMinAggregateOutputType | null
    _max: QueryResponseMaxAggregateOutputType | null
  }

  export type QueryResponseMinAggregateOutputType = {
    id: string | null
    queryId: string | null
    authorId: string | null
    message: string | null
    createdAt: Date | null
  }

  export type QueryResponseMaxAggregateOutputType = {
    id: string | null
    queryId: string | null
    authorId: string | null
    message: string | null
    createdAt: Date | null
  }

  export type QueryResponseCountAggregateOutputType = {
    id: number
    queryId: number
    authorId: number
    message: number
    createdAt: number
    _all: number
  }


  export type QueryResponseMinAggregateInputType = {
    id?: true
    queryId?: true
    authorId?: true
    message?: true
    createdAt?: true
  }

  export type QueryResponseMaxAggregateInputType = {
    id?: true
    queryId?: true
    authorId?: true
    message?: true
    createdAt?: true
  }

  export type QueryResponseCountAggregateInputType = {
    id?: true
    queryId?: true
    authorId?: true
    message?: true
    createdAt?: true
    _all?: true
  }

  export type QueryResponseAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which QueryResponse to aggregate.
     */
    where?: QueryResponseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of QueryResponses to fetch.
     */
    orderBy?: QueryResponseOrderByWithRelationInput | QueryResponseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: QueryResponseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` QueryResponses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` QueryResponses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned QueryResponses
    **/
    _count?: true | QueryResponseCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: QueryResponseMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: QueryResponseMaxAggregateInputType
  }

  export type GetQueryResponseAggregateType<T extends QueryResponseAggregateArgs> = {
        [P in keyof T & keyof AggregateQueryResponse]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateQueryResponse[P]>
      : GetScalarType<T[P], AggregateQueryResponse[P]>
  }




  export type QueryResponseGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: QueryResponseWhereInput
    orderBy?: QueryResponseOrderByWithAggregationInput | QueryResponseOrderByWithAggregationInput[]
    by: QueryResponseScalarFieldEnum[] | QueryResponseScalarFieldEnum
    having?: QueryResponseScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: QueryResponseCountAggregateInputType | true
    _min?: QueryResponseMinAggregateInputType
    _max?: QueryResponseMaxAggregateInputType
  }

  export type QueryResponseGroupByOutputType = {
    id: string
    queryId: string
    authorId: string
    message: string
    createdAt: Date
    _count: QueryResponseCountAggregateOutputType | null
    _min: QueryResponseMinAggregateOutputType | null
    _max: QueryResponseMaxAggregateOutputType | null
  }

  type GetQueryResponseGroupByPayload<T extends QueryResponseGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<QueryResponseGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof QueryResponseGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], QueryResponseGroupByOutputType[P]>
            : GetScalarType<T[P], QueryResponseGroupByOutputType[P]>
        }
      >
    >


  export type QueryResponseSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    queryId?: boolean
    authorId?: boolean
    message?: boolean
    createdAt?: boolean
    query?: boolean | QueryDefaultArgs<ExtArgs>
    author?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["queryResponse"]>

  export type QueryResponseSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    queryId?: boolean
    authorId?: boolean
    message?: boolean
    createdAt?: boolean
    query?: boolean | QueryDefaultArgs<ExtArgs>
    author?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["queryResponse"]>

  export type QueryResponseSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    queryId?: boolean
    authorId?: boolean
    message?: boolean
    createdAt?: boolean
    query?: boolean | QueryDefaultArgs<ExtArgs>
    author?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["queryResponse"]>

  export type QueryResponseSelectScalar = {
    id?: boolean
    queryId?: boolean
    authorId?: boolean
    message?: boolean
    createdAt?: boolean
  }

  export type QueryResponseOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "queryId" | "authorId" | "message" | "createdAt", ExtArgs["result"]["queryResponse"]>
  export type QueryResponseInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    query?: boolean | QueryDefaultArgs<ExtArgs>
    author?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type QueryResponseIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    query?: boolean | QueryDefaultArgs<ExtArgs>
    author?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type QueryResponseIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    query?: boolean | QueryDefaultArgs<ExtArgs>
    author?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $QueryResponsePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "QueryResponse"
    objects: {
      query: Prisma.$QueryPayload<ExtArgs>
      author: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      queryId: string
      authorId: string
      message: string
      createdAt: Date
    }, ExtArgs["result"]["queryResponse"]>
    composites: {}
  }

  type QueryResponseGetPayload<S extends boolean | null | undefined | QueryResponseDefaultArgs> = $Result.GetResult<Prisma.$QueryResponsePayload, S>

  type QueryResponseCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<QueryResponseFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: QueryResponseCountAggregateInputType | true
    }

  export interface QueryResponseDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['QueryResponse'], meta: { name: 'QueryResponse' } }
    /**
     * Find zero or one QueryResponse that matches the filter.
     * @param {QueryResponseFindUniqueArgs} args - Arguments to find a QueryResponse
     * @example
     * // Get one QueryResponse
     * const queryResponse = await prisma.queryResponse.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends QueryResponseFindUniqueArgs>(args: SelectSubset<T, QueryResponseFindUniqueArgs<ExtArgs>>): Prisma__QueryResponseClient<$Result.GetResult<Prisma.$QueryResponsePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one QueryResponse that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {QueryResponseFindUniqueOrThrowArgs} args - Arguments to find a QueryResponse
     * @example
     * // Get one QueryResponse
     * const queryResponse = await prisma.queryResponse.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends QueryResponseFindUniqueOrThrowArgs>(args: SelectSubset<T, QueryResponseFindUniqueOrThrowArgs<ExtArgs>>): Prisma__QueryResponseClient<$Result.GetResult<Prisma.$QueryResponsePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first QueryResponse that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QueryResponseFindFirstArgs} args - Arguments to find a QueryResponse
     * @example
     * // Get one QueryResponse
     * const queryResponse = await prisma.queryResponse.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends QueryResponseFindFirstArgs>(args?: SelectSubset<T, QueryResponseFindFirstArgs<ExtArgs>>): Prisma__QueryResponseClient<$Result.GetResult<Prisma.$QueryResponsePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first QueryResponse that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QueryResponseFindFirstOrThrowArgs} args - Arguments to find a QueryResponse
     * @example
     * // Get one QueryResponse
     * const queryResponse = await prisma.queryResponse.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends QueryResponseFindFirstOrThrowArgs>(args?: SelectSubset<T, QueryResponseFindFirstOrThrowArgs<ExtArgs>>): Prisma__QueryResponseClient<$Result.GetResult<Prisma.$QueryResponsePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more QueryResponses that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QueryResponseFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all QueryResponses
     * const queryResponses = await prisma.queryResponse.findMany()
     * 
     * // Get first 10 QueryResponses
     * const queryResponses = await prisma.queryResponse.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const queryResponseWithIdOnly = await prisma.queryResponse.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends QueryResponseFindManyArgs>(args?: SelectSubset<T, QueryResponseFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QueryResponsePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a QueryResponse.
     * @param {QueryResponseCreateArgs} args - Arguments to create a QueryResponse.
     * @example
     * // Create one QueryResponse
     * const QueryResponse = await prisma.queryResponse.create({
     *   data: {
     *     // ... data to create a QueryResponse
     *   }
     * })
     * 
     */
    create<T extends QueryResponseCreateArgs>(args: SelectSubset<T, QueryResponseCreateArgs<ExtArgs>>): Prisma__QueryResponseClient<$Result.GetResult<Prisma.$QueryResponsePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many QueryResponses.
     * @param {QueryResponseCreateManyArgs} args - Arguments to create many QueryResponses.
     * @example
     * // Create many QueryResponses
     * const queryResponse = await prisma.queryResponse.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends QueryResponseCreateManyArgs>(args?: SelectSubset<T, QueryResponseCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many QueryResponses and returns the data saved in the database.
     * @param {QueryResponseCreateManyAndReturnArgs} args - Arguments to create many QueryResponses.
     * @example
     * // Create many QueryResponses
     * const queryResponse = await prisma.queryResponse.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many QueryResponses and only return the `id`
     * const queryResponseWithIdOnly = await prisma.queryResponse.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends QueryResponseCreateManyAndReturnArgs>(args?: SelectSubset<T, QueryResponseCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QueryResponsePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a QueryResponse.
     * @param {QueryResponseDeleteArgs} args - Arguments to delete one QueryResponse.
     * @example
     * // Delete one QueryResponse
     * const QueryResponse = await prisma.queryResponse.delete({
     *   where: {
     *     // ... filter to delete one QueryResponse
     *   }
     * })
     * 
     */
    delete<T extends QueryResponseDeleteArgs>(args: SelectSubset<T, QueryResponseDeleteArgs<ExtArgs>>): Prisma__QueryResponseClient<$Result.GetResult<Prisma.$QueryResponsePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one QueryResponse.
     * @param {QueryResponseUpdateArgs} args - Arguments to update one QueryResponse.
     * @example
     * // Update one QueryResponse
     * const queryResponse = await prisma.queryResponse.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends QueryResponseUpdateArgs>(args: SelectSubset<T, QueryResponseUpdateArgs<ExtArgs>>): Prisma__QueryResponseClient<$Result.GetResult<Prisma.$QueryResponsePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more QueryResponses.
     * @param {QueryResponseDeleteManyArgs} args - Arguments to filter QueryResponses to delete.
     * @example
     * // Delete a few QueryResponses
     * const { count } = await prisma.queryResponse.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends QueryResponseDeleteManyArgs>(args?: SelectSubset<T, QueryResponseDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more QueryResponses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QueryResponseUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many QueryResponses
     * const queryResponse = await prisma.queryResponse.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends QueryResponseUpdateManyArgs>(args: SelectSubset<T, QueryResponseUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more QueryResponses and returns the data updated in the database.
     * @param {QueryResponseUpdateManyAndReturnArgs} args - Arguments to update many QueryResponses.
     * @example
     * // Update many QueryResponses
     * const queryResponse = await prisma.queryResponse.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more QueryResponses and only return the `id`
     * const queryResponseWithIdOnly = await prisma.queryResponse.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends QueryResponseUpdateManyAndReturnArgs>(args: SelectSubset<T, QueryResponseUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QueryResponsePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one QueryResponse.
     * @param {QueryResponseUpsertArgs} args - Arguments to update or create a QueryResponse.
     * @example
     * // Update or create a QueryResponse
     * const queryResponse = await prisma.queryResponse.upsert({
     *   create: {
     *     // ... data to create a QueryResponse
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the QueryResponse we want to update
     *   }
     * })
     */
    upsert<T extends QueryResponseUpsertArgs>(args: SelectSubset<T, QueryResponseUpsertArgs<ExtArgs>>): Prisma__QueryResponseClient<$Result.GetResult<Prisma.$QueryResponsePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of QueryResponses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QueryResponseCountArgs} args - Arguments to filter QueryResponses to count.
     * @example
     * // Count the number of QueryResponses
     * const count = await prisma.queryResponse.count({
     *   where: {
     *     // ... the filter for the QueryResponses we want to count
     *   }
     * })
    **/
    count<T extends QueryResponseCountArgs>(
      args?: Subset<T, QueryResponseCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], QueryResponseCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a QueryResponse.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QueryResponseAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends QueryResponseAggregateArgs>(args: Subset<T, QueryResponseAggregateArgs>): Prisma.PrismaPromise<GetQueryResponseAggregateType<T>>

    /**
     * Group by QueryResponse.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QueryResponseGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends QueryResponseGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: QueryResponseGroupByArgs['orderBy'] }
        : { orderBy?: QueryResponseGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, QueryResponseGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetQueryResponseGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the QueryResponse model
   */
  readonly fields: QueryResponseFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for QueryResponse.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__QueryResponseClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    query<T extends QueryDefaultArgs<ExtArgs> = {}>(args?: Subset<T, QueryDefaultArgs<ExtArgs>>): Prisma__QueryClient<$Result.GetResult<Prisma.$QueryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    author<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the QueryResponse model
   */
  interface QueryResponseFieldRefs {
    readonly id: FieldRef<"QueryResponse", 'String'>
    readonly queryId: FieldRef<"QueryResponse", 'String'>
    readonly authorId: FieldRef<"QueryResponse", 'String'>
    readonly message: FieldRef<"QueryResponse", 'String'>
    readonly createdAt: FieldRef<"QueryResponse", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * QueryResponse findUnique
   */
  export type QueryResponseFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QueryResponse
     */
    select?: QueryResponseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QueryResponse
     */
    omit?: QueryResponseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QueryResponseInclude<ExtArgs> | null
    /**
     * Filter, which QueryResponse to fetch.
     */
    where: QueryResponseWhereUniqueInput
  }

  /**
   * QueryResponse findUniqueOrThrow
   */
  export type QueryResponseFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QueryResponse
     */
    select?: QueryResponseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QueryResponse
     */
    omit?: QueryResponseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QueryResponseInclude<ExtArgs> | null
    /**
     * Filter, which QueryResponse to fetch.
     */
    where: QueryResponseWhereUniqueInput
  }

  /**
   * QueryResponse findFirst
   */
  export type QueryResponseFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QueryResponse
     */
    select?: QueryResponseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QueryResponse
     */
    omit?: QueryResponseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QueryResponseInclude<ExtArgs> | null
    /**
     * Filter, which QueryResponse to fetch.
     */
    where?: QueryResponseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of QueryResponses to fetch.
     */
    orderBy?: QueryResponseOrderByWithRelationInput | QueryResponseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for QueryResponses.
     */
    cursor?: QueryResponseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` QueryResponses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` QueryResponses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of QueryResponses.
     */
    distinct?: QueryResponseScalarFieldEnum | QueryResponseScalarFieldEnum[]
  }

  /**
   * QueryResponse findFirstOrThrow
   */
  export type QueryResponseFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QueryResponse
     */
    select?: QueryResponseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QueryResponse
     */
    omit?: QueryResponseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QueryResponseInclude<ExtArgs> | null
    /**
     * Filter, which QueryResponse to fetch.
     */
    where?: QueryResponseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of QueryResponses to fetch.
     */
    orderBy?: QueryResponseOrderByWithRelationInput | QueryResponseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for QueryResponses.
     */
    cursor?: QueryResponseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` QueryResponses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` QueryResponses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of QueryResponses.
     */
    distinct?: QueryResponseScalarFieldEnum | QueryResponseScalarFieldEnum[]
  }

  /**
   * QueryResponse findMany
   */
  export type QueryResponseFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QueryResponse
     */
    select?: QueryResponseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QueryResponse
     */
    omit?: QueryResponseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QueryResponseInclude<ExtArgs> | null
    /**
     * Filter, which QueryResponses to fetch.
     */
    where?: QueryResponseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of QueryResponses to fetch.
     */
    orderBy?: QueryResponseOrderByWithRelationInput | QueryResponseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing QueryResponses.
     */
    cursor?: QueryResponseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` QueryResponses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` QueryResponses.
     */
    skip?: number
    distinct?: QueryResponseScalarFieldEnum | QueryResponseScalarFieldEnum[]
  }

  /**
   * QueryResponse create
   */
  export type QueryResponseCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QueryResponse
     */
    select?: QueryResponseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QueryResponse
     */
    omit?: QueryResponseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QueryResponseInclude<ExtArgs> | null
    /**
     * The data needed to create a QueryResponse.
     */
    data: XOR<QueryResponseCreateInput, QueryResponseUncheckedCreateInput>
  }

  /**
   * QueryResponse createMany
   */
  export type QueryResponseCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many QueryResponses.
     */
    data: QueryResponseCreateManyInput | QueryResponseCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * QueryResponse createManyAndReturn
   */
  export type QueryResponseCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QueryResponse
     */
    select?: QueryResponseSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the QueryResponse
     */
    omit?: QueryResponseOmit<ExtArgs> | null
    /**
     * The data used to create many QueryResponses.
     */
    data: QueryResponseCreateManyInput | QueryResponseCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QueryResponseIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * QueryResponse update
   */
  export type QueryResponseUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QueryResponse
     */
    select?: QueryResponseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QueryResponse
     */
    omit?: QueryResponseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QueryResponseInclude<ExtArgs> | null
    /**
     * The data needed to update a QueryResponse.
     */
    data: XOR<QueryResponseUpdateInput, QueryResponseUncheckedUpdateInput>
    /**
     * Choose, which QueryResponse to update.
     */
    where: QueryResponseWhereUniqueInput
  }

  /**
   * QueryResponse updateMany
   */
  export type QueryResponseUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update QueryResponses.
     */
    data: XOR<QueryResponseUpdateManyMutationInput, QueryResponseUncheckedUpdateManyInput>
    /**
     * Filter which QueryResponses to update
     */
    where?: QueryResponseWhereInput
    /**
     * Limit how many QueryResponses to update.
     */
    limit?: number
  }

  /**
   * QueryResponse updateManyAndReturn
   */
  export type QueryResponseUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QueryResponse
     */
    select?: QueryResponseSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the QueryResponse
     */
    omit?: QueryResponseOmit<ExtArgs> | null
    /**
     * The data used to update QueryResponses.
     */
    data: XOR<QueryResponseUpdateManyMutationInput, QueryResponseUncheckedUpdateManyInput>
    /**
     * Filter which QueryResponses to update
     */
    where?: QueryResponseWhereInput
    /**
     * Limit how many QueryResponses to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QueryResponseIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * QueryResponse upsert
   */
  export type QueryResponseUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QueryResponse
     */
    select?: QueryResponseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QueryResponse
     */
    omit?: QueryResponseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QueryResponseInclude<ExtArgs> | null
    /**
     * The filter to search for the QueryResponse to update in case it exists.
     */
    where: QueryResponseWhereUniqueInput
    /**
     * In case the QueryResponse found by the `where` argument doesn't exist, create a new QueryResponse with this data.
     */
    create: XOR<QueryResponseCreateInput, QueryResponseUncheckedCreateInput>
    /**
     * In case the QueryResponse was found with the provided `where` argument, update it with this data.
     */
    update: XOR<QueryResponseUpdateInput, QueryResponseUncheckedUpdateInput>
  }

  /**
   * QueryResponse delete
   */
  export type QueryResponseDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QueryResponse
     */
    select?: QueryResponseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QueryResponse
     */
    omit?: QueryResponseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QueryResponseInclude<ExtArgs> | null
    /**
     * Filter which QueryResponse to delete.
     */
    where: QueryResponseWhereUniqueInput
  }

  /**
   * QueryResponse deleteMany
   */
  export type QueryResponseDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which QueryResponses to delete
     */
    where?: QueryResponseWhereInput
    /**
     * Limit how many QueryResponses to delete.
     */
    limit?: number
  }

  /**
   * QueryResponse without action
   */
  export type QueryResponseDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QueryResponse
     */
    select?: QueryResponseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QueryResponse
     */
    omit?: QueryResponseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QueryResponseInclude<ExtArgs> | null
  }


  /**
   * Model AuditLog
   */

  export type AggregateAuditLog = {
    _count: AuditLogCountAggregateOutputType | null
    _min: AuditLogMinAggregateOutputType | null
    _max: AuditLogMaxAggregateOutputType | null
  }

  export type AuditLogMinAggregateOutputType = {
    id: string | null
    userId: string | null
    action: string | null
    entity: string | null
    entityId: string | null
    projectId: string | null
    createdAt: Date | null
  }

  export type AuditLogMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    action: string | null
    entity: string | null
    entityId: string | null
    projectId: string | null
    createdAt: Date | null
  }

  export type AuditLogCountAggregateOutputType = {
    id: number
    userId: number
    action: number
    entity: number
    entityId: number
    projectId: number
    metadata: number
    createdAt: number
    _all: number
  }


  export type AuditLogMinAggregateInputType = {
    id?: true
    userId?: true
    action?: true
    entity?: true
    entityId?: true
    projectId?: true
    createdAt?: true
  }

  export type AuditLogMaxAggregateInputType = {
    id?: true
    userId?: true
    action?: true
    entity?: true
    entityId?: true
    projectId?: true
    createdAt?: true
  }

  export type AuditLogCountAggregateInputType = {
    id?: true
    userId?: true
    action?: true
    entity?: true
    entityId?: true
    projectId?: true
    metadata?: true
    createdAt?: true
    _all?: true
  }

  export type AuditLogAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AuditLog to aggregate.
     */
    where?: AuditLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuditLogs to fetch.
     */
    orderBy?: AuditLogOrderByWithRelationInput | AuditLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AuditLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuditLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuditLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AuditLogs
    **/
    _count?: true | AuditLogCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AuditLogMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AuditLogMaxAggregateInputType
  }

  export type GetAuditLogAggregateType<T extends AuditLogAggregateArgs> = {
        [P in keyof T & keyof AggregateAuditLog]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAuditLog[P]>
      : GetScalarType<T[P], AggregateAuditLog[P]>
  }




  export type AuditLogGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AuditLogWhereInput
    orderBy?: AuditLogOrderByWithAggregationInput | AuditLogOrderByWithAggregationInput[]
    by: AuditLogScalarFieldEnum[] | AuditLogScalarFieldEnum
    having?: AuditLogScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AuditLogCountAggregateInputType | true
    _min?: AuditLogMinAggregateInputType
    _max?: AuditLogMaxAggregateInputType
  }

  export type AuditLogGroupByOutputType = {
    id: string
    userId: string
    action: string
    entity: string
    entityId: string
    projectId: string | null
    metadata: JsonValue | null
    createdAt: Date
    _count: AuditLogCountAggregateOutputType | null
    _min: AuditLogMinAggregateOutputType | null
    _max: AuditLogMaxAggregateOutputType | null
  }

  type GetAuditLogGroupByPayload<T extends AuditLogGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AuditLogGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AuditLogGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AuditLogGroupByOutputType[P]>
            : GetScalarType<T[P], AuditLogGroupByOutputType[P]>
        }
      >
    >


  export type AuditLogSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    action?: boolean
    entity?: boolean
    entityId?: boolean
    projectId?: boolean
    metadata?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    project?: boolean | AuditLog$projectArgs<ExtArgs>
  }, ExtArgs["result"]["auditLog"]>

  export type AuditLogSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    action?: boolean
    entity?: boolean
    entityId?: boolean
    projectId?: boolean
    metadata?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    project?: boolean | AuditLog$projectArgs<ExtArgs>
  }, ExtArgs["result"]["auditLog"]>

  export type AuditLogSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    action?: boolean
    entity?: boolean
    entityId?: boolean
    projectId?: boolean
    metadata?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    project?: boolean | AuditLog$projectArgs<ExtArgs>
  }, ExtArgs["result"]["auditLog"]>

  export type AuditLogSelectScalar = {
    id?: boolean
    userId?: boolean
    action?: boolean
    entity?: boolean
    entityId?: boolean
    projectId?: boolean
    metadata?: boolean
    createdAt?: boolean
  }

  export type AuditLogOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "action" | "entity" | "entityId" | "projectId" | "metadata" | "createdAt", ExtArgs["result"]["auditLog"]>
  export type AuditLogInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    project?: boolean | AuditLog$projectArgs<ExtArgs>
  }
  export type AuditLogIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    project?: boolean | AuditLog$projectArgs<ExtArgs>
  }
  export type AuditLogIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    project?: boolean | AuditLog$projectArgs<ExtArgs>
  }

  export type $AuditLogPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AuditLog"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      project: Prisma.$ProjectPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      action: string
      entity: string
      entityId: string
      projectId: string | null
      metadata: Prisma.JsonValue | null
      createdAt: Date
    }, ExtArgs["result"]["auditLog"]>
    composites: {}
  }

  type AuditLogGetPayload<S extends boolean | null | undefined | AuditLogDefaultArgs> = $Result.GetResult<Prisma.$AuditLogPayload, S>

  type AuditLogCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AuditLogFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AuditLogCountAggregateInputType | true
    }

  export interface AuditLogDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AuditLog'], meta: { name: 'AuditLog' } }
    /**
     * Find zero or one AuditLog that matches the filter.
     * @param {AuditLogFindUniqueArgs} args - Arguments to find a AuditLog
     * @example
     * // Get one AuditLog
     * const auditLog = await prisma.auditLog.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AuditLogFindUniqueArgs>(args: SelectSubset<T, AuditLogFindUniqueArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one AuditLog that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AuditLogFindUniqueOrThrowArgs} args - Arguments to find a AuditLog
     * @example
     * // Get one AuditLog
     * const auditLog = await prisma.auditLog.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AuditLogFindUniqueOrThrowArgs>(args: SelectSubset<T, AuditLogFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AuditLog that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogFindFirstArgs} args - Arguments to find a AuditLog
     * @example
     * // Get one AuditLog
     * const auditLog = await prisma.auditLog.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AuditLogFindFirstArgs>(args?: SelectSubset<T, AuditLogFindFirstArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AuditLog that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogFindFirstOrThrowArgs} args - Arguments to find a AuditLog
     * @example
     * // Get one AuditLog
     * const auditLog = await prisma.auditLog.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AuditLogFindFirstOrThrowArgs>(args?: SelectSubset<T, AuditLogFindFirstOrThrowArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more AuditLogs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AuditLogs
     * const auditLogs = await prisma.auditLog.findMany()
     * 
     * // Get first 10 AuditLogs
     * const auditLogs = await prisma.auditLog.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const auditLogWithIdOnly = await prisma.auditLog.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AuditLogFindManyArgs>(args?: SelectSubset<T, AuditLogFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a AuditLog.
     * @param {AuditLogCreateArgs} args - Arguments to create a AuditLog.
     * @example
     * // Create one AuditLog
     * const AuditLog = await prisma.auditLog.create({
     *   data: {
     *     // ... data to create a AuditLog
     *   }
     * })
     * 
     */
    create<T extends AuditLogCreateArgs>(args: SelectSubset<T, AuditLogCreateArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many AuditLogs.
     * @param {AuditLogCreateManyArgs} args - Arguments to create many AuditLogs.
     * @example
     * // Create many AuditLogs
     * const auditLog = await prisma.auditLog.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AuditLogCreateManyArgs>(args?: SelectSubset<T, AuditLogCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many AuditLogs and returns the data saved in the database.
     * @param {AuditLogCreateManyAndReturnArgs} args - Arguments to create many AuditLogs.
     * @example
     * // Create many AuditLogs
     * const auditLog = await prisma.auditLog.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many AuditLogs and only return the `id`
     * const auditLogWithIdOnly = await prisma.auditLog.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AuditLogCreateManyAndReturnArgs>(args?: SelectSubset<T, AuditLogCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a AuditLog.
     * @param {AuditLogDeleteArgs} args - Arguments to delete one AuditLog.
     * @example
     * // Delete one AuditLog
     * const AuditLog = await prisma.auditLog.delete({
     *   where: {
     *     // ... filter to delete one AuditLog
     *   }
     * })
     * 
     */
    delete<T extends AuditLogDeleteArgs>(args: SelectSubset<T, AuditLogDeleteArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one AuditLog.
     * @param {AuditLogUpdateArgs} args - Arguments to update one AuditLog.
     * @example
     * // Update one AuditLog
     * const auditLog = await prisma.auditLog.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AuditLogUpdateArgs>(args: SelectSubset<T, AuditLogUpdateArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more AuditLogs.
     * @param {AuditLogDeleteManyArgs} args - Arguments to filter AuditLogs to delete.
     * @example
     * // Delete a few AuditLogs
     * const { count } = await prisma.auditLog.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AuditLogDeleteManyArgs>(args?: SelectSubset<T, AuditLogDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AuditLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AuditLogs
     * const auditLog = await prisma.auditLog.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AuditLogUpdateManyArgs>(args: SelectSubset<T, AuditLogUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AuditLogs and returns the data updated in the database.
     * @param {AuditLogUpdateManyAndReturnArgs} args - Arguments to update many AuditLogs.
     * @example
     * // Update many AuditLogs
     * const auditLog = await prisma.auditLog.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more AuditLogs and only return the `id`
     * const auditLogWithIdOnly = await prisma.auditLog.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AuditLogUpdateManyAndReturnArgs>(args: SelectSubset<T, AuditLogUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one AuditLog.
     * @param {AuditLogUpsertArgs} args - Arguments to update or create a AuditLog.
     * @example
     * // Update or create a AuditLog
     * const auditLog = await prisma.auditLog.upsert({
     *   create: {
     *     // ... data to create a AuditLog
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AuditLog we want to update
     *   }
     * })
     */
    upsert<T extends AuditLogUpsertArgs>(args: SelectSubset<T, AuditLogUpsertArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of AuditLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogCountArgs} args - Arguments to filter AuditLogs to count.
     * @example
     * // Count the number of AuditLogs
     * const count = await prisma.auditLog.count({
     *   where: {
     *     // ... the filter for the AuditLogs we want to count
     *   }
     * })
    **/
    count<T extends AuditLogCountArgs>(
      args?: Subset<T, AuditLogCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AuditLogCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AuditLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AuditLogAggregateArgs>(args: Subset<T, AuditLogAggregateArgs>): Prisma.PrismaPromise<GetAuditLogAggregateType<T>>

    /**
     * Group by AuditLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AuditLogGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AuditLogGroupByArgs['orderBy'] }
        : { orderBy?: AuditLogGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AuditLogGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAuditLogGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AuditLog model
   */
  readonly fields: AuditLogFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AuditLog.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AuditLogClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    project<T extends AuditLog$projectArgs<ExtArgs> = {}>(args?: Subset<T, AuditLog$projectArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AuditLog model
   */
  interface AuditLogFieldRefs {
    readonly id: FieldRef<"AuditLog", 'String'>
    readonly userId: FieldRef<"AuditLog", 'String'>
    readonly action: FieldRef<"AuditLog", 'String'>
    readonly entity: FieldRef<"AuditLog", 'String'>
    readonly entityId: FieldRef<"AuditLog", 'String'>
    readonly projectId: FieldRef<"AuditLog", 'String'>
    readonly metadata: FieldRef<"AuditLog", 'Json'>
    readonly createdAt: FieldRef<"AuditLog", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * AuditLog findUnique
   */
  export type AuditLogFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * Filter, which AuditLog to fetch.
     */
    where: AuditLogWhereUniqueInput
  }

  /**
   * AuditLog findUniqueOrThrow
   */
  export type AuditLogFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * Filter, which AuditLog to fetch.
     */
    where: AuditLogWhereUniqueInput
  }

  /**
   * AuditLog findFirst
   */
  export type AuditLogFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * Filter, which AuditLog to fetch.
     */
    where?: AuditLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuditLogs to fetch.
     */
    orderBy?: AuditLogOrderByWithRelationInput | AuditLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AuditLogs.
     */
    cursor?: AuditLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuditLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuditLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AuditLogs.
     */
    distinct?: AuditLogScalarFieldEnum | AuditLogScalarFieldEnum[]
  }

  /**
   * AuditLog findFirstOrThrow
   */
  export type AuditLogFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * Filter, which AuditLog to fetch.
     */
    where?: AuditLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuditLogs to fetch.
     */
    orderBy?: AuditLogOrderByWithRelationInput | AuditLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AuditLogs.
     */
    cursor?: AuditLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuditLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuditLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AuditLogs.
     */
    distinct?: AuditLogScalarFieldEnum | AuditLogScalarFieldEnum[]
  }

  /**
   * AuditLog findMany
   */
  export type AuditLogFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * Filter, which AuditLogs to fetch.
     */
    where?: AuditLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuditLogs to fetch.
     */
    orderBy?: AuditLogOrderByWithRelationInput | AuditLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AuditLogs.
     */
    cursor?: AuditLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuditLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuditLogs.
     */
    skip?: number
    distinct?: AuditLogScalarFieldEnum | AuditLogScalarFieldEnum[]
  }

  /**
   * AuditLog create
   */
  export type AuditLogCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * The data needed to create a AuditLog.
     */
    data: XOR<AuditLogCreateInput, AuditLogUncheckedCreateInput>
  }

  /**
   * AuditLog createMany
   */
  export type AuditLogCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AuditLogs.
     */
    data: AuditLogCreateManyInput | AuditLogCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AuditLog createManyAndReturn
   */
  export type AuditLogCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * The data used to create many AuditLogs.
     */
    data: AuditLogCreateManyInput | AuditLogCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * AuditLog update
   */
  export type AuditLogUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * The data needed to update a AuditLog.
     */
    data: XOR<AuditLogUpdateInput, AuditLogUncheckedUpdateInput>
    /**
     * Choose, which AuditLog to update.
     */
    where: AuditLogWhereUniqueInput
  }

  /**
   * AuditLog updateMany
   */
  export type AuditLogUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AuditLogs.
     */
    data: XOR<AuditLogUpdateManyMutationInput, AuditLogUncheckedUpdateManyInput>
    /**
     * Filter which AuditLogs to update
     */
    where?: AuditLogWhereInput
    /**
     * Limit how many AuditLogs to update.
     */
    limit?: number
  }

  /**
   * AuditLog updateManyAndReturn
   */
  export type AuditLogUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * The data used to update AuditLogs.
     */
    data: XOR<AuditLogUpdateManyMutationInput, AuditLogUncheckedUpdateManyInput>
    /**
     * Filter which AuditLogs to update
     */
    where?: AuditLogWhereInput
    /**
     * Limit how many AuditLogs to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * AuditLog upsert
   */
  export type AuditLogUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * The filter to search for the AuditLog to update in case it exists.
     */
    where: AuditLogWhereUniqueInput
    /**
     * In case the AuditLog found by the `where` argument doesn't exist, create a new AuditLog with this data.
     */
    create: XOR<AuditLogCreateInput, AuditLogUncheckedCreateInput>
    /**
     * In case the AuditLog was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AuditLogUpdateInput, AuditLogUncheckedUpdateInput>
  }

  /**
   * AuditLog delete
   */
  export type AuditLogDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * Filter which AuditLog to delete.
     */
    where: AuditLogWhereUniqueInput
  }

  /**
   * AuditLog deleteMany
   */
  export type AuditLogDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AuditLogs to delete
     */
    where?: AuditLogWhereInput
    /**
     * Limit how many AuditLogs to delete.
     */
    limit?: number
  }

  /**
   * AuditLog.project
   */
  export type AuditLog$projectArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Project
     */
    omit?: ProjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInclude<ExtArgs> | null
    where?: ProjectWhereInput
  }

  /**
   * AuditLog without action
   */
  export type AuditLogDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
  }


  /**
   * Model Material
   */

  export type AggregateMaterial = {
    _count: MaterialCountAggregateOutputType | null
    _avg: MaterialAvgAggregateOutputType | null
    _sum: MaterialSumAggregateOutputType | null
    _min: MaterialMinAggregateOutputType | null
    _max: MaterialMaxAggregateOutputType | null
  }

  export type MaterialAvgAggregateOutputType = {
    quantity: number | null
    unitCost: number | null
    totalCost: number | null
  }

  export type MaterialSumAggregateOutputType = {
    quantity: number | null
    unitCost: number | null
    totalCost: number | null
  }

  export type MaterialMinAggregateOutputType = {
    id: string | null
    projectId: string | null
    name: string | null
    quantity: number | null
    unit: string | null
    unitCost: number | null
    totalCost: number | null
    supplier: string | null
    status: $Enums.MaterialStatus | null
    createdById: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type MaterialMaxAggregateOutputType = {
    id: string | null
    projectId: string | null
    name: string | null
    quantity: number | null
    unit: string | null
    unitCost: number | null
    totalCost: number | null
    supplier: string | null
    status: $Enums.MaterialStatus | null
    createdById: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type MaterialCountAggregateOutputType = {
    id: number
    projectId: number
    name: number
    quantity: number
    unit: number
    unitCost: number
    totalCost: number
    supplier: number
    status: number
    createdById: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type MaterialAvgAggregateInputType = {
    quantity?: true
    unitCost?: true
    totalCost?: true
  }

  export type MaterialSumAggregateInputType = {
    quantity?: true
    unitCost?: true
    totalCost?: true
  }

  export type MaterialMinAggregateInputType = {
    id?: true
    projectId?: true
    name?: true
    quantity?: true
    unit?: true
    unitCost?: true
    totalCost?: true
    supplier?: true
    status?: true
    createdById?: true
    createdAt?: true
    updatedAt?: true
  }

  export type MaterialMaxAggregateInputType = {
    id?: true
    projectId?: true
    name?: true
    quantity?: true
    unit?: true
    unitCost?: true
    totalCost?: true
    supplier?: true
    status?: true
    createdById?: true
    createdAt?: true
    updatedAt?: true
  }

  export type MaterialCountAggregateInputType = {
    id?: true
    projectId?: true
    name?: true
    quantity?: true
    unit?: true
    unitCost?: true
    totalCost?: true
    supplier?: true
    status?: true
    createdById?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type MaterialAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Material to aggregate.
     */
    where?: MaterialWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Materials to fetch.
     */
    orderBy?: MaterialOrderByWithRelationInput | MaterialOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MaterialWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Materials from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Materials.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Materials
    **/
    _count?: true | MaterialCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: MaterialAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: MaterialSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MaterialMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MaterialMaxAggregateInputType
  }

  export type GetMaterialAggregateType<T extends MaterialAggregateArgs> = {
        [P in keyof T & keyof AggregateMaterial]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMaterial[P]>
      : GetScalarType<T[P], AggregateMaterial[P]>
  }




  export type MaterialGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MaterialWhereInput
    orderBy?: MaterialOrderByWithAggregationInput | MaterialOrderByWithAggregationInput[]
    by: MaterialScalarFieldEnum[] | MaterialScalarFieldEnum
    having?: MaterialScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MaterialCountAggregateInputType | true
    _avg?: MaterialAvgAggregateInputType
    _sum?: MaterialSumAggregateInputType
    _min?: MaterialMinAggregateInputType
    _max?: MaterialMaxAggregateInputType
  }

  export type MaterialGroupByOutputType = {
    id: string
    projectId: string
    name: string
    quantity: number
    unit: string
    unitCost: number
    totalCost: number
    supplier: string | null
    status: $Enums.MaterialStatus
    createdById: string
    createdAt: Date
    updatedAt: Date
    _count: MaterialCountAggregateOutputType | null
    _avg: MaterialAvgAggregateOutputType | null
    _sum: MaterialSumAggregateOutputType | null
    _min: MaterialMinAggregateOutputType | null
    _max: MaterialMaxAggregateOutputType | null
  }

  type GetMaterialGroupByPayload<T extends MaterialGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MaterialGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MaterialGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MaterialGroupByOutputType[P]>
            : GetScalarType<T[P], MaterialGroupByOutputType[P]>
        }
      >
    >


  export type MaterialSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    projectId?: boolean
    name?: boolean
    quantity?: boolean
    unit?: boolean
    unitCost?: boolean
    totalCost?: boolean
    supplier?: boolean
    status?: boolean
    createdById?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    project?: boolean | ProjectDefaultArgs<ExtArgs>
    createdBy?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["material"]>

  export type MaterialSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    projectId?: boolean
    name?: boolean
    quantity?: boolean
    unit?: boolean
    unitCost?: boolean
    totalCost?: boolean
    supplier?: boolean
    status?: boolean
    createdById?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    project?: boolean | ProjectDefaultArgs<ExtArgs>
    createdBy?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["material"]>

  export type MaterialSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    projectId?: boolean
    name?: boolean
    quantity?: boolean
    unit?: boolean
    unitCost?: boolean
    totalCost?: boolean
    supplier?: boolean
    status?: boolean
    createdById?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    project?: boolean | ProjectDefaultArgs<ExtArgs>
    createdBy?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["material"]>

  export type MaterialSelectScalar = {
    id?: boolean
    projectId?: boolean
    name?: boolean
    quantity?: boolean
    unit?: boolean
    unitCost?: boolean
    totalCost?: boolean
    supplier?: boolean
    status?: boolean
    createdById?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type MaterialOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "projectId" | "name" | "quantity" | "unit" | "unitCost" | "totalCost" | "supplier" | "status" | "createdById" | "createdAt" | "updatedAt", ExtArgs["result"]["material"]>
  export type MaterialInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    project?: boolean | ProjectDefaultArgs<ExtArgs>
    createdBy?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type MaterialIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    project?: boolean | ProjectDefaultArgs<ExtArgs>
    createdBy?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type MaterialIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    project?: boolean | ProjectDefaultArgs<ExtArgs>
    createdBy?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $MaterialPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Material"
    objects: {
      project: Prisma.$ProjectPayload<ExtArgs>
      createdBy: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      projectId: string
      name: string
      quantity: number
      unit: string
      unitCost: number
      totalCost: number
      supplier: string | null
      status: $Enums.MaterialStatus
      createdById: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["material"]>
    composites: {}
  }

  type MaterialGetPayload<S extends boolean | null | undefined | MaterialDefaultArgs> = $Result.GetResult<Prisma.$MaterialPayload, S>

  type MaterialCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<MaterialFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: MaterialCountAggregateInputType | true
    }

  export interface MaterialDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Material'], meta: { name: 'Material' } }
    /**
     * Find zero or one Material that matches the filter.
     * @param {MaterialFindUniqueArgs} args - Arguments to find a Material
     * @example
     * // Get one Material
     * const material = await prisma.material.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MaterialFindUniqueArgs>(args: SelectSubset<T, MaterialFindUniqueArgs<ExtArgs>>): Prisma__MaterialClient<$Result.GetResult<Prisma.$MaterialPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Material that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {MaterialFindUniqueOrThrowArgs} args - Arguments to find a Material
     * @example
     * // Get one Material
     * const material = await prisma.material.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MaterialFindUniqueOrThrowArgs>(args: SelectSubset<T, MaterialFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MaterialClient<$Result.GetResult<Prisma.$MaterialPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Material that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MaterialFindFirstArgs} args - Arguments to find a Material
     * @example
     * // Get one Material
     * const material = await prisma.material.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MaterialFindFirstArgs>(args?: SelectSubset<T, MaterialFindFirstArgs<ExtArgs>>): Prisma__MaterialClient<$Result.GetResult<Prisma.$MaterialPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Material that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MaterialFindFirstOrThrowArgs} args - Arguments to find a Material
     * @example
     * // Get one Material
     * const material = await prisma.material.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MaterialFindFirstOrThrowArgs>(args?: SelectSubset<T, MaterialFindFirstOrThrowArgs<ExtArgs>>): Prisma__MaterialClient<$Result.GetResult<Prisma.$MaterialPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Materials that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MaterialFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Materials
     * const materials = await prisma.material.findMany()
     * 
     * // Get first 10 Materials
     * const materials = await prisma.material.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const materialWithIdOnly = await prisma.material.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends MaterialFindManyArgs>(args?: SelectSubset<T, MaterialFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MaterialPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Material.
     * @param {MaterialCreateArgs} args - Arguments to create a Material.
     * @example
     * // Create one Material
     * const Material = await prisma.material.create({
     *   data: {
     *     // ... data to create a Material
     *   }
     * })
     * 
     */
    create<T extends MaterialCreateArgs>(args: SelectSubset<T, MaterialCreateArgs<ExtArgs>>): Prisma__MaterialClient<$Result.GetResult<Prisma.$MaterialPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Materials.
     * @param {MaterialCreateManyArgs} args - Arguments to create many Materials.
     * @example
     * // Create many Materials
     * const material = await prisma.material.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MaterialCreateManyArgs>(args?: SelectSubset<T, MaterialCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Materials and returns the data saved in the database.
     * @param {MaterialCreateManyAndReturnArgs} args - Arguments to create many Materials.
     * @example
     * // Create many Materials
     * const material = await prisma.material.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Materials and only return the `id`
     * const materialWithIdOnly = await prisma.material.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends MaterialCreateManyAndReturnArgs>(args?: SelectSubset<T, MaterialCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MaterialPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Material.
     * @param {MaterialDeleteArgs} args - Arguments to delete one Material.
     * @example
     * // Delete one Material
     * const Material = await prisma.material.delete({
     *   where: {
     *     // ... filter to delete one Material
     *   }
     * })
     * 
     */
    delete<T extends MaterialDeleteArgs>(args: SelectSubset<T, MaterialDeleteArgs<ExtArgs>>): Prisma__MaterialClient<$Result.GetResult<Prisma.$MaterialPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Material.
     * @param {MaterialUpdateArgs} args - Arguments to update one Material.
     * @example
     * // Update one Material
     * const material = await prisma.material.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MaterialUpdateArgs>(args: SelectSubset<T, MaterialUpdateArgs<ExtArgs>>): Prisma__MaterialClient<$Result.GetResult<Prisma.$MaterialPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Materials.
     * @param {MaterialDeleteManyArgs} args - Arguments to filter Materials to delete.
     * @example
     * // Delete a few Materials
     * const { count } = await prisma.material.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MaterialDeleteManyArgs>(args?: SelectSubset<T, MaterialDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Materials.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MaterialUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Materials
     * const material = await prisma.material.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MaterialUpdateManyArgs>(args: SelectSubset<T, MaterialUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Materials and returns the data updated in the database.
     * @param {MaterialUpdateManyAndReturnArgs} args - Arguments to update many Materials.
     * @example
     * // Update many Materials
     * const material = await prisma.material.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Materials and only return the `id`
     * const materialWithIdOnly = await prisma.material.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends MaterialUpdateManyAndReturnArgs>(args: SelectSubset<T, MaterialUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MaterialPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Material.
     * @param {MaterialUpsertArgs} args - Arguments to update or create a Material.
     * @example
     * // Update or create a Material
     * const material = await prisma.material.upsert({
     *   create: {
     *     // ... data to create a Material
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Material we want to update
     *   }
     * })
     */
    upsert<T extends MaterialUpsertArgs>(args: SelectSubset<T, MaterialUpsertArgs<ExtArgs>>): Prisma__MaterialClient<$Result.GetResult<Prisma.$MaterialPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Materials.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MaterialCountArgs} args - Arguments to filter Materials to count.
     * @example
     * // Count the number of Materials
     * const count = await prisma.material.count({
     *   where: {
     *     // ... the filter for the Materials we want to count
     *   }
     * })
    **/
    count<T extends MaterialCountArgs>(
      args?: Subset<T, MaterialCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MaterialCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Material.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MaterialAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MaterialAggregateArgs>(args: Subset<T, MaterialAggregateArgs>): Prisma.PrismaPromise<GetMaterialAggregateType<T>>

    /**
     * Group by Material.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MaterialGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MaterialGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MaterialGroupByArgs['orderBy'] }
        : { orderBy?: MaterialGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MaterialGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMaterialGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Material model
   */
  readonly fields: MaterialFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Material.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MaterialClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    project<T extends ProjectDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProjectDefaultArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    createdBy<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Material model
   */
  interface MaterialFieldRefs {
    readonly id: FieldRef<"Material", 'String'>
    readonly projectId: FieldRef<"Material", 'String'>
    readonly name: FieldRef<"Material", 'String'>
    readonly quantity: FieldRef<"Material", 'Float'>
    readonly unit: FieldRef<"Material", 'String'>
    readonly unitCost: FieldRef<"Material", 'Float'>
    readonly totalCost: FieldRef<"Material", 'Float'>
    readonly supplier: FieldRef<"Material", 'String'>
    readonly status: FieldRef<"Material", 'MaterialStatus'>
    readonly createdById: FieldRef<"Material", 'String'>
    readonly createdAt: FieldRef<"Material", 'DateTime'>
    readonly updatedAt: FieldRef<"Material", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Material findUnique
   */
  export type MaterialFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Material
     */
    select?: MaterialSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Material
     */
    omit?: MaterialOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaterialInclude<ExtArgs> | null
    /**
     * Filter, which Material to fetch.
     */
    where: MaterialWhereUniqueInput
  }

  /**
   * Material findUniqueOrThrow
   */
  export type MaterialFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Material
     */
    select?: MaterialSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Material
     */
    omit?: MaterialOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaterialInclude<ExtArgs> | null
    /**
     * Filter, which Material to fetch.
     */
    where: MaterialWhereUniqueInput
  }

  /**
   * Material findFirst
   */
  export type MaterialFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Material
     */
    select?: MaterialSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Material
     */
    omit?: MaterialOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaterialInclude<ExtArgs> | null
    /**
     * Filter, which Material to fetch.
     */
    where?: MaterialWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Materials to fetch.
     */
    orderBy?: MaterialOrderByWithRelationInput | MaterialOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Materials.
     */
    cursor?: MaterialWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Materials from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Materials.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Materials.
     */
    distinct?: MaterialScalarFieldEnum | MaterialScalarFieldEnum[]
  }

  /**
   * Material findFirstOrThrow
   */
  export type MaterialFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Material
     */
    select?: MaterialSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Material
     */
    omit?: MaterialOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaterialInclude<ExtArgs> | null
    /**
     * Filter, which Material to fetch.
     */
    where?: MaterialWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Materials to fetch.
     */
    orderBy?: MaterialOrderByWithRelationInput | MaterialOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Materials.
     */
    cursor?: MaterialWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Materials from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Materials.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Materials.
     */
    distinct?: MaterialScalarFieldEnum | MaterialScalarFieldEnum[]
  }

  /**
   * Material findMany
   */
  export type MaterialFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Material
     */
    select?: MaterialSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Material
     */
    omit?: MaterialOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaterialInclude<ExtArgs> | null
    /**
     * Filter, which Materials to fetch.
     */
    where?: MaterialWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Materials to fetch.
     */
    orderBy?: MaterialOrderByWithRelationInput | MaterialOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Materials.
     */
    cursor?: MaterialWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Materials from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Materials.
     */
    skip?: number
    distinct?: MaterialScalarFieldEnum | MaterialScalarFieldEnum[]
  }

  /**
   * Material create
   */
  export type MaterialCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Material
     */
    select?: MaterialSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Material
     */
    omit?: MaterialOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaterialInclude<ExtArgs> | null
    /**
     * The data needed to create a Material.
     */
    data: XOR<MaterialCreateInput, MaterialUncheckedCreateInput>
  }

  /**
   * Material createMany
   */
  export type MaterialCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Materials.
     */
    data: MaterialCreateManyInput | MaterialCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Material createManyAndReturn
   */
  export type MaterialCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Material
     */
    select?: MaterialSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Material
     */
    omit?: MaterialOmit<ExtArgs> | null
    /**
     * The data used to create many Materials.
     */
    data: MaterialCreateManyInput | MaterialCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaterialIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Material update
   */
  export type MaterialUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Material
     */
    select?: MaterialSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Material
     */
    omit?: MaterialOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaterialInclude<ExtArgs> | null
    /**
     * The data needed to update a Material.
     */
    data: XOR<MaterialUpdateInput, MaterialUncheckedUpdateInput>
    /**
     * Choose, which Material to update.
     */
    where: MaterialWhereUniqueInput
  }

  /**
   * Material updateMany
   */
  export type MaterialUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Materials.
     */
    data: XOR<MaterialUpdateManyMutationInput, MaterialUncheckedUpdateManyInput>
    /**
     * Filter which Materials to update
     */
    where?: MaterialWhereInput
    /**
     * Limit how many Materials to update.
     */
    limit?: number
  }

  /**
   * Material updateManyAndReturn
   */
  export type MaterialUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Material
     */
    select?: MaterialSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Material
     */
    omit?: MaterialOmit<ExtArgs> | null
    /**
     * The data used to update Materials.
     */
    data: XOR<MaterialUpdateManyMutationInput, MaterialUncheckedUpdateManyInput>
    /**
     * Filter which Materials to update
     */
    where?: MaterialWhereInput
    /**
     * Limit how many Materials to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaterialIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Material upsert
   */
  export type MaterialUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Material
     */
    select?: MaterialSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Material
     */
    omit?: MaterialOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaterialInclude<ExtArgs> | null
    /**
     * The filter to search for the Material to update in case it exists.
     */
    where: MaterialWhereUniqueInput
    /**
     * In case the Material found by the `where` argument doesn't exist, create a new Material with this data.
     */
    create: XOR<MaterialCreateInput, MaterialUncheckedCreateInput>
    /**
     * In case the Material was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MaterialUpdateInput, MaterialUncheckedUpdateInput>
  }

  /**
   * Material delete
   */
  export type MaterialDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Material
     */
    select?: MaterialSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Material
     */
    omit?: MaterialOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaterialInclude<ExtArgs> | null
    /**
     * Filter which Material to delete.
     */
    where: MaterialWhereUniqueInput
  }

  /**
   * Material deleteMany
   */
  export type MaterialDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Materials to delete
     */
    where?: MaterialWhereInput
    /**
     * Limit how many Materials to delete.
     */
    limit?: number
  }

  /**
   * Material without action
   */
  export type MaterialDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Material
     */
    select?: MaterialSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Material
     */
    omit?: MaterialOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaterialInclude<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const UserScalarFieldEnum: {
    id: 'id',
    name: 'name',
    email: 'email',
    passwordHash: 'passwordHash',
    role: 'role',
    isActive: 'isActive',
    createdById: 'createdById',
    createdAt: 'createdAt',
    phone: 'phone',
    designation: 'designation'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const ProjectScalarFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description',
    status: 'status',
    isArchived: 'isArchived',
    createdById: 'createdById',
    managerId: 'managerId',
    clientId: 'clientId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ProjectScalarFieldEnum = (typeof ProjectScalarFieldEnum)[keyof typeof ProjectScalarFieldEnum]


  export const ProjectMemberScalarFieldEnum: {
    id: 'id',
    projectId: 'projectId',
    userId: 'userId',
    role: 'role',
    createdAt: 'createdAt'
  };

  export type ProjectMemberScalarFieldEnum = (typeof ProjectMemberScalarFieldEnum)[keyof typeof ProjectMemberScalarFieldEnum]


  export const ProjectUpdateScalarFieldEnum: {
    id: 'id',
    projectId: 'projectId',
    authorId: 'authorId',
    notes: 'notes',
    statusSnapshot: 'statusSnapshot',
    createdAt: 'createdAt'
  };

  export type ProjectUpdateScalarFieldEnum = (typeof ProjectUpdateScalarFieldEnum)[keyof typeof ProjectUpdateScalarFieldEnum]


  export const MediaScalarFieldEnum: {
    id: 'id',
    projectId: 'projectId',
    projectUpdateId: 'projectUpdateId',
    paymentId: 'paymentId',
    type: 'type',
    fileKey: 'fileKey',
    fileUrl: 'fileUrl',
    mimeType: 'mimeType',
    fileSize: 'fileSize',
    createdById: 'createdById',
    approvedBy: 'approvedBy',
    approvedAt: 'approvedAt',
    version: 'version',
    createdAt: 'createdAt',
    queryId: 'queryId'
  };

  export type MediaScalarFieldEnum = (typeof MediaScalarFieldEnum)[keyof typeof MediaScalarFieldEnum]


  export const PaymentScalarFieldEnum: {
    id: 'id',
    projectId: 'projectId',
    createdById: 'createdById',
    amount: 'amount',
    currency: 'currency',
    status: 'status',
    category: 'category',
    invoiceNumber: 'invoiceNumber',
    paidAt: 'paidAt',
    dueDate: 'dueDate',
    notes: 'notes',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type PaymentScalarFieldEnum = (typeof PaymentScalarFieldEnum)[keyof typeof PaymentScalarFieldEnum]


  export const NotificationScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    title: 'title',
    message: 'message',
    type: 'type',
    priority: 'priority',
    actionUrl: 'actionUrl',
    isRead: 'isRead',
    createdAt: 'createdAt'
  };

  export type NotificationScalarFieldEnum = (typeof NotificationScalarFieldEnum)[keyof typeof NotificationScalarFieldEnum]


  export const NotificationPreferenceScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    inspectionSubmitted: 'inspectionSubmitted',
    paymentOverdue: 'paymentOverdue',
    newAssignment: 'newAssignment',
    queryCreated: 'queryCreated',
    drawingApproved: 'drawingApproved',
    emailEnabled: 'emailEnabled',
    inAppEnabled: 'inAppEnabled',
    updatedAt: 'updatedAt'
  };

  export type NotificationPreferenceScalarFieldEnum = (typeof NotificationPreferenceScalarFieldEnum)[keyof typeof NotificationPreferenceScalarFieldEnum]


  export const MilestoneScalarFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description',
    order: 'order',
    isActive: 'isActive',
    projectId: 'projectId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type MilestoneScalarFieldEnum = (typeof MilestoneScalarFieldEnum)[keyof typeof MilestoneScalarFieldEnum]


  export const ChecklistItemScalarFieldEnum: {
    id: 'id',
    title: 'title',
    description: 'description',
    order: 'order',
    isRequired: 'isRequired',
    isPhotoRequired: 'isPhotoRequired',
    milestoneId: 'milestoneId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ChecklistItemScalarFieldEnum = (typeof ChecklistItemScalarFieldEnum)[keyof typeof ChecklistItemScalarFieldEnum]


  export const InspectionScalarFieldEnum: {
    id: 'id',
    status: 'status',
    projectId: 'projectId',
    milestoneId: 'milestoneId',
    engineerId: 'engineerId',
    reviewedById: 'reviewedById',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type InspectionScalarFieldEnum = (typeof InspectionScalarFieldEnum)[keyof typeof InspectionScalarFieldEnum]


  export const InspectionResponseScalarFieldEnum: {
    id: 'id',
    result: 'result',
    remark: 'remark',
    inspectionId: 'inspectionId',
    checklistItemId: 'checklistItemId',
    mediaId: 'mediaId'
  };

  export type InspectionResponseScalarFieldEnum = (typeof InspectionResponseScalarFieldEnum)[keyof typeof InspectionResponseScalarFieldEnum]


  export const QueryScalarFieldEnum: {
    id: 'id',
    projectId: 'projectId',
    authorId: 'authorId',
    title: 'title',
    description: 'description',
    status: 'status',
    priority: 'priority',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type QueryScalarFieldEnum = (typeof QueryScalarFieldEnum)[keyof typeof QueryScalarFieldEnum]


  export const QueryResponseScalarFieldEnum: {
    id: 'id',
    queryId: 'queryId',
    authorId: 'authorId',
    message: 'message',
    createdAt: 'createdAt'
  };

  export type QueryResponseScalarFieldEnum = (typeof QueryResponseScalarFieldEnum)[keyof typeof QueryResponseScalarFieldEnum]


  export const AuditLogScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    action: 'action',
    entity: 'entity',
    entityId: 'entityId',
    projectId: 'projectId',
    metadata: 'metadata',
    createdAt: 'createdAt'
  };

  export type AuditLogScalarFieldEnum = (typeof AuditLogScalarFieldEnum)[keyof typeof AuditLogScalarFieldEnum]


  export const MaterialScalarFieldEnum: {
    id: 'id',
    projectId: 'projectId',
    name: 'name',
    quantity: 'quantity',
    unit: 'unit',
    unitCost: 'unitCost',
    totalCost: 'totalCost',
    supplier: 'supplier',
    status: 'status',
    createdById: 'createdById',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type MaterialScalarFieldEnum = (typeof MaterialScalarFieldEnum)[keyof typeof MaterialScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const NullableJsonNullValueInput: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull
  };

  export type NullableJsonNullValueInput = (typeof NullableJsonNullValueInput)[keyof typeof NullableJsonNullValueInput]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  export const JsonNullValueFilter: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull,
    AnyNull: typeof AnyNull
  };

  export type JsonNullValueFilter = (typeof JsonNullValueFilter)[keyof typeof JsonNullValueFilter]


  /**
   * Field references
   */


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'Role'
   */
  export type EnumRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Role'>
    


  /**
   * Reference to a field of type 'Role[]'
   */
  export type ListEnumRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Role[]'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'ProjectStatus'
   */
  export type EnumProjectStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ProjectStatus'>
    


  /**
   * Reference to a field of type 'ProjectStatus[]'
   */
  export type ListEnumProjectStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ProjectStatus[]'>
    


  /**
   * Reference to a field of type 'ProjectMemberRole'
   */
  export type EnumProjectMemberRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ProjectMemberRole'>
    


  /**
   * Reference to a field of type 'ProjectMemberRole[]'
   */
  export type ListEnumProjectMemberRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ProjectMemberRole[]'>
    


  /**
   * Reference to a field of type 'MediaType'
   */
  export type EnumMediaTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'MediaType'>
    


  /**
   * Reference to a field of type 'MediaType[]'
   */
  export type ListEnumMediaTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'MediaType[]'>
    


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'Decimal'
   */
  export type DecimalFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Decimal'>
    


  /**
   * Reference to a field of type 'Decimal[]'
   */
  export type ListDecimalFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Decimal[]'>
    


  /**
   * Reference to a field of type 'PaymentStatus'
   */
  export type EnumPaymentStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PaymentStatus'>
    


  /**
   * Reference to a field of type 'PaymentStatus[]'
   */
  export type ListEnumPaymentStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PaymentStatus[]'>
    


  /**
   * Reference to a field of type 'PaymentCategory'
   */
  export type EnumPaymentCategoryFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PaymentCategory'>
    


  /**
   * Reference to a field of type 'PaymentCategory[]'
   */
  export type ListEnumPaymentCategoryFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PaymentCategory[]'>
    


  /**
   * Reference to a field of type 'NotificationPriority'
   */
  export type EnumNotificationPriorityFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'NotificationPriority'>
    


  /**
   * Reference to a field of type 'NotificationPriority[]'
   */
  export type ListEnumNotificationPriorityFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'NotificationPriority[]'>
    


  /**
   * Reference to a field of type 'InspectionStatus'
   */
  export type EnumInspectionStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'InspectionStatus'>
    


  /**
   * Reference to a field of type 'InspectionStatus[]'
   */
  export type ListEnumInspectionStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'InspectionStatus[]'>
    


  /**
   * Reference to a field of type 'ChecklistResult'
   */
  export type EnumChecklistResultFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ChecklistResult'>
    


  /**
   * Reference to a field of type 'ChecklistResult[]'
   */
  export type ListEnumChecklistResultFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ChecklistResult[]'>
    


  /**
   * Reference to a field of type 'QueryStatus'
   */
  export type EnumQueryStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'QueryStatus'>
    


  /**
   * Reference to a field of type 'QueryStatus[]'
   */
  export type ListEnumQueryStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'QueryStatus[]'>
    


  /**
   * Reference to a field of type 'QueryPriority'
   */
  export type EnumQueryPriorityFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'QueryPriority'>
    


  /**
   * Reference to a field of type 'QueryPriority[]'
   */
  export type ListEnumQueryPriorityFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'QueryPriority[]'>
    


  /**
   * Reference to a field of type 'Json'
   */
  export type JsonFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Json'>
    


  /**
   * Reference to a field of type 'QueryMode'
   */
  export type EnumQueryModeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'QueryMode'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    


  /**
   * Reference to a field of type 'MaterialStatus'
   */
  export type EnumMaterialStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'MaterialStatus'>
    


  /**
   * Reference to a field of type 'MaterialStatus[]'
   */
  export type ListEnumMaterialStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'MaterialStatus[]'>
    
  /**
   * Deep Input Types
   */


  export type UserWhereInput = {
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    id?: StringFilter<"User"> | string
    name?: StringFilter<"User"> | string
    email?: StringFilter<"User"> | string
    passwordHash?: StringFilter<"User"> | string
    role?: EnumRoleFilter<"User"> | $Enums.Role
    isActive?: BoolFilter<"User"> | boolean
    createdById?: StringNullableFilter<"User"> | string | null
    createdAt?: DateTimeFilter<"User"> | Date | string
    phone?: StringNullableFilter<"User"> | string | null
    designation?: StringNullableFilter<"User"> | string | null
    createdBy?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    createdUsers?: UserListRelationFilter
    managedProjects?: ProjectListRelationFilter
    clientProjects?: ProjectListRelationFilter
    projectMembers?: ProjectMemberListRelationFilter
    projectUpdates?: ProjectUpdateListRelationFilter
    media?: MediaListRelationFilter
    paymentsCreated?: PaymentListRelationFilter
    notifications?: NotificationListRelationFilter
    projectsCreated?: ProjectListRelationFilter
    inspections?: InspectionListRelationFilter
    reviewedInspections?: InspectionListRelationFilter
    queries?: QueryListRelationFilter
    queryResponses?: QueryResponseListRelationFilter
    auditLogs?: AuditLogListRelationFilter
    notificationPrefs?: XOR<NotificationPreferenceNullableScalarRelationFilter, NotificationPreferenceWhereInput> | null
    materialsCreated?: MaterialListRelationFilter
  }

  export type UserOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    passwordHash?: SortOrder
    role?: SortOrder
    isActive?: SortOrder
    createdById?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    phone?: SortOrderInput | SortOrder
    designation?: SortOrderInput | SortOrder
    createdBy?: UserOrderByWithRelationInput
    createdUsers?: UserOrderByRelationAggregateInput
    managedProjects?: ProjectOrderByRelationAggregateInput
    clientProjects?: ProjectOrderByRelationAggregateInput
    projectMembers?: ProjectMemberOrderByRelationAggregateInput
    projectUpdates?: ProjectUpdateOrderByRelationAggregateInput
    media?: MediaOrderByRelationAggregateInput
    paymentsCreated?: PaymentOrderByRelationAggregateInput
    notifications?: NotificationOrderByRelationAggregateInput
    projectsCreated?: ProjectOrderByRelationAggregateInput
    inspections?: InspectionOrderByRelationAggregateInput
    reviewedInspections?: InspectionOrderByRelationAggregateInput
    queries?: QueryOrderByRelationAggregateInput
    queryResponses?: QueryResponseOrderByRelationAggregateInput
    auditLogs?: AuditLogOrderByRelationAggregateInput
    notificationPrefs?: NotificationPreferenceOrderByWithRelationInput
    materialsCreated?: MaterialOrderByRelationAggregateInput
  }

  export type UserWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    email?: string
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    name?: StringFilter<"User"> | string
    passwordHash?: StringFilter<"User"> | string
    role?: EnumRoleFilter<"User"> | $Enums.Role
    isActive?: BoolFilter<"User"> | boolean
    createdById?: StringNullableFilter<"User"> | string | null
    createdAt?: DateTimeFilter<"User"> | Date | string
    phone?: StringNullableFilter<"User"> | string | null
    designation?: StringNullableFilter<"User"> | string | null
    createdBy?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    createdUsers?: UserListRelationFilter
    managedProjects?: ProjectListRelationFilter
    clientProjects?: ProjectListRelationFilter
    projectMembers?: ProjectMemberListRelationFilter
    projectUpdates?: ProjectUpdateListRelationFilter
    media?: MediaListRelationFilter
    paymentsCreated?: PaymentListRelationFilter
    notifications?: NotificationListRelationFilter
    projectsCreated?: ProjectListRelationFilter
    inspections?: InspectionListRelationFilter
    reviewedInspections?: InspectionListRelationFilter
    queries?: QueryListRelationFilter
    queryResponses?: QueryResponseListRelationFilter
    auditLogs?: AuditLogListRelationFilter
    notificationPrefs?: XOR<NotificationPreferenceNullableScalarRelationFilter, NotificationPreferenceWhereInput> | null
    materialsCreated?: MaterialListRelationFilter
  }, "id" | "email">

  export type UserOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    passwordHash?: SortOrder
    role?: SortOrder
    isActive?: SortOrder
    createdById?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    phone?: SortOrderInput | SortOrder
    designation?: SortOrderInput | SortOrder
    _count?: UserCountOrderByAggregateInput
    _max?: UserMaxOrderByAggregateInput
    _min?: UserMinOrderByAggregateInput
  }

  export type UserScalarWhereWithAggregatesInput = {
    AND?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    OR?: UserScalarWhereWithAggregatesInput[]
    NOT?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"User"> | string
    name?: StringWithAggregatesFilter<"User"> | string
    email?: StringWithAggregatesFilter<"User"> | string
    passwordHash?: StringWithAggregatesFilter<"User"> | string
    role?: EnumRoleWithAggregatesFilter<"User"> | $Enums.Role
    isActive?: BoolWithAggregatesFilter<"User"> | boolean
    createdById?: StringNullableWithAggregatesFilter<"User"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
    phone?: StringNullableWithAggregatesFilter<"User"> | string | null
    designation?: StringNullableWithAggregatesFilter<"User"> | string | null
  }

  export type ProjectWhereInput = {
    AND?: ProjectWhereInput | ProjectWhereInput[]
    OR?: ProjectWhereInput[]
    NOT?: ProjectWhereInput | ProjectWhereInput[]
    id?: StringFilter<"Project"> | string
    name?: StringFilter<"Project"> | string
    description?: StringNullableFilter<"Project"> | string | null
    status?: EnumProjectStatusFilter<"Project"> | $Enums.ProjectStatus
    isArchived?: BoolFilter<"Project"> | boolean
    createdById?: StringFilter<"Project"> | string
    managerId?: StringFilter<"Project"> | string
    clientId?: StringFilter<"Project"> | string
    createdAt?: DateTimeFilter<"Project"> | Date | string
    updatedAt?: DateTimeFilter<"Project"> | Date | string
    createdBy?: XOR<UserScalarRelationFilter, UserWhereInput>
    manager?: XOR<UserScalarRelationFilter, UserWhereInput>
    client?: XOR<UserScalarRelationFilter, UserWhereInput>
    members?: ProjectMemberListRelationFilter
    updates?: ProjectUpdateListRelationFilter
    media?: MediaListRelationFilter
    payments?: PaymentListRelationFilter
    milestones?: MilestoneListRelationFilter
    inspections?: InspectionListRelationFilter
    queries?: QueryListRelationFilter
    materials?: MaterialListRelationFilter
    auditLogs?: AuditLogListRelationFilter
  }

  export type ProjectOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    status?: SortOrder
    isArchived?: SortOrder
    createdById?: SortOrder
    managerId?: SortOrder
    clientId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdBy?: UserOrderByWithRelationInput
    manager?: UserOrderByWithRelationInput
    client?: UserOrderByWithRelationInput
    members?: ProjectMemberOrderByRelationAggregateInput
    updates?: ProjectUpdateOrderByRelationAggregateInput
    media?: MediaOrderByRelationAggregateInput
    payments?: PaymentOrderByRelationAggregateInput
    milestones?: MilestoneOrderByRelationAggregateInput
    inspections?: InspectionOrderByRelationAggregateInput
    queries?: QueryOrderByRelationAggregateInput
    materials?: MaterialOrderByRelationAggregateInput
    auditLogs?: AuditLogOrderByRelationAggregateInput
  }

  export type ProjectWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ProjectWhereInput | ProjectWhereInput[]
    OR?: ProjectWhereInput[]
    NOT?: ProjectWhereInput | ProjectWhereInput[]
    name?: StringFilter<"Project"> | string
    description?: StringNullableFilter<"Project"> | string | null
    status?: EnumProjectStatusFilter<"Project"> | $Enums.ProjectStatus
    isArchived?: BoolFilter<"Project"> | boolean
    createdById?: StringFilter<"Project"> | string
    managerId?: StringFilter<"Project"> | string
    clientId?: StringFilter<"Project"> | string
    createdAt?: DateTimeFilter<"Project"> | Date | string
    updatedAt?: DateTimeFilter<"Project"> | Date | string
    createdBy?: XOR<UserScalarRelationFilter, UserWhereInput>
    manager?: XOR<UserScalarRelationFilter, UserWhereInput>
    client?: XOR<UserScalarRelationFilter, UserWhereInput>
    members?: ProjectMemberListRelationFilter
    updates?: ProjectUpdateListRelationFilter
    media?: MediaListRelationFilter
    payments?: PaymentListRelationFilter
    milestones?: MilestoneListRelationFilter
    inspections?: InspectionListRelationFilter
    queries?: QueryListRelationFilter
    materials?: MaterialListRelationFilter
    auditLogs?: AuditLogListRelationFilter
  }, "id">

  export type ProjectOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    status?: SortOrder
    isArchived?: SortOrder
    createdById?: SortOrder
    managerId?: SortOrder
    clientId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ProjectCountOrderByAggregateInput
    _max?: ProjectMaxOrderByAggregateInput
    _min?: ProjectMinOrderByAggregateInput
  }

  export type ProjectScalarWhereWithAggregatesInput = {
    AND?: ProjectScalarWhereWithAggregatesInput | ProjectScalarWhereWithAggregatesInput[]
    OR?: ProjectScalarWhereWithAggregatesInput[]
    NOT?: ProjectScalarWhereWithAggregatesInput | ProjectScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Project"> | string
    name?: StringWithAggregatesFilter<"Project"> | string
    description?: StringNullableWithAggregatesFilter<"Project"> | string | null
    status?: EnumProjectStatusWithAggregatesFilter<"Project"> | $Enums.ProjectStatus
    isArchived?: BoolWithAggregatesFilter<"Project"> | boolean
    createdById?: StringWithAggregatesFilter<"Project"> | string
    managerId?: StringWithAggregatesFilter<"Project"> | string
    clientId?: StringWithAggregatesFilter<"Project"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Project"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Project"> | Date | string
  }

  export type ProjectMemberWhereInput = {
    AND?: ProjectMemberWhereInput | ProjectMemberWhereInput[]
    OR?: ProjectMemberWhereInput[]
    NOT?: ProjectMemberWhereInput | ProjectMemberWhereInput[]
    id?: StringFilter<"ProjectMember"> | string
    projectId?: StringFilter<"ProjectMember"> | string
    userId?: StringFilter<"ProjectMember"> | string
    role?: EnumProjectMemberRoleFilter<"ProjectMember"> | $Enums.ProjectMemberRole
    createdAt?: DateTimeFilter<"ProjectMember"> | Date | string
    project?: XOR<ProjectScalarRelationFilter, ProjectWhereInput>
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type ProjectMemberOrderByWithRelationInput = {
    id?: SortOrder
    projectId?: SortOrder
    userId?: SortOrder
    role?: SortOrder
    createdAt?: SortOrder
    project?: ProjectOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
  }

  export type ProjectMemberWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    projectId_userId?: ProjectMemberProjectIdUserIdCompoundUniqueInput
    AND?: ProjectMemberWhereInput | ProjectMemberWhereInput[]
    OR?: ProjectMemberWhereInput[]
    NOT?: ProjectMemberWhereInput | ProjectMemberWhereInput[]
    projectId?: StringFilter<"ProjectMember"> | string
    userId?: StringFilter<"ProjectMember"> | string
    role?: EnumProjectMemberRoleFilter<"ProjectMember"> | $Enums.ProjectMemberRole
    createdAt?: DateTimeFilter<"ProjectMember"> | Date | string
    project?: XOR<ProjectScalarRelationFilter, ProjectWhereInput>
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id" | "projectId_userId">

  export type ProjectMemberOrderByWithAggregationInput = {
    id?: SortOrder
    projectId?: SortOrder
    userId?: SortOrder
    role?: SortOrder
    createdAt?: SortOrder
    _count?: ProjectMemberCountOrderByAggregateInput
    _max?: ProjectMemberMaxOrderByAggregateInput
    _min?: ProjectMemberMinOrderByAggregateInput
  }

  export type ProjectMemberScalarWhereWithAggregatesInput = {
    AND?: ProjectMemberScalarWhereWithAggregatesInput | ProjectMemberScalarWhereWithAggregatesInput[]
    OR?: ProjectMemberScalarWhereWithAggregatesInput[]
    NOT?: ProjectMemberScalarWhereWithAggregatesInput | ProjectMemberScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ProjectMember"> | string
    projectId?: StringWithAggregatesFilter<"ProjectMember"> | string
    userId?: StringWithAggregatesFilter<"ProjectMember"> | string
    role?: EnumProjectMemberRoleWithAggregatesFilter<"ProjectMember"> | $Enums.ProjectMemberRole
    createdAt?: DateTimeWithAggregatesFilter<"ProjectMember"> | Date | string
  }

  export type ProjectUpdateWhereInput = {
    AND?: ProjectUpdateWhereInput | ProjectUpdateWhereInput[]
    OR?: ProjectUpdateWhereInput[]
    NOT?: ProjectUpdateWhereInput | ProjectUpdateWhereInput[]
    id?: StringFilter<"ProjectUpdate"> | string
    projectId?: StringFilter<"ProjectUpdate"> | string
    authorId?: StringFilter<"ProjectUpdate"> | string
    notes?: StringFilter<"ProjectUpdate"> | string
    statusSnapshot?: StringNullableFilter<"ProjectUpdate"> | string | null
    createdAt?: DateTimeFilter<"ProjectUpdate"> | Date | string
    project?: XOR<ProjectScalarRelationFilter, ProjectWhereInput>
    author?: XOR<UserScalarRelationFilter, UserWhereInput>
    media?: MediaListRelationFilter
  }

  export type ProjectUpdateOrderByWithRelationInput = {
    id?: SortOrder
    projectId?: SortOrder
    authorId?: SortOrder
    notes?: SortOrder
    statusSnapshot?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    project?: ProjectOrderByWithRelationInput
    author?: UserOrderByWithRelationInput
    media?: MediaOrderByRelationAggregateInput
  }

  export type ProjectUpdateWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ProjectUpdateWhereInput | ProjectUpdateWhereInput[]
    OR?: ProjectUpdateWhereInput[]
    NOT?: ProjectUpdateWhereInput | ProjectUpdateWhereInput[]
    projectId?: StringFilter<"ProjectUpdate"> | string
    authorId?: StringFilter<"ProjectUpdate"> | string
    notes?: StringFilter<"ProjectUpdate"> | string
    statusSnapshot?: StringNullableFilter<"ProjectUpdate"> | string | null
    createdAt?: DateTimeFilter<"ProjectUpdate"> | Date | string
    project?: XOR<ProjectScalarRelationFilter, ProjectWhereInput>
    author?: XOR<UserScalarRelationFilter, UserWhereInput>
    media?: MediaListRelationFilter
  }, "id">

  export type ProjectUpdateOrderByWithAggregationInput = {
    id?: SortOrder
    projectId?: SortOrder
    authorId?: SortOrder
    notes?: SortOrder
    statusSnapshot?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: ProjectUpdateCountOrderByAggregateInput
    _max?: ProjectUpdateMaxOrderByAggregateInput
    _min?: ProjectUpdateMinOrderByAggregateInput
  }

  export type ProjectUpdateScalarWhereWithAggregatesInput = {
    AND?: ProjectUpdateScalarWhereWithAggregatesInput | ProjectUpdateScalarWhereWithAggregatesInput[]
    OR?: ProjectUpdateScalarWhereWithAggregatesInput[]
    NOT?: ProjectUpdateScalarWhereWithAggregatesInput | ProjectUpdateScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ProjectUpdate"> | string
    projectId?: StringWithAggregatesFilter<"ProjectUpdate"> | string
    authorId?: StringWithAggregatesFilter<"ProjectUpdate"> | string
    notes?: StringWithAggregatesFilter<"ProjectUpdate"> | string
    statusSnapshot?: StringNullableWithAggregatesFilter<"ProjectUpdate"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"ProjectUpdate"> | Date | string
  }

  export type MediaWhereInput = {
    AND?: MediaWhereInput | MediaWhereInput[]
    OR?: MediaWhereInput[]
    NOT?: MediaWhereInput | MediaWhereInput[]
    id?: StringFilter<"Media"> | string
    projectId?: StringFilter<"Media"> | string
    projectUpdateId?: StringNullableFilter<"Media"> | string | null
    paymentId?: StringNullableFilter<"Media"> | string | null
    type?: EnumMediaTypeFilter<"Media"> | $Enums.MediaType
    fileKey?: StringFilter<"Media"> | string
    fileUrl?: StringFilter<"Media"> | string
    mimeType?: StringFilter<"Media"> | string
    fileSize?: IntFilter<"Media"> | number
    createdById?: StringFilter<"Media"> | string
    approvedBy?: StringNullableFilter<"Media"> | string | null
    approvedAt?: DateTimeNullableFilter<"Media"> | Date | string | null
    version?: IntNullableFilter<"Media"> | number | null
    createdAt?: DateTimeFilter<"Media"> | Date | string
    queryId?: StringNullableFilter<"Media"> | string | null
    project?: XOR<ProjectScalarRelationFilter, ProjectWhereInput>
    projectUpdate?: XOR<ProjectUpdateNullableScalarRelationFilter, ProjectUpdateWhereInput> | null
    payment?: XOR<PaymentNullableScalarRelationFilter, PaymentWhereInput> | null
    createdBy?: XOR<UserScalarRelationFilter, UserWhereInput>
    inspectionResponses?: InspectionResponseListRelationFilter
    query?: XOR<QueryNullableScalarRelationFilter, QueryWhereInput> | null
  }

  export type MediaOrderByWithRelationInput = {
    id?: SortOrder
    projectId?: SortOrder
    projectUpdateId?: SortOrderInput | SortOrder
    paymentId?: SortOrderInput | SortOrder
    type?: SortOrder
    fileKey?: SortOrder
    fileUrl?: SortOrder
    mimeType?: SortOrder
    fileSize?: SortOrder
    createdById?: SortOrder
    approvedBy?: SortOrderInput | SortOrder
    approvedAt?: SortOrderInput | SortOrder
    version?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    queryId?: SortOrderInput | SortOrder
    project?: ProjectOrderByWithRelationInput
    projectUpdate?: ProjectUpdateOrderByWithRelationInput
    payment?: PaymentOrderByWithRelationInput
    createdBy?: UserOrderByWithRelationInput
    inspectionResponses?: InspectionResponseOrderByRelationAggregateInput
    query?: QueryOrderByWithRelationInput
  }

  export type MediaWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: MediaWhereInput | MediaWhereInput[]
    OR?: MediaWhereInput[]
    NOT?: MediaWhereInput | MediaWhereInput[]
    projectId?: StringFilter<"Media"> | string
    projectUpdateId?: StringNullableFilter<"Media"> | string | null
    paymentId?: StringNullableFilter<"Media"> | string | null
    type?: EnumMediaTypeFilter<"Media"> | $Enums.MediaType
    fileKey?: StringFilter<"Media"> | string
    fileUrl?: StringFilter<"Media"> | string
    mimeType?: StringFilter<"Media"> | string
    fileSize?: IntFilter<"Media"> | number
    createdById?: StringFilter<"Media"> | string
    approvedBy?: StringNullableFilter<"Media"> | string | null
    approvedAt?: DateTimeNullableFilter<"Media"> | Date | string | null
    version?: IntNullableFilter<"Media"> | number | null
    createdAt?: DateTimeFilter<"Media"> | Date | string
    queryId?: StringNullableFilter<"Media"> | string | null
    project?: XOR<ProjectScalarRelationFilter, ProjectWhereInput>
    projectUpdate?: XOR<ProjectUpdateNullableScalarRelationFilter, ProjectUpdateWhereInput> | null
    payment?: XOR<PaymentNullableScalarRelationFilter, PaymentWhereInput> | null
    createdBy?: XOR<UserScalarRelationFilter, UserWhereInput>
    inspectionResponses?: InspectionResponseListRelationFilter
    query?: XOR<QueryNullableScalarRelationFilter, QueryWhereInput> | null
  }, "id">

  export type MediaOrderByWithAggregationInput = {
    id?: SortOrder
    projectId?: SortOrder
    projectUpdateId?: SortOrderInput | SortOrder
    paymentId?: SortOrderInput | SortOrder
    type?: SortOrder
    fileKey?: SortOrder
    fileUrl?: SortOrder
    mimeType?: SortOrder
    fileSize?: SortOrder
    createdById?: SortOrder
    approvedBy?: SortOrderInput | SortOrder
    approvedAt?: SortOrderInput | SortOrder
    version?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    queryId?: SortOrderInput | SortOrder
    _count?: MediaCountOrderByAggregateInput
    _avg?: MediaAvgOrderByAggregateInput
    _max?: MediaMaxOrderByAggregateInput
    _min?: MediaMinOrderByAggregateInput
    _sum?: MediaSumOrderByAggregateInput
  }

  export type MediaScalarWhereWithAggregatesInput = {
    AND?: MediaScalarWhereWithAggregatesInput | MediaScalarWhereWithAggregatesInput[]
    OR?: MediaScalarWhereWithAggregatesInput[]
    NOT?: MediaScalarWhereWithAggregatesInput | MediaScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Media"> | string
    projectId?: StringWithAggregatesFilter<"Media"> | string
    projectUpdateId?: StringNullableWithAggregatesFilter<"Media"> | string | null
    paymentId?: StringNullableWithAggregatesFilter<"Media"> | string | null
    type?: EnumMediaTypeWithAggregatesFilter<"Media"> | $Enums.MediaType
    fileKey?: StringWithAggregatesFilter<"Media"> | string
    fileUrl?: StringWithAggregatesFilter<"Media"> | string
    mimeType?: StringWithAggregatesFilter<"Media"> | string
    fileSize?: IntWithAggregatesFilter<"Media"> | number
    createdById?: StringWithAggregatesFilter<"Media"> | string
    approvedBy?: StringNullableWithAggregatesFilter<"Media"> | string | null
    approvedAt?: DateTimeNullableWithAggregatesFilter<"Media"> | Date | string | null
    version?: IntNullableWithAggregatesFilter<"Media"> | number | null
    createdAt?: DateTimeWithAggregatesFilter<"Media"> | Date | string
    queryId?: StringNullableWithAggregatesFilter<"Media"> | string | null
  }

  export type PaymentWhereInput = {
    AND?: PaymentWhereInput | PaymentWhereInput[]
    OR?: PaymentWhereInput[]
    NOT?: PaymentWhereInput | PaymentWhereInput[]
    id?: StringFilter<"Payment"> | string
    projectId?: StringFilter<"Payment"> | string
    createdById?: StringFilter<"Payment"> | string
    amount?: DecimalFilter<"Payment"> | Decimal | DecimalJsLike | number | string
    currency?: StringFilter<"Payment"> | string
    status?: EnumPaymentStatusFilter<"Payment"> | $Enums.PaymentStatus
    category?: EnumPaymentCategoryNullableFilter<"Payment"> | $Enums.PaymentCategory | null
    invoiceNumber?: StringNullableFilter<"Payment"> | string | null
    paidAt?: DateTimeNullableFilter<"Payment"> | Date | string | null
    dueDate?: DateTimeNullableFilter<"Payment"> | Date | string | null
    notes?: StringNullableFilter<"Payment"> | string | null
    createdAt?: DateTimeFilter<"Payment"> | Date | string
    updatedAt?: DateTimeFilter<"Payment"> | Date | string
    project?: XOR<ProjectScalarRelationFilter, ProjectWhereInput>
    createdBy?: XOR<UserScalarRelationFilter, UserWhereInput>
    media?: MediaListRelationFilter
  }

  export type PaymentOrderByWithRelationInput = {
    id?: SortOrder
    projectId?: SortOrder
    createdById?: SortOrder
    amount?: SortOrder
    currency?: SortOrder
    status?: SortOrder
    category?: SortOrderInput | SortOrder
    invoiceNumber?: SortOrderInput | SortOrder
    paidAt?: SortOrderInput | SortOrder
    dueDate?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    project?: ProjectOrderByWithRelationInput
    createdBy?: UserOrderByWithRelationInput
    media?: MediaOrderByRelationAggregateInput
  }

  export type PaymentWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: PaymentWhereInput | PaymentWhereInput[]
    OR?: PaymentWhereInput[]
    NOT?: PaymentWhereInput | PaymentWhereInput[]
    projectId?: StringFilter<"Payment"> | string
    createdById?: StringFilter<"Payment"> | string
    amount?: DecimalFilter<"Payment"> | Decimal | DecimalJsLike | number | string
    currency?: StringFilter<"Payment"> | string
    status?: EnumPaymentStatusFilter<"Payment"> | $Enums.PaymentStatus
    category?: EnumPaymentCategoryNullableFilter<"Payment"> | $Enums.PaymentCategory | null
    invoiceNumber?: StringNullableFilter<"Payment"> | string | null
    paidAt?: DateTimeNullableFilter<"Payment"> | Date | string | null
    dueDate?: DateTimeNullableFilter<"Payment"> | Date | string | null
    notes?: StringNullableFilter<"Payment"> | string | null
    createdAt?: DateTimeFilter<"Payment"> | Date | string
    updatedAt?: DateTimeFilter<"Payment"> | Date | string
    project?: XOR<ProjectScalarRelationFilter, ProjectWhereInput>
    createdBy?: XOR<UserScalarRelationFilter, UserWhereInput>
    media?: MediaListRelationFilter
  }, "id">

  export type PaymentOrderByWithAggregationInput = {
    id?: SortOrder
    projectId?: SortOrder
    createdById?: SortOrder
    amount?: SortOrder
    currency?: SortOrder
    status?: SortOrder
    category?: SortOrderInput | SortOrder
    invoiceNumber?: SortOrderInput | SortOrder
    paidAt?: SortOrderInput | SortOrder
    dueDate?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: PaymentCountOrderByAggregateInput
    _avg?: PaymentAvgOrderByAggregateInput
    _max?: PaymentMaxOrderByAggregateInput
    _min?: PaymentMinOrderByAggregateInput
    _sum?: PaymentSumOrderByAggregateInput
  }

  export type PaymentScalarWhereWithAggregatesInput = {
    AND?: PaymentScalarWhereWithAggregatesInput | PaymentScalarWhereWithAggregatesInput[]
    OR?: PaymentScalarWhereWithAggregatesInput[]
    NOT?: PaymentScalarWhereWithAggregatesInput | PaymentScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Payment"> | string
    projectId?: StringWithAggregatesFilter<"Payment"> | string
    createdById?: StringWithAggregatesFilter<"Payment"> | string
    amount?: DecimalWithAggregatesFilter<"Payment"> | Decimal | DecimalJsLike | number | string
    currency?: StringWithAggregatesFilter<"Payment"> | string
    status?: EnumPaymentStatusWithAggregatesFilter<"Payment"> | $Enums.PaymentStatus
    category?: EnumPaymentCategoryNullableWithAggregatesFilter<"Payment"> | $Enums.PaymentCategory | null
    invoiceNumber?: StringNullableWithAggregatesFilter<"Payment"> | string | null
    paidAt?: DateTimeNullableWithAggregatesFilter<"Payment"> | Date | string | null
    dueDate?: DateTimeNullableWithAggregatesFilter<"Payment"> | Date | string | null
    notes?: StringNullableWithAggregatesFilter<"Payment"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Payment"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Payment"> | Date | string
  }

  export type NotificationWhereInput = {
    AND?: NotificationWhereInput | NotificationWhereInput[]
    OR?: NotificationWhereInput[]
    NOT?: NotificationWhereInput | NotificationWhereInput[]
    id?: StringFilter<"Notification"> | string
    userId?: StringFilter<"Notification"> | string
    title?: StringFilter<"Notification"> | string
    message?: StringFilter<"Notification"> | string
    type?: StringFilter<"Notification"> | string
    priority?: EnumNotificationPriorityFilter<"Notification"> | $Enums.NotificationPriority
    actionUrl?: StringNullableFilter<"Notification"> | string | null
    isRead?: BoolFilter<"Notification"> | boolean
    createdAt?: DateTimeFilter<"Notification"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type NotificationOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    title?: SortOrder
    message?: SortOrder
    type?: SortOrder
    priority?: SortOrder
    actionUrl?: SortOrderInput | SortOrder
    isRead?: SortOrder
    createdAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type NotificationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: NotificationWhereInput | NotificationWhereInput[]
    OR?: NotificationWhereInput[]
    NOT?: NotificationWhereInput | NotificationWhereInput[]
    userId?: StringFilter<"Notification"> | string
    title?: StringFilter<"Notification"> | string
    message?: StringFilter<"Notification"> | string
    type?: StringFilter<"Notification"> | string
    priority?: EnumNotificationPriorityFilter<"Notification"> | $Enums.NotificationPriority
    actionUrl?: StringNullableFilter<"Notification"> | string | null
    isRead?: BoolFilter<"Notification"> | boolean
    createdAt?: DateTimeFilter<"Notification"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id">

  export type NotificationOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    title?: SortOrder
    message?: SortOrder
    type?: SortOrder
    priority?: SortOrder
    actionUrl?: SortOrderInput | SortOrder
    isRead?: SortOrder
    createdAt?: SortOrder
    _count?: NotificationCountOrderByAggregateInput
    _max?: NotificationMaxOrderByAggregateInput
    _min?: NotificationMinOrderByAggregateInput
  }

  export type NotificationScalarWhereWithAggregatesInput = {
    AND?: NotificationScalarWhereWithAggregatesInput | NotificationScalarWhereWithAggregatesInput[]
    OR?: NotificationScalarWhereWithAggregatesInput[]
    NOT?: NotificationScalarWhereWithAggregatesInput | NotificationScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Notification"> | string
    userId?: StringWithAggregatesFilter<"Notification"> | string
    title?: StringWithAggregatesFilter<"Notification"> | string
    message?: StringWithAggregatesFilter<"Notification"> | string
    type?: StringWithAggregatesFilter<"Notification"> | string
    priority?: EnumNotificationPriorityWithAggregatesFilter<"Notification"> | $Enums.NotificationPriority
    actionUrl?: StringNullableWithAggregatesFilter<"Notification"> | string | null
    isRead?: BoolWithAggregatesFilter<"Notification"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"Notification"> | Date | string
  }

  export type NotificationPreferenceWhereInput = {
    AND?: NotificationPreferenceWhereInput | NotificationPreferenceWhereInput[]
    OR?: NotificationPreferenceWhereInput[]
    NOT?: NotificationPreferenceWhereInput | NotificationPreferenceWhereInput[]
    id?: StringFilter<"NotificationPreference"> | string
    userId?: StringFilter<"NotificationPreference"> | string
    inspectionSubmitted?: BoolFilter<"NotificationPreference"> | boolean
    paymentOverdue?: BoolFilter<"NotificationPreference"> | boolean
    newAssignment?: BoolFilter<"NotificationPreference"> | boolean
    queryCreated?: BoolFilter<"NotificationPreference"> | boolean
    drawingApproved?: BoolFilter<"NotificationPreference"> | boolean
    emailEnabled?: BoolFilter<"NotificationPreference"> | boolean
    inAppEnabled?: BoolFilter<"NotificationPreference"> | boolean
    updatedAt?: DateTimeFilter<"NotificationPreference"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type NotificationPreferenceOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    inspectionSubmitted?: SortOrder
    paymentOverdue?: SortOrder
    newAssignment?: SortOrder
    queryCreated?: SortOrder
    drawingApproved?: SortOrder
    emailEnabled?: SortOrder
    inAppEnabled?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type NotificationPreferenceWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId?: string
    AND?: NotificationPreferenceWhereInput | NotificationPreferenceWhereInput[]
    OR?: NotificationPreferenceWhereInput[]
    NOT?: NotificationPreferenceWhereInput | NotificationPreferenceWhereInput[]
    inspectionSubmitted?: BoolFilter<"NotificationPreference"> | boolean
    paymentOverdue?: BoolFilter<"NotificationPreference"> | boolean
    newAssignment?: BoolFilter<"NotificationPreference"> | boolean
    queryCreated?: BoolFilter<"NotificationPreference"> | boolean
    drawingApproved?: BoolFilter<"NotificationPreference"> | boolean
    emailEnabled?: BoolFilter<"NotificationPreference"> | boolean
    inAppEnabled?: BoolFilter<"NotificationPreference"> | boolean
    updatedAt?: DateTimeFilter<"NotificationPreference"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id" | "userId">

  export type NotificationPreferenceOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    inspectionSubmitted?: SortOrder
    paymentOverdue?: SortOrder
    newAssignment?: SortOrder
    queryCreated?: SortOrder
    drawingApproved?: SortOrder
    emailEnabled?: SortOrder
    inAppEnabled?: SortOrder
    updatedAt?: SortOrder
    _count?: NotificationPreferenceCountOrderByAggregateInput
    _max?: NotificationPreferenceMaxOrderByAggregateInput
    _min?: NotificationPreferenceMinOrderByAggregateInput
  }

  export type NotificationPreferenceScalarWhereWithAggregatesInput = {
    AND?: NotificationPreferenceScalarWhereWithAggregatesInput | NotificationPreferenceScalarWhereWithAggregatesInput[]
    OR?: NotificationPreferenceScalarWhereWithAggregatesInput[]
    NOT?: NotificationPreferenceScalarWhereWithAggregatesInput | NotificationPreferenceScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"NotificationPreference"> | string
    userId?: StringWithAggregatesFilter<"NotificationPreference"> | string
    inspectionSubmitted?: BoolWithAggregatesFilter<"NotificationPreference"> | boolean
    paymentOverdue?: BoolWithAggregatesFilter<"NotificationPreference"> | boolean
    newAssignment?: BoolWithAggregatesFilter<"NotificationPreference"> | boolean
    queryCreated?: BoolWithAggregatesFilter<"NotificationPreference"> | boolean
    drawingApproved?: BoolWithAggregatesFilter<"NotificationPreference"> | boolean
    emailEnabled?: BoolWithAggregatesFilter<"NotificationPreference"> | boolean
    inAppEnabled?: BoolWithAggregatesFilter<"NotificationPreference"> | boolean
    updatedAt?: DateTimeWithAggregatesFilter<"NotificationPreference"> | Date | string
  }

  export type MilestoneWhereInput = {
    AND?: MilestoneWhereInput | MilestoneWhereInput[]
    OR?: MilestoneWhereInput[]
    NOT?: MilestoneWhereInput | MilestoneWhereInput[]
    id?: StringFilter<"Milestone"> | string
    name?: StringFilter<"Milestone"> | string
    description?: StringNullableFilter<"Milestone"> | string | null
    order?: IntFilter<"Milestone"> | number
    isActive?: BoolFilter<"Milestone"> | boolean
    projectId?: StringFilter<"Milestone"> | string
    createdAt?: DateTimeFilter<"Milestone"> | Date | string
    updatedAt?: DateTimeFilter<"Milestone"> | Date | string
    project?: XOR<ProjectScalarRelationFilter, ProjectWhereInput>
    checklistItems?: ChecklistItemListRelationFilter
    inspections?: InspectionListRelationFilter
  }

  export type MilestoneOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    order?: SortOrder
    isActive?: SortOrder
    projectId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    project?: ProjectOrderByWithRelationInput
    checklistItems?: ChecklistItemOrderByRelationAggregateInput
    inspections?: InspectionOrderByRelationAggregateInput
  }

  export type MilestoneWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: MilestoneWhereInput | MilestoneWhereInput[]
    OR?: MilestoneWhereInput[]
    NOT?: MilestoneWhereInput | MilestoneWhereInput[]
    name?: StringFilter<"Milestone"> | string
    description?: StringNullableFilter<"Milestone"> | string | null
    order?: IntFilter<"Milestone"> | number
    isActive?: BoolFilter<"Milestone"> | boolean
    projectId?: StringFilter<"Milestone"> | string
    createdAt?: DateTimeFilter<"Milestone"> | Date | string
    updatedAt?: DateTimeFilter<"Milestone"> | Date | string
    project?: XOR<ProjectScalarRelationFilter, ProjectWhereInput>
    checklistItems?: ChecklistItemListRelationFilter
    inspections?: InspectionListRelationFilter
  }, "id">

  export type MilestoneOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    order?: SortOrder
    isActive?: SortOrder
    projectId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: MilestoneCountOrderByAggregateInput
    _avg?: MilestoneAvgOrderByAggregateInput
    _max?: MilestoneMaxOrderByAggregateInput
    _min?: MilestoneMinOrderByAggregateInput
    _sum?: MilestoneSumOrderByAggregateInput
  }

  export type MilestoneScalarWhereWithAggregatesInput = {
    AND?: MilestoneScalarWhereWithAggregatesInput | MilestoneScalarWhereWithAggregatesInput[]
    OR?: MilestoneScalarWhereWithAggregatesInput[]
    NOT?: MilestoneScalarWhereWithAggregatesInput | MilestoneScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Milestone"> | string
    name?: StringWithAggregatesFilter<"Milestone"> | string
    description?: StringNullableWithAggregatesFilter<"Milestone"> | string | null
    order?: IntWithAggregatesFilter<"Milestone"> | number
    isActive?: BoolWithAggregatesFilter<"Milestone"> | boolean
    projectId?: StringWithAggregatesFilter<"Milestone"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Milestone"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Milestone"> | Date | string
  }

  export type ChecklistItemWhereInput = {
    AND?: ChecklistItemWhereInput | ChecklistItemWhereInput[]
    OR?: ChecklistItemWhereInput[]
    NOT?: ChecklistItemWhereInput | ChecklistItemWhereInput[]
    id?: StringFilter<"ChecklistItem"> | string
    title?: StringFilter<"ChecklistItem"> | string
    description?: StringNullableFilter<"ChecklistItem"> | string | null
    order?: IntFilter<"ChecklistItem"> | number
    isRequired?: BoolFilter<"ChecklistItem"> | boolean
    isPhotoRequired?: BoolFilter<"ChecklistItem"> | boolean
    milestoneId?: StringFilter<"ChecklistItem"> | string
    createdAt?: DateTimeFilter<"ChecklistItem"> | Date | string
    updatedAt?: DateTimeFilter<"ChecklistItem"> | Date | string
    milestone?: XOR<MilestoneScalarRelationFilter, MilestoneWhereInput>
    responses?: InspectionResponseListRelationFilter
  }

  export type ChecklistItemOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    order?: SortOrder
    isRequired?: SortOrder
    isPhotoRequired?: SortOrder
    milestoneId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    milestone?: MilestoneOrderByWithRelationInput
    responses?: InspectionResponseOrderByRelationAggregateInput
  }

  export type ChecklistItemWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ChecklistItemWhereInput | ChecklistItemWhereInput[]
    OR?: ChecklistItemWhereInput[]
    NOT?: ChecklistItemWhereInput | ChecklistItemWhereInput[]
    title?: StringFilter<"ChecklistItem"> | string
    description?: StringNullableFilter<"ChecklistItem"> | string | null
    order?: IntFilter<"ChecklistItem"> | number
    isRequired?: BoolFilter<"ChecklistItem"> | boolean
    isPhotoRequired?: BoolFilter<"ChecklistItem"> | boolean
    milestoneId?: StringFilter<"ChecklistItem"> | string
    createdAt?: DateTimeFilter<"ChecklistItem"> | Date | string
    updatedAt?: DateTimeFilter<"ChecklistItem"> | Date | string
    milestone?: XOR<MilestoneScalarRelationFilter, MilestoneWhereInput>
    responses?: InspectionResponseListRelationFilter
  }, "id">

  export type ChecklistItemOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    order?: SortOrder
    isRequired?: SortOrder
    isPhotoRequired?: SortOrder
    milestoneId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ChecklistItemCountOrderByAggregateInput
    _avg?: ChecklistItemAvgOrderByAggregateInput
    _max?: ChecklistItemMaxOrderByAggregateInput
    _min?: ChecklistItemMinOrderByAggregateInput
    _sum?: ChecklistItemSumOrderByAggregateInput
  }

  export type ChecklistItemScalarWhereWithAggregatesInput = {
    AND?: ChecklistItemScalarWhereWithAggregatesInput | ChecklistItemScalarWhereWithAggregatesInput[]
    OR?: ChecklistItemScalarWhereWithAggregatesInput[]
    NOT?: ChecklistItemScalarWhereWithAggregatesInput | ChecklistItemScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ChecklistItem"> | string
    title?: StringWithAggregatesFilter<"ChecklistItem"> | string
    description?: StringNullableWithAggregatesFilter<"ChecklistItem"> | string | null
    order?: IntWithAggregatesFilter<"ChecklistItem"> | number
    isRequired?: BoolWithAggregatesFilter<"ChecklistItem"> | boolean
    isPhotoRequired?: BoolWithAggregatesFilter<"ChecklistItem"> | boolean
    milestoneId?: StringWithAggregatesFilter<"ChecklistItem"> | string
    createdAt?: DateTimeWithAggregatesFilter<"ChecklistItem"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"ChecklistItem"> | Date | string
  }

  export type InspectionWhereInput = {
    AND?: InspectionWhereInput | InspectionWhereInput[]
    OR?: InspectionWhereInput[]
    NOT?: InspectionWhereInput | InspectionWhereInput[]
    id?: StringFilter<"Inspection"> | string
    status?: EnumInspectionStatusFilter<"Inspection"> | $Enums.InspectionStatus
    projectId?: StringFilter<"Inspection"> | string
    milestoneId?: StringFilter<"Inspection"> | string
    engineerId?: StringFilter<"Inspection"> | string
    reviewedById?: StringNullableFilter<"Inspection"> | string | null
    createdAt?: DateTimeFilter<"Inspection"> | Date | string
    updatedAt?: DateTimeFilter<"Inspection"> | Date | string
    project?: XOR<ProjectScalarRelationFilter, ProjectWhereInput>
    milestone?: XOR<MilestoneScalarRelationFilter, MilestoneWhereInput>
    engineer?: XOR<UserScalarRelationFilter, UserWhereInput>
    responses?: InspectionResponseListRelationFilter
    reviewedBy?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
  }

  export type InspectionOrderByWithRelationInput = {
    id?: SortOrder
    status?: SortOrder
    projectId?: SortOrder
    milestoneId?: SortOrder
    engineerId?: SortOrder
    reviewedById?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    project?: ProjectOrderByWithRelationInput
    milestone?: MilestoneOrderByWithRelationInput
    engineer?: UserOrderByWithRelationInput
    responses?: InspectionResponseOrderByRelationAggregateInput
    reviewedBy?: UserOrderByWithRelationInput
  }

  export type InspectionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    milestoneId_engineerId_status?: InspectionMilestoneIdEngineerIdStatusCompoundUniqueInput
    AND?: InspectionWhereInput | InspectionWhereInput[]
    OR?: InspectionWhereInput[]
    NOT?: InspectionWhereInput | InspectionWhereInput[]
    status?: EnumInspectionStatusFilter<"Inspection"> | $Enums.InspectionStatus
    projectId?: StringFilter<"Inspection"> | string
    milestoneId?: StringFilter<"Inspection"> | string
    engineerId?: StringFilter<"Inspection"> | string
    reviewedById?: StringNullableFilter<"Inspection"> | string | null
    createdAt?: DateTimeFilter<"Inspection"> | Date | string
    updatedAt?: DateTimeFilter<"Inspection"> | Date | string
    project?: XOR<ProjectScalarRelationFilter, ProjectWhereInput>
    milestone?: XOR<MilestoneScalarRelationFilter, MilestoneWhereInput>
    engineer?: XOR<UserScalarRelationFilter, UserWhereInput>
    responses?: InspectionResponseListRelationFilter
    reviewedBy?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
  }, "id" | "milestoneId_engineerId_status">

  export type InspectionOrderByWithAggregationInput = {
    id?: SortOrder
    status?: SortOrder
    projectId?: SortOrder
    milestoneId?: SortOrder
    engineerId?: SortOrder
    reviewedById?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: InspectionCountOrderByAggregateInput
    _max?: InspectionMaxOrderByAggregateInput
    _min?: InspectionMinOrderByAggregateInput
  }

  export type InspectionScalarWhereWithAggregatesInput = {
    AND?: InspectionScalarWhereWithAggregatesInput | InspectionScalarWhereWithAggregatesInput[]
    OR?: InspectionScalarWhereWithAggregatesInput[]
    NOT?: InspectionScalarWhereWithAggregatesInput | InspectionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Inspection"> | string
    status?: EnumInspectionStatusWithAggregatesFilter<"Inspection"> | $Enums.InspectionStatus
    projectId?: StringWithAggregatesFilter<"Inspection"> | string
    milestoneId?: StringWithAggregatesFilter<"Inspection"> | string
    engineerId?: StringWithAggregatesFilter<"Inspection"> | string
    reviewedById?: StringNullableWithAggregatesFilter<"Inspection"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Inspection"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Inspection"> | Date | string
  }

  export type InspectionResponseWhereInput = {
    AND?: InspectionResponseWhereInput | InspectionResponseWhereInput[]
    OR?: InspectionResponseWhereInput[]
    NOT?: InspectionResponseWhereInput | InspectionResponseWhereInput[]
    id?: StringFilter<"InspectionResponse"> | string
    result?: EnumChecklistResultFilter<"InspectionResponse"> | $Enums.ChecklistResult
    remark?: StringNullableFilter<"InspectionResponse"> | string | null
    inspectionId?: StringFilter<"InspectionResponse"> | string
    checklistItemId?: StringFilter<"InspectionResponse"> | string
    mediaId?: StringNullableFilter<"InspectionResponse"> | string | null
    inspection?: XOR<InspectionScalarRelationFilter, InspectionWhereInput>
    checklistItem?: XOR<ChecklistItemScalarRelationFilter, ChecklistItemWhereInput>
    media?: XOR<MediaNullableScalarRelationFilter, MediaWhereInput> | null
  }

  export type InspectionResponseOrderByWithRelationInput = {
    id?: SortOrder
    result?: SortOrder
    remark?: SortOrderInput | SortOrder
    inspectionId?: SortOrder
    checklistItemId?: SortOrder
    mediaId?: SortOrderInput | SortOrder
    inspection?: InspectionOrderByWithRelationInput
    checklistItem?: ChecklistItemOrderByWithRelationInput
    media?: MediaOrderByWithRelationInput
  }

  export type InspectionResponseWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: InspectionResponseWhereInput | InspectionResponseWhereInput[]
    OR?: InspectionResponseWhereInput[]
    NOT?: InspectionResponseWhereInput | InspectionResponseWhereInput[]
    result?: EnumChecklistResultFilter<"InspectionResponse"> | $Enums.ChecklistResult
    remark?: StringNullableFilter<"InspectionResponse"> | string | null
    inspectionId?: StringFilter<"InspectionResponse"> | string
    checklistItemId?: StringFilter<"InspectionResponse"> | string
    mediaId?: StringNullableFilter<"InspectionResponse"> | string | null
    inspection?: XOR<InspectionScalarRelationFilter, InspectionWhereInput>
    checklistItem?: XOR<ChecklistItemScalarRelationFilter, ChecklistItemWhereInput>
    media?: XOR<MediaNullableScalarRelationFilter, MediaWhereInput> | null
  }, "id">

  export type InspectionResponseOrderByWithAggregationInput = {
    id?: SortOrder
    result?: SortOrder
    remark?: SortOrderInput | SortOrder
    inspectionId?: SortOrder
    checklistItemId?: SortOrder
    mediaId?: SortOrderInput | SortOrder
    _count?: InspectionResponseCountOrderByAggregateInput
    _max?: InspectionResponseMaxOrderByAggregateInput
    _min?: InspectionResponseMinOrderByAggregateInput
  }

  export type InspectionResponseScalarWhereWithAggregatesInput = {
    AND?: InspectionResponseScalarWhereWithAggregatesInput | InspectionResponseScalarWhereWithAggregatesInput[]
    OR?: InspectionResponseScalarWhereWithAggregatesInput[]
    NOT?: InspectionResponseScalarWhereWithAggregatesInput | InspectionResponseScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"InspectionResponse"> | string
    result?: EnumChecklistResultWithAggregatesFilter<"InspectionResponse"> | $Enums.ChecklistResult
    remark?: StringNullableWithAggregatesFilter<"InspectionResponse"> | string | null
    inspectionId?: StringWithAggregatesFilter<"InspectionResponse"> | string
    checklistItemId?: StringWithAggregatesFilter<"InspectionResponse"> | string
    mediaId?: StringNullableWithAggregatesFilter<"InspectionResponse"> | string | null
  }

  export type QueryWhereInput = {
    AND?: QueryWhereInput | QueryWhereInput[]
    OR?: QueryWhereInput[]
    NOT?: QueryWhereInput | QueryWhereInput[]
    id?: StringFilter<"Query"> | string
    projectId?: StringFilter<"Query"> | string
    authorId?: StringFilter<"Query"> | string
    title?: StringFilter<"Query"> | string
    description?: StringFilter<"Query"> | string
    status?: EnumQueryStatusFilter<"Query"> | $Enums.QueryStatus
    priority?: EnumQueryPriorityFilter<"Query"> | $Enums.QueryPriority
    createdAt?: DateTimeFilter<"Query"> | Date | string
    updatedAt?: DateTimeFilter<"Query"> | Date | string
    project?: XOR<ProjectScalarRelationFilter, ProjectWhereInput>
    author?: XOR<UserScalarRelationFilter, UserWhereInput>
    attachments?: MediaListRelationFilter
    responses?: QueryResponseListRelationFilter
  }

  export type QueryOrderByWithRelationInput = {
    id?: SortOrder
    projectId?: SortOrder
    authorId?: SortOrder
    title?: SortOrder
    description?: SortOrder
    status?: SortOrder
    priority?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    project?: ProjectOrderByWithRelationInput
    author?: UserOrderByWithRelationInput
    attachments?: MediaOrderByRelationAggregateInput
    responses?: QueryResponseOrderByRelationAggregateInput
  }

  export type QueryWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: QueryWhereInput | QueryWhereInput[]
    OR?: QueryWhereInput[]
    NOT?: QueryWhereInput | QueryWhereInput[]
    projectId?: StringFilter<"Query"> | string
    authorId?: StringFilter<"Query"> | string
    title?: StringFilter<"Query"> | string
    description?: StringFilter<"Query"> | string
    status?: EnumQueryStatusFilter<"Query"> | $Enums.QueryStatus
    priority?: EnumQueryPriorityFilter<"Query"> | $Enums.QueryPriority
    createdAt?: DateTimeFilter<"Query"> | Date | string
    updatedAt?: DateTimeFilter<"Query"> | Date | string
    project?: XOR<ProjectScalarRelationFilter, ProjectWhereInput>
    author?: XOR<UserScalarRelationFilter, UserWhereInput>
    attachments?: MediaListRelationFilter
    responses?: QueryResponseListRelationFilter
  }, "id">

  export type QueryOrderByWithAggregationInput = {
    id?: SortOrder
    projectId?: SortOrder
    authorId?: SortOrder
    title?: SortOrder
    description?: SortOrder
    status?: SortOrder
    priority?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: QueryCountOrderByAggregateInput
    _max?: QueryMaxOrderByAggregateInput
    _min?: QueryMinOrderByAggregateInput
  }

  export type QueryScalarWhereWithAggregatesInput = {
    AND?: QueryScalarWhereWithAggregatesInput | QueryScalarWhereWithAggregatesInput[]
    OR?: QueryScalarWhereWithAggregatesInput[]
    NOT?: QueryScalarWhereWithAggregatesInput | QueryScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Query"> | string
    projectId?: StringWithAggregatesFilter<"Query"> | string
    authorId?: StringWithAggregatesFilter<"Query"> | string
    title?: StringWithAggregatesFilter<"Query"> | string
    description?: StringWithAggregatesFilter<"Query"> | string
    status?: EnumQueryStatusWithAggregatesFilter<"Query"> | $Enums.QueryStatus
    priority?: EnumQueryPriorityWithAggregatesFilter<"Query"> | $Enums.QueryPriority
    createdAt?: DateTimeWithAggregatesFilter<"Query"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Query"> | Date | string
  }

  export type QueryResponseWhereInput = {
    AND?: QueryResponseWhereInput | QueryResponseWhereInput[]
    OR?: QueryResponseWhereInput[]
    NOT?: QueryResponseWhereInput | QueryResponseWhereInput[]
    id?: StringFilter<"QueryResponse"> | string
    queryId?: StringFilter<"QueryResponse"> | string
    authorId?: StringFilter<"QueryResponse"> | string
    message?: StringFilter<"QueryResponse"> | string
    createdAt?: DateTimeFilter<"QueryResponse"> | Date | string
    query?: XOR<QueryScalarRelationFilter, QueryWhereInput>
    author?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type QueryResponseOrderByWithRelationInput = {
    id?: SortOrder
    queryId?: SortOrder
    authorId?: SortOrder
    message?: SortOrder
    createdAt?: SortOrder
    query?: QueryOrderByWithRelationInput
    author?: UserOrderByWithRelationInput
  }

  export type QueryResponseWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: QueryResponseWhereInput | QueryResponseWhereInput[]
    OR?: QueryResponseWhereInput[]
    NOT?: QueryResponseWhereInput | QueryResponseWhereInput[]
    queryId?: StringFilter<"QueryResponse"> | string
    authorId?: StringFilter<"QueryResponse"> | string
    message?: StringFilter<"QueryResponse"> | string
    createdAt?: DateTimeFilter<"QueryResponse"> | Date | string
    query?: XOR<QueryScalarRelationFilter, QueryWhereInput>
    author?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id">

  export type QueryResponseOrderByWithAggregationInput = {
    id?: SortOrder
    queryId?: SortOrder
    authorId?: SortOrder
    message?: SortOrder
    createdAt?: SortOrder
    _count?: QueryResponseCountOrderByAggregateInput
    _max?: QueryResponseMaxOrderByAggregateInput
    _min?: QueryResponseMinOrderByAggregateInput
  }

  export type QueryResponseScalarWhereWithAggregatesInput = {
    AND?: QueryResponseScalarWhereWithAggregatesInput | QueryResponseScalarWhereWithAggregatesInput[]
    OR?: QueryResponseScalarWhereWithAggregatesInput[]
    NOT?: QueryResponseScalarWhereWithAggregatesInput | QueryResponseScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"QueryResponse"> | string
    queryId?: StringWithAggregatesFilter<"QueryResponse"> | string
    authorId?: StringWithAggregatesFilter<"QueryResponse"> | string
    message?: StringWithAggregatesFilter<"QueryResponse"> | string
    createdAt?: DateTimeWithAggregatesFilter<"QueryResponse"> | Date | string
  }

  export type AuditLogWhereInput = {
    AND?: AuditLogWhereInput | AuditLogWhereInput[]
    OR?: AuditLogWhereInput[]
    NOT?: AuditLogWhereInput | AuditLogWhereInput[]
    id?: StringFilter<"AuditLog"> | string
    userId?: StringFilter<"AuditLog"> | string
    action?: StringFilter<"AuditLog"> | string
    entity?: StringFilter<"AuditLog"> | string
    entityId?: StringFilter<"AuditLog"> | string
    projectId?: StringNullableFilter<"AuditLog"> | string | null
    metadata?: JsonNullableFilter<"AuditLog">
    createdAt?: DateTimeFilter<"AuditLog"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    project?: XOR<ProjectNullableScalarRelationFilter, ProjectWhereInput> | null
  }

  export type AuditLogOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    action?: SortOrder
    entity?: SortOrder
    entityId?: SortOrder
    projectId?: SortOrderInput | SortOrder
    metadata?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    user?: UserOrderByWithRelationInput
    project?: ProjectOrderByWithRelationInput
  }

  export type AuditLogWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: AuditLogWhereInput | AuditLogWhereInput[]
    OR?: AuditLogWhereInput[]
    NOT?: AuditLogWhereInput | AuditLogWhereInput[]
    userId?: StringFilter<"AuditLog"> | string
    action?: StringFilter<"AuditLog"> | string
    entity?: StringFilter<"AuditLog"> | string
    entityId?: StringFilter<"AuditLog"> | string
    projectId?: StringNullableFilter<"AuditLog"> | string | null
    metadata?: JsonNullableFilter<"AuditLog">
    createdAt?: DateTimeFilter<"AuditLog"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    project?: XOR<ProjectNullableScalarRelationFilter, ProjectWhereInput> | null
  }, "id">

  export type AuditLogOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    action?: SortOrder
    entity?: SortOrder
    entityId?: SortOrder
    projectId?: SortOrderInput | SortOrder
    metadata?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: AuditLogCountOrderByAggregateInput
    _max?: AuditLogMaxOrderByAggregateInput
    _min?: AuditLogMinOrderByAggregateInput
  }

  export type AuditLogScalarWhereWithAggregatesInput = {
    AND?: AuditLogScalarWhereWithAggregatesInput | AuditLogScalarWhereWithAggregatesInput[]
    OR?: AuditLogScalarWhereWithAggregatesInput[]
    NOT?: AuditLogScalarWhereWithAggregatesInput | AuditLogScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"AuditLog"> | string
    userId?: StringWithAggregatesFilter<"AuditLog"> | string
    action?: StringWithAggregatesFilter<"AuditLog"> | string
    entity?: StringWithAggregatesFilter<"AuditLog"> | string
    entityId?: StringWithAggregatesFilter<"AuditLog"> | string
    projectId?: StringNullableWithAggregatesFilter<"AuditLog"> | string | null
    metadata?: JsonNullableWithAggregatesFilter<"AuditLog">
    createdAt?: DateTimeWithAggregatesFilter<"AuditLog"> | Date | string
  }

  export type MaterialWhereInput = {
    AND?: MaterialWhereInput | MaterialWhereInput[]
    OR?: MaterialWhereInput[]
    NOT?: MaterialWhereInput | MaterialWhereInput[]
    id?: StringFilter<"Material"> | string
    projectId?: StringFilter<"Material"> | string
    name?: StringFilter<"Material"> | string
    quantity?: FloatFilter<"Material"> | number
    unit?: StringFilter<"Material"> | string
    unitCost?: FloatFilter<"Material"> | number
    totalCost?: FloatFilter<"Material"> | number
    supplier?: StringNullableFilter<"Material"> | string | null
    status?: EnumMaterialStatusFilter<"Material"> | $Enums.MaterialStatus
    createdById?: StringFilter<"Material"> | string
    createdAt?: DateTimeFilter<"Material"> | Date | string
    updatedAt?: DateTimeFilter<"Material"> | Date | string
    project?: XOR<ProjectScalarRelationFilter, ProjectWhereInput>
    createdBy?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type MaterialOrderByWithRelationInput = {
    id?: SortOrder
    projectId?: SortOrder
    name?: SortOrder
    quantity?: SortOrder
    unit?: SortOrder
    unitCost?: SortOrder
    totalCost?: SortOrder
    supplier?: SortOrderInput | SortOrder
    status?: SortOrder
    createdById?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    project?: ProjectOrderByWithRelationInput
    createdBy?: UserOrderByWithRelationInput
  }

  export type MaterialWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: MaterialWhereInput | MaterialWhereInput[]
    OR?: MaterialWhereInput[]
    NOT?: MaterialWhereInput | MaterialWhereInput[]
    projectId?: StringFilter<"Material"> | string
    name?: StringFilter<"Material"> | string
    quantity?: FloatFilter<"Material"> | number
    unit?: StringFilter<"Material"> | string
    unitCost?: FloatFilter<"Material"> | number
    totalCost?: FloatFilter<"Material"> | number
    supplier?: StringNullableFilter<"Material"> | string | null
    status?: EnumMaterialStatusFilter<"Material"> | $Enums.MaterialStatus
    createdById?: StringFilter<"Material"> | string
    createdAt?: DateTimeFilter<"Material"> | Date | string
    updatedAt?: DateTimeFilter<"Material"> | Date | string
    project?: XOR<ProjectScalarRelationFilter, ProjectWhereInput>
    createdBy?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id">

  export type MaterialOrderByWithAggregationInput = {
    id?: SortOrder
    projectId?: SortOrder
    name?: SortOrder
    quantity?: SortOrder
    unit?: SortOrder
    unitCost?: SortOrder
    totalCost?: SortOrder
    supplier?: SortOrderInput | SortOrder
    status?: SortOrder
    createdById?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: MaterialCountOrderByAggregateInput
    _avg?: MaterialAvgOrderByAggregateInput
    _max?: MaterialMaxOrderByAggregateInput
    _min?: MaterialMinOrderByAggregateInput
    _sum?: MaterialSumOrderByAggregateInput
  }

  export type MaterialScalarWhereWithAggregatesInput = {
    AND?: MaterialScalarWhereWithAggregatesInput | MaterialScalarWhereWithAggregatesInput[]
    OR?: MaterialScalarWhereWithAggregatesInput[]
    NOT?: MaterialScalarWhereWithAggregatesInput | MaterialScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Material"> | string
    projectId?: StringWithAggregatesFilter<"Material"> | string
    name?: StringWithAggregatesFilter<"Material"> | string
    quantity?: FloatWithAggregatesFilter<"Material"> | number
    unit?: StringWithAggregatesFilter<"Material"> | string
    unitCost?: FloatWithAggregatesFilter<"Material"> | number
    totalCost?: FloatWithAggregatesFilter<"Material"> | number
    supplier?: StringNullableWithAggregatesFilter<"Material"> | string | null
    status?: EnumMaterialStatusWithAggregatesFilter<"Material"> | $Enums.MaterialStatus
    createdById?: StringWithAggregatesFilter<"Material"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Material"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Material"> | Date | string
  }

  export type UserCreateInput = {
    id?: string
    name: string
    email: string
    passwordHash: string
    role: $Enums.Role
    isActive?: boolean
    createdAt?: Date | string
    phone?: string | null
    designation?: string | null
    createdBy?: UserCreateNestedOneWithoutCreatedUsersInput
    createdUsers?: UserCreateNestedManyWithoutCreatedByInput
    managedProjects?: ProjectCreateNestedManyWithoutManagerInput
    clientProjects?: ProjectCreateNestedManyWithoutClientInput
    projectMembers?: ProjectMemberCreateNestedManyWithoutUserInput
    projectUpdates?: ProjectUpdateCreateNestedManyWithoutAuthorInput
    media?: MediaCreateNestedManyWithoutCreatedByInput
    paymentsCreated?: PaymentCreateNestedManyWithoutCreatedByInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    projectsCreated?: ProjectCreateNestedManyWithoutCreatedByInput
    inspections?: InspectionCreateNestedManyWithoutEngineerInput
    reviewedInspections?: InspectionCreateNestedManyWithoutReviewedByInput
    queries?: QueryCreateNestedManyWithoutAuthorInput
    queryResponses?: QueryResponseCreateNestedManyWithoutAuthorInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
    notificationPrefs?: NotificationPreferenceCreateNestedOneWithoutUserInput
    materialsCreated?: MaterialCreateNestedManyWithoutCreatedByInput
  }

  export type UserUncheckedCreateInput = {
    id?: string
    name: string
    email: string
    passwordHash: string
    role: $Enums.Role
    isActive?: boolean
    createdById?: string | null
    createdAt?: Date | string
    phone?: string | null
    designation?: string | null
    createdUsers?: UserUncheckedCreateNestedManyWithoutCreatedByInput
    managedProjects?: ProjectUncheckedCreateNestedManyWithoutManagerInput
    clientProjects?: ProjectUncheckedCreateNestedManyWithoutClientInput
    projectMembers?: ProjectMemberUncheckedCreateNestedManyWithoutUserInput
    projectUpdates?: ProjectUpdateUncheckedCreateNestedManyWithoutAuthorInput
    media?: MediaUncheckedCreateNestedManyWithoutCreatedByInput
    paymentsCreated?: PaymentUncheckedCreateNestedManyWithoutCreatedByInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    projectsCreated?: ProjectUncheckedCreateNestedManyWithoutCreatedByInput
    inspections?: InspectionUncheckedCreateNestedManyWithoutEngineerInput
    reviewedInspections?: InspectionUncheckedCreateNestedManyWithoutReviewedByInput
    queries?: QueryUncheckedCreateNestedManyWithoutAuthorInput
    queryResponses?: QueryResponseUncheckedCreateNestedManyWithoutAuthorInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    notificationPrefs?: NotificationPreferenceUncheckedCreateNestedOneWithoutUserInput
    materialsCreated?: MaterialUncheckedCreateNestedManyWithoutCreatedByInput
  }

  export type UserUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    designation?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: UserUpdateOneWithoutCreatedUsersNestedInput
    createdUsers?: UserUpdateManyWithoutCreatedByNestedInput
    managedProjects?: ProjectUpdateManyWithoutManagerNestedInput
    clientProjects?: ProjectUpdateManyWithoutClientNestedInput
    projectMembers?: ProjectMemberUpdateManyWithoutUserNestedInput
    projectUpdates?: ProjectUpdateUpdateManyWithoutAuthorNestedInput
    media?: MediaUpdateManyWithoutCreatedByNestedInput
    paymentsCreated?: PaymentUpdateManyWithoutCreatedByNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    projectsCreated?: ProjectUpdateManyWithoutCreatedByNestedInput
    inspections?: InspectionUpdateManyWithoutEngineerNestedInput
    reviewedInspections?: InspectionUpdateManyWithoutReviewedByNestedInput
    queries?: QueryUpdateManyWithoutAuthorNestedInput
    queryResponses?: QueryResponseUpdateManyWithoutAuthorNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
    notificationPrefs?: NotificationPreferenceUpdateOneWithoutUserNestedInput
    materialsCreated?: MaterialUpdateManyWithoutCreatedByNestedInput
  }

  export type UserUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    designation?: NullableStringFieldUpdateOperationsInput | string | null
    createdUsers?: UserUncheckedUpdateManyWithoutCreatedByNestedInput
    managedProjects?: ProjectUncheckedUpdateManyWithoutManagerNestedInput
    clientProjects?: ProjectUncheckedUpdateManyWithoutClientNestedInput
    projectMembers?: ProjectMemberUncheckedUpdateManyWithoutUserNestedInput
    projectUpdates?: ProjectUpdateUncheckedUpdateManyWithoutAuthorNestedInput
    media?: MediaUncheckedUpdateManyWithoutCreatedByNestedInput
    paymentsCreated?: PaymentUncheckedUpdateManyWithoutCreatedByNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    projectsCreated?: ProjectUncheckedUpdateManyWithoutCreatedByNestedInput
    inspections?: InspectionUncheckedUpdateManyWithoutEngineerNestedInput
    reviewedInspections?: InspectionUncheckedUpdateManyWithoutReviewedByNestedInput
    queries?: QueryUncheckedUpdateManyWithoutAuthorNestedInput
    queryResponses?: QueryResponseUncheckedUpdateManyWithoutAuthorNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    notificationPrefs?: NotificationPreferenceUncheckedUpdateOneWithoutUserNestedInput
    materialsCreated?: MaterialUncheckedUpdateManyWithoutCreatedByNestedInput
  }

  export type UserCreateManyInput = {
    id?: string
    name: string
    email: string
    passwordHash: string
    role: $Enums.Role
    isActive?: boolean
    createdById?: string | null
    createdAt?: Date | string
    phone?: string | null
    designation?: string | null
  }

  export type UserUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    designation?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type UserUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    designation?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ProjectCreateInput = {
    id?: string
    name: string
    description?: string | null
    status?: $Enums.ProjectStatus
    isArchived?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy: UserCreateNestedOneWithoutProjectsCreatedInput
    manager: UserCreateNestedOneWithoutManagedProjectsInput
    client: UserCreateNestedOneWithoutClientProjectsInput
    members?: ProjectMemberCreateNestedManyWithoutProjectInput
    updates?: ProjectUpdateCreateNestedManyWithoutProjectInput
    media?: MediaCreateNestedManyWithoutProjectInput
    payments?: PaymentCreateNestedManyWithoutProjectInput
    milestones?: MilestoneCreateNestedManyWithoutProjectInput
    inspections?: InspectionCreateNestedManyWithoutProjectInput
    queries?: QueryCreateNestedManyWithoutProjectInput
    materials?: MaterialCreateNestedManyWithoutProjectInput
    auditLogs?: AuditLogCreateNestedManyWithoutProjectInput
  }

  export type ProjectUncheckedCreateInput = {
    id?: string
    name: string
    description?: string | null
    status?: $Enums.ProjectStatus
    isArchived?: boolean
    createdById: string
    managerId: string
    clientId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    members?: ProjectMemberUncheckedCreateNestedManyWithoutProjectInput
    updates?: ProjectUpdateUncheckedCreateNestedManyWithoutProjectInput
    media?: MediaUncheckedCreateNestedManyWithoutProjectInput
    payments?: PaymentUncheckedCreateNestedManyWithoutProjectInput
    milestones?: MilestoneUncheckedCreateNestedManyWithoutProjectInput
    inspections?: InspectionUncheckedCreateNestedManyWithoutProjectInput
    queries?: QueryUncheckedCreateNestedManyWithoutProjectInput
    materials?: MaterialUncheckedCreateNestedManyWithoutProjectInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutProjectInput
  }

  export type ProjectUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumProjectStatusFieldUpdateOperationsInput | $Enums.ProjectStatus
    isArchived?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: UserUpdateOneRequiredWithoutProjectsCreatedNestedInput
    manager?: UserUpdateOneRequiredWithoutManagedProjectsNestedInput
    client?: UserUpdateOneRequiredWithoutClientProjectsNestedInput
    members?: ProjectMemberUpdateManyWithoutProjectNestedInput
    updates?: ProjectUpdateUpdateManyWithoutProjectNestedInput
    media?: MediaUpdateManyWithoutProjectNestedInput
    payments?: PaymentUpdateManyWithoutProjectNestedInput
    milestones?: MilestoneUpdateManyWithoutProjectNestedInput
    inspections?: InspectionUpdateManyWithoutProjectNestedInput
    queries?: QueryUpdateManyWithoutProjectNestedInput
    materials?: MaterialUpdateManyWithoutProjectNestedInput
    auditLogs?: AuditLogUpdateManyWithoutProjectNestedInput
  }

  export type ProjectUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumProjectStatusFieldUpdateOperationsInput | $Enums.ProjectStatus
    isArchived?: BoolFieldUpdateOperationsInput | boolean
    createdById?: StringFieldUpdateOperationsInput | string
    managerId?: StringFieldUpdateOperationsInput | string
    clientId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    members?: ProjectMemberUncheckedUpdateManyWithoutProjectNestedInput
    updates?: ProjectUpdateUncheckedUpdateManyWithoutProjectNestedInput
    media?: MediaUncheckedUpdateManyWithoutProjectNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutProjectNestedInput
    milestones?: MilestoneUncheckedUpdateManyWithoutProjectNestedInput
    inspections?: InspectionUncheckedUpdateManyWithoutProjectNestedInput
    queries?: QueryUncheckedUpdateManyWithoutProjectNestedInput
    materials?: MaterialUncheckedUpdateManyWithoutProjectNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutProjectNestedInput
  }

  export type ProjectCreateManyInput = {
    id?: string
    name: string
    description?: string | null
    status?: $Enums.ProjectStatus
    isArchived?: boolean
    createdById: string
    managerId: string
    clientId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProjectUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumProjectStatusFieldUpdateOperationsInput | $Enums.ProjectStatus
    isArchived?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProjectUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumProjectStatusFieldUpdateOperationsInput | $Enums.ProjectStatus
    isArchived?: BoolFieldUpdateOperationsInput | boolean
    createdById?: StringFieldUpdateOperationsInput | string
    managerId?: StringFieldUpdateOperationsInput | string
    clientId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProjectMemberCreateInput = {
    id?: string
    role: $Enums.ProjectMemberRole
    createdAt?: Date | string
    project: ProjectCreateNestedOneWithoutMembersInput
    user: UserCreateNestedOneWithoutProjectMembersInput
  }

  export type ProjectMemberUncheckedCreateInput = {
    id?: string
    projectId: string
    userId: string
    role: $Enums.ProjectMemberRole
    createdAt?: Date | string
  }

  export type ProjectMemberUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: EnumProjectMemberRoleFieldUpdateOperationsInput | $Enums.ProjectMemberRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    project?: ProjectUpdateOneRequiredWithoutMembersNestedInput
    user?: UserUpdateOneRequiredWithoutProjectMembersNestedInput
  }

  export type ProjectMemberUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    projectId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    role?: EnumProjectMemberRoleFieldUpdateOperationsInput | $Enums.ProjectMemberRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProjectMemberCreateManyInput = {
    id?: string
    projectId: string
    userId: string
    role: $Enums.ProjectMemberRole
    createdAt?: Date | string
  }

  export type ProjectMemberUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: EnumProjectMemberRoleFieldUpdateOperationsInput | $Enums.ProjectMemberRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProjectMemberUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    projectId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    role?: EnumProjectMemberRoleFieldUpdateOperationsInput | $Enums.ProjectMemberRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProjectUpdateCreateInput = {
    id?: string
    notes: string
    statusSnapshot?: string | null
    createdAt?: Date | string
    project: ProjectCreateNestedOneWithoutUpdatesInput
    author: UserCreateNestedOneWithoutProjectUpdatesInput
    media?: MediaCreateNestedManyWithoutProjectUpdateInput
  }

  export type ProjectUpdateUncheckedCreateInput = {
    id?: string
    projectId: string
    authorId: string
    notes: string
    statusSnapshot?: string | null
    createdAt?: Date | string
    media?: MediaUncheckedCreateNestedManyWithoutProjectUpdateInput
  }

  export type ProjectUpdateUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    notes?: StringFieldUpdateOperationsInput | string
    statusSnapshot?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    project?: ProjectUpdateOneRequiredWithoutUpdatesNestedInput
    author?: UserUpdateOneRequiredWithoutProjectUpdatesNestedInput
    media?: MediaUpdateManyWithoutProjectUpdateNestedInput
  }

  export type ProjectUpdateUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    projectId?: StringFieldUpdateOperationsInput | string
    authorId?: StringFieldUpdateOperationsInput | string
    notes?: StringFieldUpdateOperationsInput | string
    statusSnapshot?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    media?: MediaUncheckedUpdateManyWithoutProjectUpdateNestedInput
  }

  export type ProjectUpdateCreateManyInput = {
    id?: string
    projectId: string
    authorId: string
    notes: string
    statusSnapshot?: string | null
    createdAt?: Date | string
  }

  export type ProjectUpdateUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    notes?: StringFieldUpdateOperationsInput | string
    statusSnapshot?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProjectUpdateUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    projectId?: StringFieldUpdateOperationsInput | string
    authorId?: StringFieldUpdateOperationsInput | string
    notes?: StringFieldUpdateOperationsInput | string
    statusSnapshot?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MediaCreateInput = {
    id?: string
    type: $Enums.MediaType
    fileKey: string
    fileUrl: string
    mimeType: string
    fileSize: number
    approvedBy?: string | null
    approvedAt?: Date | string | null
    version?: number | null
    createdAt?: Date | string
    project: ProjectCreateNestedOneWithoutMediaInput
    projectUpdate?: ProjectUpdateCreateNestedOneWithoutMediaInput
    payment?: PaymentCreateNestedOneWithoutMediaInput
    createdBy: UserCreateNestedOneWithoutMediaInput
    inspectionResponses?: InspectionResponseCreateNestedManyWithoutMediaInput
    query?: QueryCreateNestedOneWithoutAttachmentsInput
  }

  export type MediaUncheckedCreateInput = {
    id?: string
    projectId: string
    projectUpdateId?: string | null
    paymentId?: string | null
    type: $Enums.MediaType
    fileKey: string
    fileUrl: string
    mimeType: string
    fileSize: number
    createdById: string
    approvedBy?: string | null
    approvedAt?: Date | string | null
    version?: number | null
    createdAt?: Date | string
    queryId?: string | null
    inspectionResponses?: InspectionResponseUncheckedCreateNestedManyWithoutMediaInput
  }

  export type MediaUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumMediaTypeFieldUpdateOperationsInput | $Enums.MediaType
    fileKey?: StringFieldUpdateOperationsInput | string
    fileUrl?: StringFieldUpdateOperationsInput | string
    mimeType?: StringFieldUpdateOperationsInput | string
    fileSize?: IntFieldUpdateOperationsInput | number
    approvedBy?: NullableStringFieldUpdateOperationsInput | string | null
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    version?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    project?: ProjectUpdateOneRequiredWithoutMediaNestedInput
    projectUpdate?: ProjectUpdateUpdateOneWithoutMediaNestedInput
    payment?: PaymentUpdateOneWithoutMediaNestedInput
    createdBy?: UserUpdateOneRequiredWithoutMediaNestedInput
    inspectionResponses?: InspectionResponseUpdateManyWithoutMediaNestedInput
    query?: QueryUpdateOneWithoutAttachmentsNestedInput
  }

  export type MediaUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    projectId?: StringFieldUpdateOperationsInput | string
    projectUpdateId?: NullableStringFieldUpdateOperationsInput | string | null
    paymentId?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumMediaTypeFieldUpdateOperationsInput | $Enums.MediaType
    fileKey?: StringFieldUpdateOperationsInput | string
    fileUrl?: StringFieldUpdateOperationsInput | string
    mimeType?: StringFieldUpdateOperationsInput | string
    fileSize?: IntFieldUpdateOperationsInput | number
    createdById?: StringFieldUpdateOperationsInput | string
    approvedBy?: NullableStringFieldUpdateOperationsInput | string | null
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    version?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    queryId?: NullableStringFieldUpdateOperationsInput | string | null
    inspectionResponses?: InspectionResponseUncheckedUpdateManyWithoutMediaNestedInput
  }

  export type MediaCreateManyInput = {
    id?: string
    projectId: string
    projectUpdateId?: string | null
    paymentId?: string | null
    type: $Enums.MediaType
    fileKey: string
    fileUrl: string
    mimeType: string
    fileSize: number
    createdById: string
    approvedBy?: string | null
    approvedAt?: Date | string | null
    version?: number | null
    createdAt?: Date | string
    queryId?: string | null
  }

  export type MediaUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumMediaTypeFieldUpdateOperationsInput | $Enums.MediaType
    fileKey?: StringFieldUpdateOperationsInput | string
    fileUrl?: StringFieldUpdateOperationsInput | string
    mimeType?: StringFieldUpdateOperationsInput | string
    fileSize?: IntFieldUpdateOperationsInput | number
    approvedBy?: NullableStringFieldUpdateOperationsInput | string | null
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    version?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MediaUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    projectId?: StringFieldUpdateOperationsInput | string
    projectUpdateId?: NullableStringFieldUpdateOperationsInput | string | null
    paymentId?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumMediaTypeFieldUpdateOperationsInput | $Enums.MediaType
    fileKey?: StringFieldUpdateOperationsInput | string
    fileUrl?: StringFieldUpdateOperationsInput | string
    mimeType?: StringFieldUpdateOperationsInput | string
    fileSize?: IntFieldUpdateOperationsInput | number
    createdById?: StringFieldUpdateOperationsInput | string
    approvedBy?: NullableStringFieldUpdateOperationsInput | string | null
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    version?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    queryId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PaymentCreateInput = {
    id?: string
    amount: Decimal | DecimalJsLike | number | string
    currency?: string
    status?: $Enums.PaymentStatus
    category?: $Enums.PaymentCategory | null
    invoiceNumber?: string | null
    paidAt?: Date | string | null
    dueDate?: Date | string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    project: ProjectCreateNestedOneWithoutPaymentsInput
    createdBy: UserCreateNestedOneWithoutPaymentsCreatedInput
    media?: MediaCreateNestedManyWithoutPaymentInput
  }

  export type PaymentUncheckedCreateInput = {
    id?: string
    projectId: string
    createdById: string
    amount: Decimal | DecimalJsLike | number | string
    currency?: string
    status?: $Enums.PaymentStatus
    category?: $Enums.PaymentCategory | null
    invoiceNumber?: string | null
    paidAt?: Date | string | null
    dueDate?: Date | string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    media?: MediaUncheckedCreateNestedManyWithoutPaymentInput
  }

  export type PaymentUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    status?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    category?: NullableEnumPaymentCategoryFieldUpdateOperationsInput | $Enums.PaymentCategory | null
    invoiceNumber?: NullableStringFieldUpdateOperationsInput | string | null
    paidAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    project?: ProjectUpdateOneRequiredWithoutPaymentsNestedInput
    createdBy?: UserUpdateOneRequiredWithoutPaymentsCreatedNestedInput
    media?: MediaUpdateManyWithoutPaymentNestedInput
  }

  export type PaymentUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    projectId?: StringFieldUpdateOperationsInput | string
    createdById?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    status?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    category?: NullableEnumPaymentCategoryFieldUpdateOperationsInput | $Enums.PaymentCategory | null
    invoiceNumber?: NullableStringFieldUpdateOperationsInput | string | null
    paidAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    media?: MediaUncheckedUpdateManyWithoutPaymentNestedInput
  }

  export type PaymentCreateManyInput = {
    id?: string
    projectId: string
    createdById: string
    amount: Decimal | DecimalJsLike | number | string
    currency?: string
    status?: $Enums.PaymentStatus
    category?: $Enums.PaymentCategory | null
    invoiceNumber?: string | null
    paidAt?: Date | string | null
    dueDate?: Date | string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PaymentUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    status?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    category?: NullableEnumPaymentCategoryFieldUpdateOperationsInput | $Enums.PaymentCategory | null
    invoiceNumber?: NullableStringFieldUpdateOperationsInput | string | null
    paidAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    projectId?: StringFieldUpdateOperationsInput | string
    createdById?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    status?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    category?: NullableEnumPaymentCategoryFieldUpdateOperationsInput | $Enums.PaymentCategory | null
    invoiceNumber?: NullableStringFieldUpdateOperationsInput | string | null
    paidAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationCreateInput = {
    id?: string
    title: string
    message: string
    type: string
    priority?: $Enums.NotificationPriority
    actionUrl?: string | null
    isRead?: boolean
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutNotificationsInput
  }

  export type NotificationUncheckedCreateInput = {
    id?: string
    userId: string
    title: string
    message: string
    type: string
    priority?: $Enums.NotificationPriority
    actionUrl?: string | null
    isRead?: boolean
    createdAt?: Date | string
  }

  export type NotificationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    priority?: EnumNotificationPriorityFieldUpdateOperationsInput | $Enums.NotificationPriority
    actionUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isRead?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutNotificationsNestedInput
  }

  export type NotificationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    priority?: EnumNotificationPriorityFieldUpdateOperationsInput | $Enums.NotificationPriority
    actionUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isRead?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationCreateManyInput = {
    id?: string
    userId: string
    title: string
    message: string
    type: string
    priority?: $Enums.NotificationPriority
    actionUrl?: string | null
    isRead?: boolean
    createdAt?: Date | string
  }

  export type NotificationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    priority?: EnumNotificationPriorityFieldUpdateOperationsInput | $Enums.NotificationPriority
    actionUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isRead?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    priority?: EnumNotificationPriorityFieldUpdateOperationsInput | $Enums.NotificationPriority
    actionUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isRead?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationPreferenceCreateInput = {
    id?: string
    inspectionSubmitted?: boolean
    paymentOverdue?: boolean
    newAssignment?: boolean
    queryCreated?: boolean
    drawingApproved?: boolean
    emailEnabled?: boolean
    inAppEnabled?: boolean
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutNotificationPrefsInput
  }

  export type NotificationPreferenceUncheckedCreateInput = {
    id?: string
    userId: string
    inspectionSubmitted?: boolean
    paymentOverdue?: boolean
    newAssignment?: boolean
    queryCreated?: boolean
    drawingApproved?: boolean
    emailEnabled?: boolean
    inAppEnabled?: boolean
    updatedAt?: Date | string
  }

  export type NotificationPreferenceUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    inspectionSubmitted?: BoolFieldUpdateOperationsInput | boolean
    paymentOverdue?: BoolFieldUpdateOperationsInput | boolean
    newAssignment?: BoolFieldUpdateOperationsInput | boolean
    queryCreated?: BoolFieldUpdateOperationsInput | boolean
    drawingApproved?: BoolFieldUpdateOperationsInput | boolean
    emailEnabled?: BoolFieldUpdateOperationsInput | boolean
    inAppEnabled?: BoolFieldUpdateOperationsInput | boolean
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutNotificationPrefsNestedInput
  }

  export type NotificationPreferenceUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    inspectionSubmitted?: BoolFieldUpdateOperationsInput | boolean
    paymentOverdue?: BoolFieldUpdateOperationsInput | boolean
    newAssignment?: BoolFieldUpdateOperationsInput | boolean
    queryCreated?: BoolFieldUpdateOperationsInput | boolean
    drawingApproved?: BoolFieldUpdateOperationsInput | boolean
    emailEnabled?: BoolFieldUpdateOperationsInput | boolean
    inAppEnabled?: BoolFieldUpdateOperationsInput | boolean
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationPreferenceCreateManyInput = {
    id?: string
    userId: string
    inspectionSubmitted?: boolean
    paymentOverdue?: boolean
    newAssignment?: boolean
    queryCreated?: boolean
    drawingApproved?: boolean
    emailEnabled?: boolean
    inAppEnabled?: boolean
    updatedAt?: Date | string
  }

  export type NotificationPreferenceUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    inspectionSubmitted?: BoolFieldUpdateOperationsInput | boolean
    paymentOverdue?: BoolFieldUpdateOperationsInput | boolean
    newAssignment?: BoolFieldUpdateOperationsInput | boolean
    queryCreated?: BoolFieldUpdateOperationsInput | boolean
    drawingApproved?: BoolFieldUpdateOperationsInput | boolean
    emailEnabled?: BoolFieldUpdateOperationsInput | boolean
    inAppEnabled?: BoolFieldUpdateOperationsInput | boolean
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationPreferenceUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    inspectionSubmitted?: BoolFieldUpdateOperationsInput | boolean
    paymentOverdue?: BoolFieldUpdateOperationsInput | boolean
    newAssignment?: BoolFieldUpdateOperationsInput | boolean
    queryCreated?: BoolFieldUpdateOperationsInput | boolean
    drawingApproved?: BoolFieldUpdateOperationsInput | boolean
    emailEnabled?: BoolFieldUpdateOperationsInput | boolean
    inAppEnabled?: BoolFieldUpdateOperationsInput | boolean
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MilestoneCreateInput = {
    id?: string
    name: string
    description?: string | null
    order: number
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    project: ProjectCreateNestedOneWithoutMilestonesInput
    checklistItems?: ChecklistItemCreateNestedManyWithoutMilestoneInput
    inspections?: InspectionCreateNestedManyWithoutMilestoneInput
  }

  export type MilestoneUncheckedCreateInput = {
    id?: string
    name: string
    description?: string | null
    order: number
    isActive?: boolean
    projectId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    checklistItems?: ChecklistItemUncheckedCreateNestedManyWithoutMilestoneInput
    inspections?: InspectionUncheckedCreateNestedManyWithoutMilestoneInput
  }

  export type MilestoneUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    order?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    project?: ProjectUpdateOneRequiredWithoutMilestonesNestedInput
    checklistItems?: ChecklistItemUpdateManyWithoutMilestoneNestedInput
    inspections?: InspectionUpdateManyWithoutMilestoneNestedInput
  }

  export type MilestoneUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    order?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    projectId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    checklistItems?: ChecklistItemUncheckedUpdateManyWithoutMilestoneNestedInput
    inspections?: InspectionUncheckedUpdateManyWithoutMilestoneNestedInput
  }

  export type MilestoneCreateManyInput = {
    id?: string
    name: string
    description?: string | null
    order: number
    isActive?: boolean
    projectId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MilestoneUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    order?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MilestoneUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    order?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    projectId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ChecklistItemCreateInput = {
    id?: string
    title: string
    description?: string | null
    order: number
    isRequired?: boolean
    isPhotoRequired?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    milestone: MilestoneCreateNestedOneWithoutChecklistItemsInput
    responses?: InspectionResponseCreateNestedManyWithoutChecklistItemInput
  }

  export type ChecklistItemUncheckedCreateInput = {
    id?: string
    title: string
    description?: string | null
    order: number
    isRequired?: boolean
    isPhotoRequired?: boolean
    milestoneId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    responses?: InspectionResponseUncheckedCreateNestedManyWithoutChecklistItemInput
  }

  export type ChecklistItemUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    order?: IntFieldUpdateOperationsInput | number
    isRequired?: BoolFieldUpdateOperationsInput | boolean
    isPhotoRequired?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    milestone?: MilestoneUpdateOneRequiredWithoutChecklistItemsNestedInput
    responses?: InspectionResponseUpdateManyWithoutChecklistItemNestedInput
  }

  export type ChecklistItemUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    order?: IntFieldUpdateOperationsInput | number
    isRequired?: BoolFieldUpdateOperationsInput | boolean
    isPhotoRequired?: BoolFieldUpdateOperationsInput | boolean
    milestoneId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    responses?: InspectionResponseUncheckedUpdateManyWithoutChecklistItemNestedInput
  }

  export type ChecklistItemCreateManyInput = {
    id?: string
    title: string
    description?: string | null
    order: number
    isRequired?: boolean
    isPhotoRequired?: boolean
    milestoneId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ChecklistItemUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    order?: IntFieldUpdateOperationsInput | number
    isRequired?: BoolFieldUpdateOperationsInput | boolean
    isPhotoRequired?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ChecklistItemUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    order?: IntFieldUpdateOperationsInput | number
    isRequired?: BoolFieldUpdateOperationsInput | boolean
    isPhotoRequired?: BoolFieldUpdateOperationsInput | boolean
    milestoneId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InspectionCreateInput = {
    id?: string
    status?: $Enums.InspectionStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    project: ProjectCreateNestedOneWithoutInspectionsInput
    milestone: MilestoneCreateNestedOneWithoutInspectionsInput
    engineer: UserCreateNestedOneWithoutInspectionsInput
    responses?: InspectionResponseCreateNestedManyWithoutInspectionInput
    reviewedBy?: UserCreateNestedOneWithoutReviewedInspectionsInput
  }

  export type InspectionUncheckedCreateInput = {
    id?: string
    status?: $Enums.InspectionStatus
    projectId: string
    milestoneId: string
    engineerId: string
    reviewedById?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    responses?: InspectionResponseUncheckedCreateNestedManyWithoutInspectionInput
  }

  export type InspectionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumInspectionStatusFieldUpdateOperationsInput | $Enums.InspectionStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    project?: ProjectUpdateOneRequiredWithoutInspectionsNestedInput
    milestone?: MilestoneUpdateOneRequiredWithoutInspectionsNestedInput
    engineer?: UserUpdateOneRequiredWithoutInspectionsNestedInput
    responses?: InspectionResponseUpdateManyWithoutInspectionNestedInput
    reviewedBy?: UserUpdateOneWithoutReviewedInspectionsNestedInput
  }

  export type InspectionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumInspectionStatusFieldUpdateOperationsInput | $Enums.InspectionStatus
    projectId?: StringFieldUpdateOperationsInput | string
    milestoneId?: StringFieldUpdateOperationsInput | string
    engineerId?: StringFieldUpdateOperationsInput | string
    reviewedById?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    responses?: InspectionResponseUncheckedUpdateManyWithoutInspectionNestedInput
  }

  export type InspectionCreateManyInput = {
    id?: string
    status?: $Enums.InspectionStatus
    projectId: string
    milestoneId: string
    engineerId: string
    reviewedById?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type InspectionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumInspectionStatusFieldUpdateOperationsInput | $Enums.InspectionStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InspectionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumInspectionStatusFieldUpdateOperationsInput | $Enums.InspectionStatus
    projectId?: StringFieldUpdateOperationsInput | string
    milestoneId?: StringFieldUpdateOperationsInput | string
    engineerId?: StringFieldUpdateOperationsInput | string
    reviewedById?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InspectionResponseCreateInput = {
    id?: string
    result: $Enums.ChecklistResult
    remark?: string | null
    inspection: InspectionCreateNestedOneWithoutResponsesInput
    checklistItem: ChecklistItemCreateNestedOneWithoutResponsesInput
    media?: MediaCreateNestedOneWithoutInspectionResponsesInput
  }

  export type InspectionResponseUncheckedCreateInput = {
    id?: string
    result: $Enums.ChecklistResult
    remark?: string | null
    inspectionId: string
    checklistItemId: string
    mediaId?: string | null
  }

  export type InspectionResponseUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    result?: EnumChecklistResultFieldUpdateOperationsInput | $Enums.ChecklistResult
    remark?: NullableStringFieldUpdateOperationsInput | string | null
    inspection?: InspectionUpdateOneRequiredWithoutResponsesNestedInput
    checklistItem?: ChecklistItemUpdateOneRequiredWithoutResponsesNestedInput
    media?: MediaUpdateOneWithoutInspectionResponsesNestedInput
  }

  export type InspectionResponseUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    result?: EnumChecklistResultFieldUpdateOperationsInput | $Enums.ChecklistResult
    remark?: NullableStringFieldUpdateOperationsInput | string | null
    inspectionId?: StringFieldUpdateOperationsInput | string
    checklistItemId?: StringFieldUpdateOperationsInput | string
    mediaId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type InspectionResponseCreateManyInput = {
    id?: string
    result: $Enums.ChecklistResult
    remark?: string | null
    inspectionId: string
    checklistItemId: string
    mediaId?: string | null
  }

  export type InspectionResponseUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    result?: EnumChecklistResultFieldUpdateOperationsInput | $Enums.ChecklistResult
    remark?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type InspectionResponseUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    result?: EnumChecklistResultFieldUpdateOperationsInput | $Enums.ChecklistResult
    remark?: NullableStringFieldUpdateOperationsInput | string | null
    inspectionId?: StringFieldUpdateOperationsInput | string
    checklistItemId?: StringFieldUpdateOperationsInput | string
    mediaId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type QueryCreateInput = {
    id?: string
    title: string
    description: string
    status?: $Enums.QueryStatus
    priority?: $Enums.QueryPriority
    createdAt?: Date | string
    updatedAt?: Date | string
    project: ProjectCreateNestedOneWithoutQueriesInput
    author: UserCreateNestedOneWithoutQueriesInput
    attachments?: MediaCreateNestedManyWithoutQueryInput
    responses?: QueryResponseCreateNestedManyWithoutQueryInput
  }

  export type QueryUncheckedCreateInput = {
    id?: string
    projectId: string
    authorId: string
    title: string
    description: string
    status?: $Enums.QueryStatus
    priority?: $Enums.QueryPriority
    createdAt?: Date | string
    updatedAt?: Date | string
    attachments?: MediaUncheckedCreateNestedManyWithoutQueryInput
    responses?: QueryResponseUncheckedCreateNestedManyWithoutQueryInput
  }

  export type QueryUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    status?: EnumQueryStatusFieldUpdateOperationsInput | $Enums.QueryStatus
    priority?: EnumQueryPriorityFieldUpdateOperationsInput | $Enums.QueryPriority
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    project?: ProjectUpdateOneRequiredWithoutQueriesNestedInput
    author?: UserUpdateOneRequiredWithoutQueriesNestedInput
    attachments?: MediaUpdateManyWithoutQueryNestedInput
    responses?: QueryResponseUpdateManyWithoutQueryNestedInput
  }

  export type QueryUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    projectId?: StringFieldUpdateOperationsInput | string
    authorId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    status?: EnumQueryStatusFieldUpdateOperationsInput | $Enums.QueryStatus
    priority?: EnumQueryPriorityFieldUpdateOperationsInput | $Enums.QueryPriority
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    attachments?: MediaUncheckedUpdateManyWithoutQueryNestedInput
    responses?: QueryResponseUncheckedUpdateManyWithoutQueryNestedInput
  }

  export type QueryCreateManyInput = {
    id?: string
    projectId: string
    authorId: string
    title: string
    description: string
    status?: $Enums.QueryStatus
    priority?: $Enums.QueryPriority
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type QueryUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    status?: EnumQueryStatusFieldUpdateOperationsInput | $Enums.QueryStatus
    priority?: EnumQueryPriorityFieldUpdateOperationsInput | $Enums.QueryPriority
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type QueryUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    projectId?: StringFieldUpdateOperationsInput | string
    authorId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    status?: EnumQueryStatusFieldUpdateOperationsInput | $Enums.QueryStatus
    priority?: EnumQueryPriorityFieldUpdateOperationsInput | $Enums.QueryPriority
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type QueryResponseCreateInput = {
    id?: string
    message: string
    createdAt?: Date | string
    query: QueryCreateNestedOneWithoutResponsesInput
    author: UserCreateNestedOneWithoutQueryResponsesInput
  }

  export type QueryResponseUncheckedCreateInput = {
    id?: string
    queryId: string
    authorId: string
    message: string
    createdAt?: Date | string
  }

  export type QueryResponseUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    query?: QueryUpdateOneRequiredWithoutResponsesNestedInput
    author?: UserUpdateOneRequiredWithoutQueryResponsesNestedInput
  }

  export type QueryResponseUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    queryId?: StringFieldUpdateOperationsInput | string
    authorId?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type QueryResponseCreateManyInput = {
    id?: string
    queryId: string
    authorId: string
    message: string
    createdAt?: Date | string
  }

  export type QueryResponseUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type QueryResponseUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    queryId?: StringFieldUpdateOperationsInput | string
    authorId?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditLogCreateInput = {
    id?: string
    action: string
    entity: string
    entityId: string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutAuditLogsInput
    project?: ProjectCreateNestedOneWithoutAuditLogsInput
  }

  export type AuditLogUncheckedCreateInput = {
    id?: string
    userId: string
    action: string
    entity: string
    entityId: string
    projectId?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type AuditLogUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    entity?: StringFieldUpdateOperationsInput | string
    entityId?: StringFieldUpdateOperationsInput | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutAuditLogsNestedInput
    project?: ProjectUpdateOneWithoutAuditLogsNestedInput
  }

  export type AuditLogUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    entity?: StringFieldUpdateOperationsInput | string
    entityId?: StringFieldUpdateOperationsInput | string
    projectId?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditLogCreateManyInput = {
    id?: string
    userId: string
    action: string
    entity: string
    entityId: string
    projectId?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type AuditLogUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    entity?: StringFieldUpdateOperationsInput | string
    entityId?: StringFieldUpdateOperationsInput | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditLogUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    entity?: StringFieldUpdateOperationsInput | string
    entityId?: StringFieldUpdateOperationsInput | string
    projectId?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MaterialCreateInput = {
    id?: string
    name: string
    quantity: number
    unit: string
    unitCost: number
    totalCost: number
    supplier?: string | null
    status?: $Enums.MaterialStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    project: ProjectCreateNestedOneWithoutMaterialsInput
    createdBy: UserCreateNestedOneWithoutMaterialsCreatedInput
  }

  export type MaterialUncheckedCreateInput = {
    id?: string
    projectId: string
    name: string
    quantity: number
    unit: string
    unitCost: number
    totalCost: number
    supplier?: string | null
    status?: $Enums.MaterialStatus
    createdById: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MaterialUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    quantity?: FloatFieldUpdateOperationsInput | number
    unit?: StringFieldUpdateOperationsInput | string
    unitCost?: FloatFieldUpdateOperationsInput | number
    totalCost?: FloatFieldUpdateOperationsInput | number
    supplier?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumMaterialStatusFieldUpdateOperationsInput | $Enums.MaterialStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    project?: ProjectUpdateOneRequiredWithoutMaterialsNestedInput
    createdBy?: UserUpdateOneRequiredWithoutMaterialsCreatedNestedInput
  }

  export type MaterialUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    projectId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    quantity?: FloatFieldUpdateOperationsInput | number
    unit?: StringFieldUpdateOperationsInput | string
    unitCost?: FloatFieldUpdateOperationsInput | number
    totalCost?: FloatFieldUpdateOperationsInput | number
    supplier?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumMaterialStatusFieldUpdateOperationsInput | $Enums.MaterialStatus
    createdById?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MaterialCreateManyInput = {
    id?: string
    projectId: string
    name: string
    quantity: number
    unit: string
    unitCost: number
    totalCost: number
    supplier?: string | null
    status?: $Enums.MaterialStatus
    createdById: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MaterialUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    quantity?: FloatFieldUpdateOperationsInput | number
    unit?: StringFieldUpdateOperationsInput | string
    unitCost?: FloatFieldUpdateOperationsInput | number
    totalCost?: FloatFieldUpdateOperationsInput | number
    supplier?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumMaterialStatusFieldUpdateOperationsInput | $Enums.MaterialStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MaterialUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    projectId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    quantity?: FloatFieldUpdateOperationsInput | number
    unit?: StringFieldUpdateOperationsInput | string
    unitCost?: FloatFieldUpdateOperationsInput | number
    totalCost?: FloatFieldUpdateOperationsInput | number
    supplier?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumMaterialStatusFieldUpdateOperationsInput | $Enums.MaterialStatus
    createdById?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type EnumRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.Role | EnumRoleFieldRefInput<$PrismaModel>
    in?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumRoleFilter<$PrismaModel> | $Enums.Role
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type UserNullableScalarRelationFilter = {
    is?: UserWhereInput | null
    isNot?: UserWhereInput | null
  }

  export type UserListRelationFilter = {
    every?: UserWhereInput
    some?: UserWhereInput
    none?: UserWhereInput
  }

  export type ProjectListRelationFilter = {
    every?: ProjectWhereInput
    some?: ProjectWhereInput
    none?: ProjectWhereInput
  }

  export type ProjectMemberListRelationFilter = {
    every?: ProjectMemberWhereInput
    some?: ProjectMemberWhereInput
    none?: ProjectMemberWhereInput
  }

  export type ProjectUpdateListRelationFilter = {
    every?: ProjectUpdateWhereInput
    some?: ProjectUpdateWhereInput
    none?: ProjectUpdateWhereInput
  }

  export type MediaListRelationFilter = {
    every?: MediaWhereInput
    some?: MediaWhereInput
    none?: MediaWhereInput
  }

  export type PaymentListRelationFilter = {
    every?: PaymentWhereInput
    some?: PaymentWhereInput
    none?: PaymentWhereInput
  }

  export type NotificationListRelationFilter = {
    every?: NotificationWhereInput
    some?: NotificationWhereInput
    none?: NotificationWhereInput
  }

  export type InspectionListRelationFilter = {
    every?: InspectionWhereInput
    some?: InspectionWhereInput
    none?: InspectionWhereInput
  }

  export type QueryListRelationFilter = {
    every?: QueryWhereInput
    some?: QueryWhereInput
    none?: QueryWhereInput
  }

  export type QueryResponseListRelationFilter = {
    every?: QueryResponseWhereInput
    some?: QueryResponseWhereInput
    none?: QueryResponseWhereInput
  }

  export type AuditLogListRelationFilter = {
    every?: AuditLogWhereInput
    some?: AuditLogWhereInput
    none?: AuditLogWhereInput
  }

  export type NotificationPreferenceNullableScalarRelationFilter = {
    is?: NotificationPreferenceWhereInput | null
    isNot?: NotificationPreferenceWhereInput | null
  }

  export type MaterialListRelationFilter = {
    every?: MaterialWhereInput
    some?: MaterialWhereInput
    none?: MaterialWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type UserOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ProjectOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ProjectMemberOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ProjectUpdateOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type MediaOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PaymentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type NotificationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type InspectionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type QueryOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type QueryResponseOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AuditLogOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type MaterialOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    passwordHash?: SortOrder
    role?: SortOrder
    isActive?: SortOrder
    createdById?: SortOrder
    createdAt?: SortOrder
    phone?: SortOrder
    designation?: SortOrder
  }

  export type UserMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    passwordHash?: SortOrder
    role?: SortOrder
    isActive?: SortOrder
    createdById?: SortOrder
    createdAt?: SortOrder
    phone?: SortOrder
    designation?: SortOrder
  }

  export type UserMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    passwordHash?: SortOrder
    role?: SortOrder
    isActive?: SortOrder
    createdById?: SortOrder
    createdAt?: SortOrder
    phone?: SortOrder
    designation?: SortOrder
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type EnumRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Role | EnumRoleFieldRefInput<$PrismaModel>
    in?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumRoleWithAggregatesFilter<$PrismaModel> | $Enums.Role
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumRoleFilter<$PrismaModel>
    _max?: NestedEnumRoleFilter<$PrismaModel>
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type EnumProjectStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.ProjectStatus | EnumProjectStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ProjectStatus[] | ListEnumProjectStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ProjectStatus[] | ListEnumProjectStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumProjectStatusFilter<$PrismaModel> | $Enums.ProjectStatus
  }

  export type UserScalarRelationFilter = {
    is?: UserWhereInput
    isNot?: UserWhereInput
  }

  export type MilestoneListRelationFilter = {
    every?: MilestoneWhereInput
    some?: MilestoneWhereInput
    none?: MilestoneWhereInput
  }

  export type MilestoneOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ProjectCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    status?: SortOrder
    isArchived?: SortOrder
    createdById?: SortOrder
    managerId?: SortOrder
    clientId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProjectMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    status?: SortOrder
    isArchived?: SortOrder
    createdById?: SortOrder
    managerId?: SortOrder
    clientId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProjectMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    status?: SortOrder
    isArchived?: SortOrder
    createdById?: SortOrder
    managerId?: SortOrder
    clientId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumProjectStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ProjectStatus | EnumProjectStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ProjectStatus[] | ListEnumProjectStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ProjectStatus[] | ListEnumProjectStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumProjectStatusWithAggregatesFilter<$PrismaModel> | $Enums.ProjectStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumProjectStatusFilter<$PrismaModel>
    _max?: NestedEnumProjectStatusFilter<$PrismaModel>
  }

  export type EnumProjectMemberRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.ProjectMemberRole | EnumProjectMemberRoleFieldRefInput<$PrismaModel>
    in?: $Enums.ProjectMemberRole[] | ListEnumProjectMemberRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.ProjectMemberRole[] | ListEnumProjectMemberRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumProjectMemberRoleFilter<$PrismaModel> | $Enums.ProjectMemberRole
  }

  export type ProjectScalarRelationFilter = {
    is?: ProjectWhereInput
    isNot?: ProjectWhereInput
  }

  export type ProjectMemberProjectIdUserIdCompoundUniqueInput = {
    projectId: string
    userId: string
  }

  export type ProjectMemberCountOrderByAggregateInput = {
    id?: SortOrder
    projectId?: SortOrder
    userId?: SortOrder
    role?: SortOrder
    createdAt?: SortOrder
  }

  export type ProjectMemberMaxOrderByAggregateInput = {
    id?: SortOrder
    projectId?: SortOrder
    userId?: SortOrder
    role?: SortOrder
    createdAt?: SortOrder
  }

  export type ProjectMemberMinOrderByAggregateInput = {
    id?: SortOrder
    projectId?: SortOrder
    userId?: SortOrder
    role?: SortOrder
    createdAt?: SortOrder
  }

  export type EnumProjectMemberRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ProjectMemberRole | EnumProjectMemberRoleFieldRefInput<$PrismaModel>
    in?: $Enums.ProjectMemberRole[] | ListEnumProjectMemberRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.ProjectMemberRole[] | ListEnumProjectMemberRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumProjectMemberRoleWithAggregatesFilter<$PrismaModel> | $Enums.ProjectMemberRole
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumProjectMemberRoleFilter<$PrismaModel>
    _max?: NestedEnumProjectMemberRoleFilter<$PrismaModel>
  }

  export type ProjectUpdateCountOrderByAggregateInput = {
    id?: SortOrder
    projectId?: SortOrder
    authorId?: SortOrder
    notes?: SortOrder
    statusSnapshot?: SortOrder
    createdAt?: SortOrder
  }

  export type ProjectUpdateMaxOrderByAggregateInput = {
    id?: SortOrder
    projectId?: SortOrder
    authorId?: SortOrder
    notes?: SortOrder
    statusSnapshot?: SortOrder
    createdAt?: SortOrder
  }

  export type ProjectUpdateMinOrderByAggregateInput = {
    id?: SortOrder
    projectId?: SortOrder
    authorId?: SortOrder
    notes?: SortOrder
    statusSnapshot?: SortOrder
    createdAt?: SortOrder
  }

  export type EnumMediaTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.MediaType | EnumMediaTypeFieldRefInput<$PrismaModel>
    in?: $Enums.MediaType[] | ListEnumMediaTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.MediaType[] | ListEnumMediaTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumMediaTypeFilter<$PrismaModel> | $Enums.MediaType
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type ProjectUpdateNullableScalarRelationFilter = {
    is?: ProjectUpdateWhereInput | null
    isNot?: ProjectUpdateWhereInput | null
  }

  export type PaymentNullableScalarRelationFilter = {
    is?: PaymentWhereInput | null
    isNot?: PaymentWhereInput | null
  }

  export type InspectionResponseListRelationFilter = {
    every?: InspectionResponseWhereInput
    some?: InspectionResponseWhereInput
    none?: InspectionResponseWhereInput
  }

  export type QueryNullableScalarRelationFilter = {
    is?: QueryWhereInput | null
    isNot?: QueryWhereInput | null
  }

  export type InspectionResponseOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type MediaCountOrderByAggregateInput = {
    id?: SortOrder
    projectId?: SortOrder
    projectUpdateId?: SortOrder
    paymentId?: SortOrder
    type?: SortOrder
    fileKey?: SortOrder
    fileUrl?: SortOrder
    mimeType?: SortOrder
    fileSize?: SortOrder
    createdById?: SortOrder
    approvedBy?: SortOrder
    approvedAt?: SortOrder
    version?: SortOrder
    createdAt?: SortOrder
    queryId?: SortOrder
  }

  export type MediaAvgOrderByAggregateInput = {
    fileSize?: SortOrder
    version?: SortOrder
  }

  export type MediaMaxOrderByAggregateInput = {
    id?: SortOrder
    projectId?: SortOrder
    projectUpdateId?: SortOrder
    paymentId?: SortOrder
    type?: SortOrder
    fileKey?: SortOrder
    fileUrl?: SortOrder
    mimeType?: SortOrder
    fileSize?: SortOrder
    createdById?: SortOrder
    approvedBy?: SortOrder
    approvedAt?: SortOrder
    version?: SortOrder
    createdAt?: SortOrder
    queryId?: SortOrder
  }

  export type MediaMinOrderByAggregateInput = {
    id?: SortOrder
    projectId?: SortOrder
    projectUpdateId?: SortOrder
    paymentId?: SortOrder
    type?: SortOrder
    fileKey?: SortOrder
    fileUrl?: SortOrder
    mimeType?: SortOrder
    fileSize?: SortOrder
    createdById?: SortOrder
    approvedBy?: SortOrder
    approvedAt?: SortOrder
    version?: SortOrder
    createdAt?: SortOrder
    queryId?: SortOrder
  }

  export type MediaSumOrderByAggregateInput = {
    fileSize?: SortOrder
    version?: SortOrder
  }

  export type EnumMediaTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.MediaType | EnumMediaTypeFieldRefInput<$PrismaModel>
    in?: $Enums.MediaType[] | ListEnumMediaTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.MediaType[] | ListEnumMediaTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumMediaTypeWithAggregatesFilter<$PrismaModel> | $Enums.MediaType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumMediaTypeFilter<$PrismaModel>
    _max?: NestedEnumMediaTypeFilter<$PrismaModel>
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type DecimalFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
  }

  export type EnumPaymentStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentStatus | EnumPaymentStatusFieldRefInput<$PrismaModel>
    in?: $Enums.PaymentStatus[] | ListEnumPaymentStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.PaymentStatus[] | ListEnumPaymentStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumPaymentStatusFilter<$PrismaModel> | $Enums.PaymentStatus
  }

  export type EnumPaymentCategoryNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentCategory | EnumPaymentCategoryFieldRefInput<$PrismaModel> | null
    in?: $Enums.PaymentCategory[] | ListEnumPaymentCategoryFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.PaymentCategory[] | ListEnumPaymentCategoryFieldRefInput<$PrismaModel> | null
    not?: NestedEnumPaymentCategoryNullableFilter<$PrismaModel> | $Enums.PaymentCategory | null
  }

  export type PaymentCountOrderByAggregateInput = {
    id?: SortOrder
    projectId?: SortOrder
    createdById?: SortOrder
    amount?: SortOrder
    currency?: SortOrder
    status?: SortOrder
    category?: SortOrder
    invoiceNumber?: SortOrder
    paidAt?: SortOrder
    dueDate?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PaymentAvgOrderByAggregateInput = {
    amount?: SortOrder
  }

  export type PaymentMaxOrderByAggregateInput = {
    id?: SortOrder
    projectId?: SortOrder
    createdById?: SortOrder
    amount?: SortOrder
    currency?: SortOrder
    status?: SortOrder
    category?: SortOrder
    invoiceNumber?: SortOrder
    paidAt?: SortOrder
    dueDate?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PaymentMinOrderByAggregateInput = {
    id?: SortOrder
    projectId?: SortOrder
    createdById?: SortOrder
    amount?: SortOrder
    currency?: SortOrder
    status?: SortOrder
    category?: SortOrder
    invoiceNumber?: SortOrder
    paidAt?: SortOrder
    dueDate?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PaymentSumOrderByAggregateInput = {
    amount?: SortOrder
  }

  export type DecimalWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedDecimalFilter<$PrismaModel>
    _sum?: NestedDecimalFilter<$PrismaModel>
    _min?: NestedDecimalFilter<$PrismaModel>
    _max?: NestedDecimalFilter<$PrismaModel>
  }

  export type EnumPaymentStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentStatus | EnumPaymentStatusFieldRefInput<$PrismaModel>
    in?: $Enums.PaymentStatus[] | ListEnumPaymentStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.PaymentStatus[] | ListEnumPaymentStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumPaymentStatusWithAggregatesFilter<$PrismaModel> | $Enums.PaymentStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPaymentStatusFilter<$PrismaModel>
    _max?: NestedEnumPaymentStatusFilter<$PrismaModel>
  }

  export type EnumPaymentCategoryNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentCategory | EnumPaymentCategoryFieldRefInput<$PrismaModel> | null
    in?: $Enums.PaymentCategory[] | ListEnumPaymentCategoryFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.PaymentCategory[] | ListEnumPaymentCategoryFieldRefInput<$PrismaModel> | null
    not?: NestedEnumPaymentCategoryNullableWithAggregatesFilter<$PrismaModel> | $Enums.PaymentCategory | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumPaymentCategoryNullableFilter<$PrismaModel>
    _max?: NestedEnumPaymentCategoryNullableFilter<$PrismaModel>
  }

  export type EnumNotificationPriorityFilter<$PrismaModel = never> = {
    equals?: $Enums.NotificationPriority | EnumNotificationPriorityFieldRefInput<$PrismaModel>
    in?: $Enums.NotificationPriority[] | ListEnumNotificationPriorityFieldRefInput<$PrismaModel>
    notIn?: $Enums.NotificationPriority[] | ListEnumNotificationPriorityFieldRefInput<$PrismaModel>
    not?: NestedEnumNotificationPriorityFilter<$PrismaModel> | $Enums.NotificationPriority
  }

  export type NotificationCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    title?: SortOrder
    message?: SortOrder
    type?: SortOrder
    priority?: SortOrder
    actionUrl?: SortOrder
    isRead?: SortOrder
    createdAt?: SortOrder
  }

  export type NotificationMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    title?: SortOrder
    message?: SortOrder
    type?: SortOrder
    priority?: SortOrder
    actionUrl?: SortOrder
    isRead?: SortOrder
    createdAt?: SortOrder
  }

  export type NotificationMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    title?: SortOrder
    message?: SortOrder
    type?: SortOrder
    priority?: SortOrder
    actionUrl?: SortOrder
    isRead?: SortOrder
    createdAt?: SortOrder
  }

  export type EnumNotificationPriorityWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.NotificationPriority | EnumNotificationPriorityFieldRefInput<$PrismaModel>
    in?: $Enums.NotificationPriority[] | ListEnumNotificationPriorityFieldRefInput<$PrismaModel>
    notIn?: $Enums.NotificationPriority[] | ListEnumNotificationPriorityFieldRefInput<$PrismaModel>
    not?: NestedEnumNotificationPriorityWithAggregatesFilter<$PrismaModel> | $Enums.NotificationPriority
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumNotificationPriorityFilter<$PrismaModel>
    _max?: NestedEnumNotificationPriorityFilter<$PrismaModel>
  }

  export type NotificationPreferenceCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    inspectionSubmitted?: SortOrder
    paymentOverdue?: SortOrder
    newAssignment?: SortOrder
    queryCreated?: SortOrder
    drawingApproved?: SortOrder
    emailEnabled?: SortOrder
    inAppEnabled?: SortOrder
    updatedAt?: SortOrder
  }

  export type NotificationPreferenceMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    inspectionSubmitted?: SortOrder
    paymentOverdue?: SortOrder
    newAssignment?: SortOrder
    queryCreated?: SortOrder
    drawingApproved?: SortOrder
    emailEnabled?: SortOrder
    inAppEnabled?: SortOrder
    updatedAt?: SortOrder
  }

  export type NotificationPreferenceMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    inspectionSubmitted?: SortOrder
    paymentOverdue?: SortOrder
    newAssignment?: SortOrder
    queryCreated?: SortOrder
    drawingApproved?: SortOrder
    emailEnabled?: SortOrder
    inAppEnabled?: SortOrder
    updatedAt?: SortOrder
  }

  export type ChecklistItemListRelationFilter = {
    every?: ChecklistItemWhereInput
    some?: ChecklistItemWhereInput
    none?: ChecklistItemWhereInput
  }

  export type ChecklistItemOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type MilestoneCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    order?: SortOrder
    isActive?: SortOrder
    projectId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MilestoneAvgOrderByAggregateInput = {
    order?: SortOrder
  }

  export type MilestoneMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    order?: SortOrder
    isActive?: SortOrder
    projectId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MilestoneMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    order?: SortOrder
    isActive?: SortOrder
    projectId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MilestoneSumOrderByAggregateInput = {
    order?: SortOrder
  }

  export type MilestoneScalarRelationFilter = {
    is?: MilestoneWhereInput
    isNot?: MilestoneWhereInput
  }

  export type ChecklistItemCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    order?: SortOrder
    isRequired?: SortOrder
    isPhotoRequired?: SortOrder
    milestoneId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ChecklistItemAvgOrderByAggregateInput = {
    order?: SortOrder
  }

  export type ChecklistItemMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    order?: SortOrder
    isRequired?: SortOrder
    isPhotoRequired?: SortOrder
    milestoneId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ChecklistItemMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    order?: SortOrder
    isRequired?: SortOrder
    isPhotoRequired?: SortOrder
    milestoneId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ChecklistItemSumOrderByAggregateInput = {
    order?: SortOrder
  }

  export type EnumInspectionStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.InspectionStatus | EnumInspectionStatusFieldRefInput<$PrismaModel>
    in?: $Enums.InspectionStatus[] | ListEnumInspectionStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.InspectionStatus[] | ListEnumInspectionStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumInspectionStatusFilter<$PrismaModel> | $Enums.InspectionStatus
  }

  export type InspectionMilestoneIdEngineerIdStatusCompoundUniqueInput = {
    milestoneId: string
    engineerId: string
    status: $Enums.InspectionStatus
  }

  export type InspectionCountOrderByAggregateInput = {
    id?: SortOrder
    status?: SortOrder
    projectId?: SortOrder
    milestoneId?: SortOrder
    engineerId?: SortOrder
    reviewedById?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type InspectionMaxOrderByAggregateInput = {
    id?: SortOrder
    status?: SortOrder
    projectId?: SortOrder
    milestoneId?: SortOrder
    engineerId?: SortOrder
    reviewedById?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type InspectionMinOrderByAggregateInput = {
    id?: SortOrder
    status?: SortOrder
    projectId?: SortOrder
    milestoneId?: SortOrder
    engineerId?: SortOrder
    reviewedById?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumInspectionStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.InspectionStatus | EnumInspectionStatusFieldRefInput<$PrismaModel>
    in?: $Enums.InspectionStatus[] | ListEnumInspectionStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.InspectionStatus[] | ListEnumInspectionStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumInspectionStatusWithAggregatesFilter<$PrismaModel> | $Enums.InspectionStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumInspectionStatusFilter<$PrismaModel>
    _max?: NestedEnumInspectionStatusFilter<$PrismaModel>
  }

  export type EnumChecklistResultFilter<$PrismaModel = never> = {
    equals?: $Enums.ChecklistResult | EnumChecklistResultFieldRefInput<$PrismaModel>
    in?: $Enums.ChecklistResult[] | ListEnumChecklistResultFieldRefInput<$PrismaModel>
    notIn?: $Enums.ChecklistResult[] | ListEnumChecklistResultFieldRefInput<$PrismaModel>
    not?: NestedEnumChecklistResultFilter<$PrismaModel> | $Enums.ChecklistResult
  }

  export type InspectionScalarRelationFilter = {
    is?: InspectionWhereInput
    isNot?: InspectionWhereInput
  }

  export type ChecklistItemScalarRelationFilter = {
    is?: ChecklistItemWhereInput
    isNot?: ChecklistItemWhereInput
  }

  export type MediaNullableScalarRelationFilter = {
    is?: MediaWhereInput | null
    isNot?: MediaWhereInput | null
  }

  export type InspectionResponseCountOrderByAggregateInput = {
    id?: SortOrder
    result?: SortOrder
    remark?: SortOrder
    inspectionId?: SortOrder
    checklistItemId?: SortOrder
    mediaId?: SortOrder
  }

  export type InspectionResponseMaxOrderByAggregateInput = {
    id?: SortOrder
    result?: SortOrder
    remark?: SortOrder
    inspectionId?: SortOrder
    checklistItemId?: SortOrder
    mediaId?: SortOrder
  }

  export type InspectionResponseMinOrderByAggregateInput = {
    id?: SortOrder
    result?: SortOrder
    remark?: SortOrder
    inspectionId?: SortOrder
    checklistItemId?: SortOrder
    mediaId?: SortOrder
  }

  export type EnumChecklistResultWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ChecklistResult | EnumChecklistResultFieldRefInput<$PrismaModel>
    in?: $Enums.ChecklistResult[] | ListEnumChecklistResultFieldRefInput<$PrismaModel>
    notIn?: $Enums.ChecklistResult[] | ListEnumChecklistResultFieldRefInput<$PrismaModel>
    not?: NestedEnumChecklistResultWithAggregatesFilter<$PrismaModel> | $Enums.ChecklistResult
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumChecklistResultFilter<$PrismaModel>
    _max?: NestedEnumChecklistResultFilter<$PrismaModel>
  }

  export type EnumQueryStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.QueryStatus | EnumQueryStatusFieldRefInput<$PrismaModel>
    in?: $Enums.QueryStatus[] | ListEnumQueryStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.QueryStatus[] | ListEnumQueryStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumQueryStatusFilter<$PrismaModel> | $Enums.QueryStatus
  }

  export type EnumQueryPriorityFilter<$PrismaModel = never> = {
    equals?: $Enums.QueryPriority | EnumQueryPriorityFieldRefInput<$PrismaModel>
    in?: $Enums.QueryPriority[] | ListEnumQueryPriorityFieldRefInput<$PrismaModel>
    notIn?: $Enums.QueryPriority[] | ListEnumQueryPriorityFieldRefInput<$PrismaModel>
    not?: NestedEnumQueryPriorityFilter<$PrismaModel> | $Enums.QueryPriority
  }

  export type QueryCountOrderByAggregateInput = {
    id?: SortOrder
    projectId?: SortOrder
    authorId?: SortOrder
    title?: SortOrder
    description?: SortOrder
    status?: SortOrder
    priority?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type QueryMaxOrderByAggregateInput = {
    id?: SortOrder
    projectId?: SortOrder
    authorId?: SortOrder
    title?: SortOrder
    description?: SortOrder
    status?: SortOrder
    priority?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type QueryMinOrderByAggregateInput = {
    id?: SortOrder
    projectId?: SortOrder
    authorId?: SortOrder
    title?: SortOrder
    description?: SortOrder
    status?: SortOrder
    priority?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumQueryStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.QueryStatus | EnumQueryStatusFieldRefInput<$PrismaModel>
    in?: $Enums.QueryStatus[] | ListEnumQueryStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.QueryStatus[] | ListEnumQueryStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumQueryStatusWithAggregatesFilter<$PrismaModel> | $Enums.QueryStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumQueryStatusFilter<$PrismaModel>
    _max?: NestedEnumQueryStatusFilter<$PrismaModel>
  }

  export type EnumQueryPriorityWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.QueryPriority | EnumQueryPriorityFieldRefInput<$PrismaModel>
    in?: $Enums.QueryPriority[] | ListEnumQueryPriorityFieldRefInput<$PrismaModel>
    notIn?: $Enums.QueryPriority[] | ListEnumQueryPriorityFieldRefInput<$PrismaModel>
    not?: NestedEnumQueryPriorityWithAggregatesFilter<$PrismaModel> | $Enums.QueryPriority
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumQueryPriorityFilter<$PrismaModel>
    _max?: NestedEnumQueryPriorityFilter<$PrismaModel>
  }

  export type QueryScalarRelationFilter = {
    is?: QueryWhereInput
    isNot?: QueryWhereInput
  }

  export type QueryResponseCountOrderByAggregateInput = {
    id?: SortOrder
    queryId?: SortOrder
    authorId?: SortOrder
    message?: SortOrder
    createdAt?: SortOrder
  }

  export type QueryResponseMaxOrderByAggregateInput = {
    id?: SortOrder
    queryId?: SortOrder
    authorId?: SortOrder
    message?: SortOrder
    createdAt?: SortOrder
  }

  export type QueryResponseMinOrderByAggregateInput = {
    id?: SortOrder
    queryId?: SortOrder
    authorId?: SortOrder
    message?: SortOrder
    createdAt?: SortOrder
  }
  export type JsonNullableFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type ProjectNullableScalarRelationFilter = {
    is?: ProjectWhereInput | null
    isNot?: ProjectWhereInput | null
  }

  export type AuditLogCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    action?: SortOrder
    entity?: SortOrder
    entityId?: SortOrder
    projectId?: SortOrder
    metadata?: SortOrder
    createdAt?: SortOrder
  }

  export type AuditLogMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    action?: SortOrder
    entity?: SortOrder
    entityId?: SortOrder
    projectId?: SortOrder
    createdAt?: SortOrder
  }

  export type AuditLogMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    action?: SortOrder
    entity?: SortOrder
    entityId?: SortOrder
    projectId?: SortOrder
    createdAt?: SortOrder
  }
  export type JsonNullableWithAggregatesFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedJsonNullableFilter<$PrismaModel>
    _max?: NestedJsonNullableFilter<$PrismaModel>
  }

  export type FloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type EnumMaterialStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.MaterialStatus | EnumMaterialStatusFieldRefInput<$PrismaModel>
    in?: $Enums.MaterialStatus[] | ListEnumMaterialStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.MaterialStatus[] | ListEnumMaterialStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumMaterialStatusFilter<$PrismaModel> | $Enums.MaterialStatus
  }

  export type MaterialCountOrderByAggregateInput = {
    id?: SortOrder
    projectId?: SortOrder
    name?: SortOrder
    quantity?: SortOrder
    unit?: SortOrder
    unitCost?: SortOrder
    totalCost?: SortOrder
    supplier?: SortOrder
    status?: SortOrder
    createdById?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MaterialAvgOrderByAggregateInput = {
    quantity?: SortOrder
    unitCost?: SortOrder
    totalCost?: SortOrder
  }

  export type MaterialMaxOrderByAggregateInput = {
    id?: SortOrder
    projectId?: SortOrder
    name?: SortOrder
    quantity?: SortOrder
    unit?: SortOrder
    unitCost?: SortOrder
    totalCost?: SortOrder
    supplier?: SortOrder
    status?: SortOrder
    createdById?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MaterialMinOrderByAggregateInput = {
    id?: SortOrder
    projectId?: SortOrder
    name?: SortOrder
    quantity?: SortOrder
    unit?: SortOrder
    unitCost?: SortOrder
    totalCost?: SortOrder
    supplier?: SortOrder
    status?: SortOrder
    createdById?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MaterialSumOrderByAggregateInput = {
    quantity?: SortOrder
    unitCost?: SortOrder
    totalCost?: SortOrder
  }

  export type FloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type EnumMaterialStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.MaterialStatus | EnumMaterialStatusFieldRefInput<$PrismaModel>
    in?: $Enums.MaterialStatus[] | ListEnumMaterialStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.MaterialStatus[] | ListEnumMaterialStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumMaterialStatusWithAggregatesFilter<$PrismaModel> | $Enums.MaterialStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumMaterialStatusFilter<$PrismaModel>
    _max?: NestedEnumMaterialStatusFilter<$PrismaModel>
  }

  export type UserCreateNestedOneWithoutCreatedUsersInput = {
    create?: XOR<UserCreateWithoutCreatedUsersInput, UserUncheckedCreateWithoutCreatedUsersInput>
    connectOrCreate?: UserCreateOrConnectWithoutCreatedUsersInput
    connect?: UserWhereUniqueInput
  }

  export type UserCreateNestedManyWithoutCreatedByInput = {
    create?: XOR<UserCreateWithoutCreatedByInput, UserUncheckedCreateWithoutCreatedByInput> | UserCreateWithoutCreatedByInput[] | UserUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: UserCreateOrConnectWithoutCreatedByInput | UserCreateOrConnectWithoutCreatedByInput[]
    createMany?: UserCreateManyCreatedByInputEnvelope
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
  }

  export type ProjectCreateNestedManyWithoutManagerInput = {
    create?: XOR<ProjectCreateWithoutManagerInput, ProjectUncheckedCreateWithoutManagerInput> | ProjectCreateWithoutManagerInput[] | ProjectUncheckedCreateWithoutManagerInput[]
    connectOrCreate?: ProjectCreateOrConnectWithoutManagerInput | ProjectCreateOrConnectWithoutManagerInput[]
    createMany?: ProjectCreateManyManagerInputEnvelope
    connect?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
  }

  export type ProjectCreateNestedManyWithoutClientInput = {
    create?: XOR<ProjectCreateWithoutClientInput, ProjectUncheckedCreateWithoutClientInput> | ProjectCreateWithoutClientInput[] | ProjectUncheckedCreateWithoutClientInput[]
    connectOrCreate?: ProjectCreateOrConnectWithoutClientInput | ProjectCreateOrConnectWithoutClientInput[]
    createMany?: ProjectCreateManyClientInputEnvelope
    connect?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
  }

  export type ProjectMemberCreateNestedManyWithoutUserInput = {
    create?: XOR<ProjectMemberCreateWithoutUserInput, ProjectMemberUncheckedCreateWithoutUserInput> | ProjectMemberCreateWithoutUserInput[] | ProjectMemberUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ProjectMemberCreateOrConnectWithoutUserInput | ProjectMemberCreateOrConnectWithoutUserInput[]
    createMany?: ProjectMemberCreateManyUserInputEnvelope
    connect?: ProjectMemberWhereUniqueInput | ProjectMemberWhereUniqueInput[]
  }

  export type ProjectUpdateCreateNestedManyWithoutAuthorInput = {
    create?: XOR<ProjectUpdateCreateWithoutAuthorInput, ProjectUpdateUncheckedCreateWithoutAuthorInput> | ProjectUpdateCreateWithoutAuthorInput[] | ProjectUpdateUncheckedCreateWithoutAuthorInput[]
    connectOrCreate?: ProjectUpdateCreateOrConnectWithoutAuthorInput | ProjectUpdateCreateOrConnectWithoutAuthorInput[]
    createMany?: ProjectUpdateCreateManyAuthorInputEnvelope
    connect?: ProjectUpdateWhereUniqueInput | ProjectUpdateWhereUniqueInput[]
  }

  export type MediaCreateNestedManyWithoutCreatedByInput = {
    create?: XOR<MediaCreateWithoutCreatedByInput, MediaUncheckedCreateWithoutCreatedByInput> | MediaCreateWithoutCreatedByInput[] | MediaUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: MediaCreateOrConnectWithoutCreatedByInput | MediaCreateOrConnectWithoutCreatedByInput[]
    createMany?: MediaCreateManyCreatedByInputEnvelope
    connect?: MediaWhereUniqueInput | MediaWhereUniqueInput[]
  }

  export type PaymentCreateNestedManyWithoutCreatedByInput = {
    create?: XOR<PaymentCreateWithoutCreatedByInput, PaymentUncheckedCreateWithoutCreatedByInput> | PaymentCreateWithoutCreatedByInput[] | PaymentUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: PaymentCreateOrConnectWithoutCreatedByInput | PaymentCreateOrConnectWithoutCreatedByInput[]
    createMany?: PaymentCreateManyCreatedByInputEnvelope
    connect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
  }

  export type NotificationCreateNestedManyWithoutUserInput = {
    create?: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput> | NotificationCreateWithoutUserInput[] | NotificationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutUserInput | NotificationCreateOrConnectWithoutUserInput[]
    createMany?: NotificationCreateManyUserInputEnvelope
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
  }

  export type ProjectCreateNestedManyWithoutCreatedByInput = {
    create?: XOR<ProjectCreateWithoutCreatedByInput, ProjectUncheckedCreateWithoutCreatedByInput> | ProjectCreateWithoutCreatedByInput[] | ProjectUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: ProjectCreateOrConnectWithoutCreatedByInput | ProjectCreateOrConnectWithoutCreatedByInput[]
    createMany?: ProjectCreateManyCreatedByInputEnvelope
    connect?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
  }

  export type InspectionCreateNestedManyWithoutEngineerInput = {
    create?: XOR<InspectionCreateWithoutEngineerInput, InspectionUncheckedCreateWithoutEngineerInput> | InspectionCreateWithoutEngineerInput[] | InspectionUncheckedCreateWithoutEngineerInput[]
    connectOrCreate?: InspectionCreateOrConnectWithoutEngineerInput | InspectionCreateOrConnectWithoutEngineerInput[]
    createMany?: InspectionCreateManyEngineerInputEnvelope
    connect?: InspectionWhereUniqueInput | InspectionWhereUniqueInput[]
  }

  export type InspectionCreateNestedManyWithoutReviewedByInput = {
    create?: XOR<InspectionCreateWithoutReviewedByInput, InspectionUncheckedCreateWithoutReviewedByInput> | InspectionCreateWithoutReviewedByInput[] | InspectionUncheckedCreateWithoutReviewedByInput[]
    connectOrCreate?: InspectionCreateOrConnectWithoutReviewedByInput | InspectionCreateOrConnectWithoutReviewedByInput[]
    createMany?: InspectionCreateManyReviewedByInputEnvelope
    connect?: InspectionWhereUniqueInput | InspectionWhereUniqueInput[]
  }

  export type QueryCreateNestedManyWithoutAuthorInput = {
    create?: XOR<QueryCreateWithoutAuthorInput, QueryUncheckedCreateWithoutAuthorInput> | QueryCreateWithoutAuthorInput[] | QueryUncheckedCreateWithoutAuthorInput[]
    connectOrCreate?: QueryCreateOrConnectWithoutAuthorInput | QueryCreateOrConnectWithoutAuthorInput[]
    createMany?: QueryCreateManyAuthorInputEnvelope
    connect?: QueryWhereUniqueInput | QueryWhereUniqueInput[]
  }

  export type QueryResponseCreateNestedManyWithoutAuthorInput = {
    create?: XOR<QueryResponseCreateWithoutAuthorInput, QueryResponseUncheckedCreateWithoutAuthorInput> | QueryResponseCreateWithoutAuthorInput[] | QueryResponseUncheckedCreateWithoutAuthorInput[]
    connectOrCreate?: QueryResponseCreateOrConnectWithoutAuthorInput | QueryResponseCreateOrConnectWithoutAuthorInput[]
    createMany?: QueryResponseCreateManyAuthorInputEnvelope
    connect?: QueryResponseWhereUniqueInput | QueryResponseWhereUniqueInput[]
  }

  export type AuditLogCreateNestedManyWithoutUserInput = {
    create?: XOR<AuditLogCreateWithoutUserInput, AuditLogUncheckedCreateWithoutUserInput> | AuditLogCreateWithoutUserInput[] | AuditLogUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AuditLogCreateOrConnectWithoutUserInput | AuditLogCreateOrConnectWithoutUserInput[]
    createMany?: AuditLogCreateManyUserInputEnvelope
    connect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
  }

  export type NotificationPreferenceCreateNestedOneWithoutUserInput = {
    create?: XOR<NotificationPreferenceCreateWithoutUserInput, NotificationPreferenceUncheckedCreateWithoutUserInput>
    connectOrCreate?: NotificationPreferenceCreateOrConnectWithoutUserInput
    connect?: NotificationPreferenceWhereUniqueInput
  }

  export type MaterialCreateNestedManyWithoutCreatedByInput = {
    create?: XOR<MaterialCreateWithoutCreatedByInput, MaterialUncheckedCreateWithoutCreatedByInput> | MaterialCreateWithoutCreatedByInput[] | MaterialUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: MaterialCreateOrConnectWithoutCreatedByInput | MaterialCreateOrConnectWithoutCreatedByInput[]
    createMany?: MaterialCreateManyCreatedByInputEnvelope
    connect?: MaterialWhereUniqueInput | MaterialWhereUniqueInput[]
  }

  export type UserUncheckedCreateNestedManyWithoutCreatedByInput = {
    create?: XOR<UserCreateWithoutCreatedByInput, UserUncheckedCreateWithoutCreatedByInput> | UserCreateWithoutCreatedByInput[] | UserUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: UserCreateOrConnectWithoutCreatedByInput | UserCreateOrConnectWithoutCreatedByInput[]
    createMany?: UserCreateManyCreatedByInputEnvelope
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
  }

  export type ProjectUncheckedCreateNestedManyWithoutManagerInput = {
    create?: XOR<ProjectCreateWithoutManagerInput, ProjectUncheckedCreateWithoutManagerInput> | ProjectCreateWithoutManagerInput[] | ProjectUncheckedCreateWithoutManagerInput[]
    connectOrCreate?: ProjectCreateOrConnectWithoutManagerInput | ProjectCreateOrConnectWithoutManagerInput[]
    createMany?: ProjectCreateManyManagerInputEnvelope
    connect?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
  }

  export type ProjectUncheckedCreateNestedManyWithoutClientInput = {
    create?: XOR<ProjectCreateWithoutClientInput, ProjectUncheckedCreateWithoutClientInput> | ProjectCreateWithoutClientInput[] | ProjectUncheckedCreateWithoutClientInput[]
    connectOrCreate?: ProjectCreateOrConnectWithoutClientInput | ProjectCreateOrConnectWithoutClientInput[]
    createMany?: ProjectCreateManyClientInputEnvelope
    connect?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
  }

  export type ProjectMemberUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<ProjectMemberCreateWithoutUserInput, ProjectMemberUncheckedCreateWithoutUserInput> | ProjectMemberCreateWithoutUserInput[] | ProjectMemberUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ProjectMemberCreateOrConnectWithoutUserInput | ProjectMemberCreateOrConnectWithoutUserInput[]
    createMany?: ProjectMemberCreateManyUserInputEnvelope
    connect?: ProjectMemberWhereUniqueInput | ProjectMemberWhereUniqueInput[]
  }

  export type ProjectUpdateUncheckedCreateNestedManyWithoutAuthorInput = {
    create?: XOR<ProjectUpdateCreateWithoutAuthorInput, ProjectUpdateUncheckedCreateWithoutAuthorInput> | ProjectUpdateCreateWithoutAuthorInput[] | ProjectUpdateUncheckedCreateWithoutAuthorInput[]
    connectOrCreate?: ProjectUpdateCreateOrConnectWithoutAuthorInput | ProjectUpdateCreateOrConnectWithoutAuthorInput[]
    createMany?: ProjectUpdateCreateManyAuthorInputEnvelope
    connect?: ProjectUpdateWhereUniqueInput | ProjectUpdateWhereUniqueInput[]
  }

  export type MediaUncheckedCreateNestedManyWithoutCreatedByInput = {
    create?: XOR<MediaCreateWithoutCreatedByInput, MediaUncheckedCreateWithoutCreatedByInput> | MediaCreateWithoutCreatedByInput[] | MediaUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: MediaCreateOrConnectWithoutCreatedByInput | MediaCreateOrConnectWithoutCreatedByInput[]
    createMany?: MediaCreateManyCreatedByInputEnvelope
    connect?: MediaWhereUniqueInput | MediaWhereUniqueInput[]
  }

  export type PaymentUncheckedCreateNestedManyWithoutCreatedByInput = {
    create?: XOR<PaymentCreateWithoutCreatedByInput, PaymentUncheckedCreateWithoutCreatedByInput> | PaymentCreateWithoutCreatedByInput[] | PaymentUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: PaymentCreateOrConnectWithoutCreatedByInput | PaymentCreateOrConnectWithoutCreatedByInput[]
    createMany?: PaymentCreateManyCreatedByInputEnvelope
    connect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
  }

  export type NotificationUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput> | NotificationCreateWithoutUserInput[] | NotificationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutUserInput | NotificationCreateOrConnectWithoutUserInput[]
    createMany?: NotificationCreateManyUserInputEnvelope
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
  }

  export type ProjectUncheckedCreateNestedManyWithoutCreatedByInput = {
    create?: XOR<ProjectCreateWithoutCreatedByInput, ProjectUncheckedCreateWithoutCreatedByInput> | ProjectCreateWithoutCreatedByInput[] | ProjectUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: ProjectCreateOrConnectWithoutCreatedByInput | ProjectCreateOrConnectWithoutCreatedByInput[]
    createMany?: ProjectCreateManyCreatedByInputEnvelope
    connect?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
  }

  export type InspectionUncheckedCreateNestedManyWithoutEngineerInput = {
    create?: XOR<InspectionCreateWithoutEngineerInput, InspectionUncheckedCreateWithoutEngineerInput> | InspectionCreateWithoutEngineerInput[] | InspectionUncheckedCreateWithoutEngineerInput[]
    connectOrCreate?: InspectionCreateOrConnectWithoutEngineerInput | InspectionCreateOrConnectWithoutEngineerInput[]
    createMany?: InspectionCreateManyEngineerInputEnvelope
    connect?: InspectionWhereUniqueInput | InspectionWhereUniqueInput[]
  }

  export type InspectionUncheckedCreateNestedManyWithoutReviewedByInput = {
    create?: XOR<InspectionCreateWithoutReviewedByInput, InspectionUncheckedCreateWithoutReviewedByInput> | InspectionCreateWithoutReviewedByInput[] | InspectionUncheckedCreateWithoutReviewedByInput[]
    connectOrCreate?: InspectionCreateOrConnectWithoutReviewedByInput | InspectionCreateOrConnectWithoutReviewedByInput[]
    createMany?: InspectionCreateManyReviewedByInputEnvelope
    connect?: InspectionWhereUniqueInput | InspectionWhereUniqueInput[]
  }

  export type QueryUncheckedCreateNestedManyWithoutAuthorInput = {
    create?: XOR<QueryCreateWithoutAuthorInput, QueryUncheckedCreateWithoutAuthorInput> | QueryCreateWithoutAuthorInput[] | QueryUncheckedCreateWithoutAuthorInput[]
    connectOrCreate?: QueryCreateOrConnectWithoutAuthorInput | QueryCreateOrConnectWithoutAuthorInput[]
    createMany?: QueryCreateManyAuthorInputEnvelope
    connect?: QueryWhereUniqueInput | QueryWhereUniqueInput[]
  }

  export type QueryResponseUncheckedCreateNestedManyWithoutAuthorInput = {
    create?: XOR<QueryResponseCreateWithoutAuthorInput, QueryResponseUncheckedCreateWithoutAuthorInput> | QueryResponseCreateWithoutAuthorInput[] | QueryResponseUncheckedCreateWithoutAuthorInput[]
    connectOrCreate?: QueryResponseCreateOrConnectWithoutAuthorInput | QueryResponseCreateOrConnectWithoutAuthorInput[]
    createMany?: QueryResponseCreateManyAuthorInputEnvelope
    connect?: QueryResponseWhereUniqueInput | QueryResponseWhereUniqueInput[]
  }

  export type AuditLogUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<AuditLogCreateWithoutUserInput, AuditLogUncheckedCreateWithoutUserInput> | AuditLogCreateWithoutUserInput[] | AuditLogUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AuditLogCreateOrConnectWithoutUserInput | AuditLogCreateOrConnectWithoutUserInput[]
    createMany?: AuditLogCreateManyUserInputEnvelope
    connect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
  }

  export type NotificationPreferenceUncheckedCreateNestedOneWithoutUserInput = {
    create?: XOR<NotificationPreferenceCreateWithoutUserInput, NotificationPreferenceUncheckedCreateWithoutUserInput>
    connectOrCreate?: NotificationPreferenceCreateOrConnectWithoutUserInput
    connect?: NotificationPreferenceWhereUniqueInput
  }

  export type MaterialUncheckedCreateNestedManyWithoutCreatedByInput = {
    create?: XOR<MaterialCreateWithoutCreatedByInput, MaterialUncheckedCreateWithoutCreatedByInput> | MaterialCreateWithoutCreatedByInput[] | MaterialUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: MaterialCreateOrConnectWithoutCreatedByInput | MaterialCreateOrConnectWithoutCreatedByInput[]
    createMany?: MaterialCreateManyCreatedByInputEnvelope
    connect?: MaterialWhereUniqueInput | MaterialWhereUniqueInput[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type EnumRoleFieldUpdateOperationsInput = {
    set?: $Enums.Role
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type UserUpdateOneWithoutCreatedUsersNestedInput = {
    create?: XOR<UserCreateWithoutCreatedUsersInput, UserUncheckedCreateWithoutCreatedUsersInput>
    connectOrCreate?: UserCreateOrConnectWithoutCreatedUsersInput
    upsert?: UserUpsertWithoutCreatedUsersInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutCreatedUsersInput, UserUpdateWithoutCreatedUsersInput>, UserUncheckedUpdateWithoutCreatedUsersInput>
  }

  export type UserUpdateManyWithoutCreatedByNestedInput = {
    create?: XOR<UserCreateWithoutCreatedByInput, UserUncheckedCreateWithoutCreatedByInput> | UserCreateWithoutCreatedByInput[] | UserUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: UserCreateOrConnectWithoutCreatedByInput | UserCreateOrConnectWithoutCreatedByInput[]
    upsert?: UserUpsertWithWhereUniqueWithoutCreatedByInput | UserUpsertWithWhereUniqueWithoutCreatedByInput[]
    createMany?: UserCreateManyCreatedByInputEnvelope
    set?: UserWhereUniqueInput | UserWhereUniqueInput[]
    disconnect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    delete?: UserWhereUniqueInput | UserWhereUniqueInput[]
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    update?: UserUpdateWithWhereUniqueWithoutCreatedByInput | UserUpdateWithWhereUniqueWithoutCreatedByInput[]
    updateMany?: UserUpdateManyWithWhereWithoutCreatedByInput | UserUpdateManyWithWhereWithoutCreatedByInput[]
    deleteMany?: UserScalarWhereInput | UserScalarWhereInput[]
  }

  export type ProjectUpdateManyWithoutManagerNestedInput = {
    create?: XOR<ProjectCreateWithoutManagerInput, ProjectUncheckedCreateWithoutManagerInput> | ProjectCreateWithoutManagerInput[] | ProjectUncheckedCreateWithoutManagerInput[]
    connectOrCreate?: ProjectCreateOrConnectWithoutManagerInput | ProjectCreateOrConnectWithoutManagerInput[]
    upsert?: ProjectUpsertWithWhereUniqueWithoutManagerInput | ProjectUpsertWithWhereUniqueWithoutManagerInput[]
    createMany?: ProjectCreateManyManagerInputEnvelope
    set?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
    disconnect?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
    delete?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
    connect?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
    update?: ProjectUpdateWithWhereUniqueWithoutManagerInput | ProjectUpdateWithWhereUniqueWithoutManagerInput[]
    updateMany?: ProjectUpdateManyWithWhereWithoutManagerInput | ProjectUpdateManyWithWhereWithoutManagerInput[]
    deleteMany?: ProjectScalarWhereInput | ProjectScalarWhereInput[]
  }

  export type ProjectUpdateManyWithoutClientNestedInput = {
    create?: XOR<ProjectCreateWithoutClientInput, ProjectUncheckedCreateWithoutClientInput> | ProjectCreateWithoutClientInput[] | ProjectUncheckedCreateWithoutClientInput[]
    connectOrCreate?: ProjectCreateOrConnectWithoutClientInput | ProjectCreateOrConnectWithoutClientInput[]
    upsert?: ProjectUpsertWithWhereUniqueWithoutClientInput | ProjectUpsertWithWhereUniqueWithoutClientInput[]
    createMany?: ProjectCreateManyClientInputEnvelope
    set?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
    disconnect?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
    delete?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
    connect?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
    update?: ProjectUpdateWithWhereUniqueWithoutClientInput | ProjectUpdateWithWhereUniqueWithoutClientInput[]
    updateMany?: ProjectUpdateManyWithWhereWithoutClientInput | ProjectUpdateManyWithWhereWithoutClientInput[]
    deleteMany?: ProjectScalarWhereInput | ProjectScalarWhereInput[]
  }

  export type ProjectMemberUpdateManyWithoutUserNestedInput = {
    create?: XOR<ProjectMemberCreateWithoutUserInput, ProjectMemberUncheckedCreateWithoutUserInput> | ProjectMemberCreateWithoutUserInput[] | ProjectMemberUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ProjectMemberCreateOrConnectWithoutUserInput | ProjectMemberCreateOrConnectWithoutUserInput[]
    upsert?: ProjectMemberUpsertWithWhereUniqueWithoutUserInput | ProjectMemberUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ProjectMemberCreateManyUserInputEnvelope
    set?: ProjectMemberWhereUniqueInput | ProjectMemberWhereUniqueInput[]
    disconnect?: ProjectMemberWhereUniqueInput | ProjectMemberWhereUniqueInput[]
    delete?: ProjectMemberWhereUniqueInput | ProjectMemberWhereUniqueInput[]
    connect?: ProjectMemberWhereUniqueInput | ProjectMemberWhereUniqueInput[]
    update?: ProjectMemberUpdateWithWhereUniqueWithoutUserInput | ProjectMemberUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ProjectMemberUpdateManyWithWhereWithoutUserInput | ProjectMemberUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ProjectMemberScalarWhereInput | ProjectMemberScalarWhereInput[]
  }

  export type ProjectUpdateUpdateManyWithoutAuthorNestedInput = {
    create?: XOR<ProjectUpdateCreateWithoutAuthorInput, ProjectUpdateUncheckedCreateWithoutAuthorInput> | ProjectUpdateCreateWithoutAuthorInput[] | ProjectUpdateUncheckedCreateWithoutAuthorInput[]
    connectOrCreate?: ProjectUpdateCreateOrConnectWithoutAuthorInput | ProjectUpdateCreateOrConnectWithoutAuthorInput[]
    upsert?: ProjectUpdateUpsertWithWhereUniqueWithoutAuthorInput | ProjectUpdateUpsertWithWhereUniqueWithoutAuthorInput[]
    createMany?: ProjectUpdateCreateManyAuthorInputEnvelope
    set?: ProjectUpdateWhereUniqueInput | ProjectUpdateWhereUniqueInput[]
    disconnect?: ProjectUpdateWhereUniqueInput | ProjectUpdateWhereUniqueInput[]
    delete?: ProjectUpdateWhereUniqueInput | ProjectUpdateWhereUniqueInput[]
    connect?: ProjectUpdateWhereUniqueInput | ProjectUpdateWhereUniqueInput[]
    update?: ProjectUpdateUpdateWithWhereUniqueWithoutAuthorInput | ProjectUpdateUpdateWithWhereUniqueWithoutAuthorInput[]
    updateMany?: ProjectUpdateUpdateManyWithWhereWithoutAuthorInput | ProjectUpdateUpdateManyWithWhereWithoutAuthorInput[]
    deleteMany?: ProjectUpdateScalarWhereInput | ProjectUpdateScalarWhereInput[]
  }

  export type MediaUpdateManyWithoutCreatedByNestedInput = {
    create?: XOR<MediaCreateWithoutCreatedByInput, MediaUncheckedCreateWithoutCreatedByInput> | MediaCreateWithoutCreatedByInput[] | MediaUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: MediaCreateOrConnectWithoutCreatedByInput | MediaCreateOrConnectWithoutCreatedByInput[]
    upsert?: MediaUpsertWithWhereUniqueWithoutCreatedByInput | MediaUpsertWithWhereUniqueWithoutCreatedByInput[]
    createMany?: MediaCreateManyCreatedByInputEnvelope
    set?: MediaWhereUniqueInput | MediaWhereUniqueInput[]
    disconnect?: MediaWhereUniqueInput | MediaWhereUniqueInput[]
    delete?: MediaWhereUniqueInput | MediaWhereUniqueInput[]
    connect?: MediaWhereUniqueInput | MediaWhereUniqueInput[]
    update?: MediaUpdateWithWhereUniqueWithoutCreatedByInput | MediaUpdateWithWhereUniqueWithoutCreatedByInput[]
    updateMany?: MediaUpdateManyWithWhereWithoutCreatedByInput | MediaUpdateManyWithWhereWithoutCreatedByInput[]
    deleteMany?: MediaScalarWhereInput | MediaScalarWhereInput[]
  }

  export type PaymentUpdateManyWithoutCreatedByNestedInput = {
    create?: XOR<PaymentCreateWithoutCreatedByInput, PaymentUncheckedCreateWithoutCreatedByInput> | PaymentCreateWithoutCreatedByInput[] | PaymentUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: PaymentCreateOrConnectWithoutCreatedByInput | PaymentCreateOrConnectWithoutCreatedByInput[]
    upsert?: PaymentUpsertWithWhereUniqueWithoutCreatedByInput | PaymentUpsertWithWhereUniqueWithoutCreatedByInput[]
    createMany?: PaymentCreateManyCreatedByInputEnvelope
    set?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    disconnect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    delete?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    connect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    update?: PaymentUpdateWithWhereUniqueWithoutCreatedByInput | PaymentUpdateWithWhereUniqueWithoutCreatedByInput[]
    updateMany?: PaymentUpdateManyWithWhereWithoutCreatedByInput | PaymentUpdateManyWithWhereWithoutCreatedByInput[]
    deleteMany?: PaymentScalarWhereInput | PaymentScalarWhereInput[]
  }

  export type NotificationUpdateManyWithoutUserNestedInput = {
    create?: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput> | NotificationCreateWithoutUserInput[] | NotificationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutUserInput | NotificationCreateOrConnectWithoutUserInput[]
    upsert?: NotificationUpsertWithWhereUniqueWithoutUserInput | NotificationUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: NotificationCreateManyUserInputEnvelope
    set?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    disconnect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    delete?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    update?: NotificationUpdateWithWhereUniqueWithoutUserInput | NotificationUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: NotificationUpdateManyWithWhereWithoutUserInput | NotificationUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
  }

  export type ProjectUpdateManyWithoutCreatedByNestedInput = {
    create?: XOR<ProjectCreateWithoutCreatedByInput, ProjectUncheckedCreateWithoutCreatedByInput> | ProjectCreateWithoutCreatedByInput[] | ProjectUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: ProjectCreateOrConnectWithoutCreatedByInput | ProjectCreateOrConnectWithoutCreatedByInput[]
    upsert?: ProjectUpsertWithWhereUniqueWithoutCreatedByInput | ProjectUpsertWithWhereUniqueWithoutCreatedByInput[]
    createMany?: ProjectCreateManyCreatedByInputEnvelope
    set?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
    disconnect?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
    delete?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
    connect?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
    update?: ProjectUpdateWithWhereUniqueWithoutCreatedByInput | ProjectUpdateWithWhereUniqueWithoutCreatedByInput[]
    updateMany?: ProjectUpdateManyWithWhereWithoutCreatedByInput | ProjectUpdateManyWithWhereWithoutCreatedByInput[]
    deleteMany?: ProjectScalarWhereInput | ProjectScalarWhereInput[]
  }

  export type InspectionUpdateManyWithoutEngineerNestedInput = {
    create?: XOR<InspectionCreateWithoutEngineerInput, InspectionUncheckedCreateWithoutEngineerInput> | InspectionCreateWithoutEngineerInput[] | InspectionUncheckedCreateWithoutEngineerInput[]
    connectOrCreate?: InspectionCreateOrConnectWithoutEngineerInput | InspectionCreateOrConnectWithoutEngineerInput[]
    upsert?: InspectionUpsertWithWhereUniqueWithoutEngineerInput | InspectionUpsertWithWhereUniqueWithoutEngineerInput[]
    createMany?: InspectionCreateManyEngineerInputEnvelope
    set?: InspectionWhereUniqueInput | InspectionWhereUniqueInput[]
    disconnect?: InspectionWhereUniqueInput | InspectionWhereUniqueInput[]
    delete?: InspectionWhereUniqueInput | InspectionWhereUniqueInput[]
    connect?: InspectionWhereUniqueInput | InspectionWhereUniqueInput[]
    update?: InspectionUpdateWithWhereUniqueWithoutEngineerInput | InspectionUpdateWithWhereUniqueWithoutEngineerInput[]
    updateMany?: InspectionUpdateManyWithWhereWithoutEngineerInput | InspectionUpdateManyWithWhereWithoutEngineerInput[]
    deleteMany?: InspectionScalarWhereInput | InspectionScalarWhereInput[]
  }

  export type InspectionUpdateManyWithoutReviewedByNestedInput = {
    create?: XOR<InspectionCreateWithoutReviewedByInput, InspectionUncheckedCreateWithoutReviewedByInput> | InspectionCreateWithoutReviewedByInput[] | InspectionUncheckedCreateWithoutReviewedByInput[]
    connectOrCreate?: InspectionCreateOrConnectWithoutReviewedByInput | InspectionCreateOrConnectWithoutReviewedByInput[]
    upsert?: InspectionUpsertWithWhereUniqueWithoutReviewedByInput | InspectionUpsertWithWhereUniqueWithoutReviewedByInput[]
    createMany?: InspectionCreateManyReviewedByInputEnvelope
    set?: InspectionWhereUniqueInput | InspectionWhereUniqueInput[]
    disconnect?: InspectionWhereUniqueInput | InspectionWhereUniqueInput[]
    delete?: InspectionWhereUniqueInput | InspectionWhereUniqueInput[]
    connect?: InspectionWhereUniqueInput | InspectionWhereUniqueInput[]
    update?: InspectionUpdateWithWhereUniqueWithoutReviewedByInput | InspectionUpdateWithWhereUniqueWithoutReviewedByInput[]
    updateMany?: InspectionUpdateManyWithWhereWithoutReviewedByInput | InspectionUpdateManyWithWhereWithoutReviewedByInput[]
    deleteMany?: InspectionScalarWhereInput | InspectionScalarWhereInput[]
  }

  export type QueryUpdateManyWithoutAuthorNestedInput = {
    create?: XOR<QueryCreateWithoutAuthorInput, QueryUncheckedCreateWithoutAuthorInput> | QueryCreateWithoutAuthorInput[] | QueryUncheckedCreateWithoutAuthorInput[]
    connectOrCreate?: QueryCreateOrConnectWithoutAuthorInput | QueryCreateOrConnectWithoutAuthorInput[]
    upsert?: QueryUpsertWithWhereUniqueWithoutAuthorInput | QueryUpsertWithWhereUniqueWithoutAuthorInput[]
    createMany?: QueryCreateManyAuthorInputEnvelope
    set?: QueryWhereUniqueInput | QueryWhereUniqueInput[]
    disconnect?: QueryWhereUniqueInput | QueryWhereUniqueInput[]
    delete?: QueryWhereUniqueInput | QueryWhereUniqueInput[]
    connect?: QueryWhereUniqueInput | QueryWhereUniqueInput[]
    update?: QueryUpdateWithWhereUniqueWithoutAuthorInput | QueryUpdateWithWhereUniqueWithoutAuthorInput[]
    updateMany?: QueryUpdateManyWithWhereWithoutAuthorInput | QueryUpdateManyWithWhereWithoutAuthorInput[]
    deleteMany?: QueryScalarWhereInput | QueryScalarWhereInput[]
  }

  export type QueryResponseUpdateManyWithoutAuthorNestedInput = {
    create?: XOR<QueryResponseCreateWithoutAuthorInput, QueryResponseUncheckedCreateWithoutAuthorInput> | QueryResponseCreateWithoutAuthorInput[] | QueryResponseUncheckedCreateWithoutAuthorInput[]
    connectOrCreate?: QueryResponseCreateOrConnectWithoutAuthorInput | QueryResponseCreateOrConnectWithoutAuthorInput[]
    upsert?: QueryResponseUpsertWithWhereUniqueWithoutAuthorInput | QueryResponseUpsertWithWhereUniqueWithoutAuthorInput[]
    createMany?: QueryResponseCreateManyAuthorInputEnvelope
    set?: QueryResponseWhereUniqueInput | QueryResponseWhereUniqueInput[]
    disconnect?: QueryResponseWhereUniqueInput | QueryResponseWhereUniqueInput[]
    delete?: QueryResponseWhereUniqueInput | QueryResponseWhereUniqueInput[]
    connect?: QueryResponseWhereUniqueInput | QueryResponseWhereUniqueInput[]
    update?: QueryResponseUpdateWithWhereUniqueWithoutAuthorInput | QueryResponseUpdateWithWhereUniqueWithoutAuthorInput[]
    updateMany?: QueryResponseUpdateManyWithWhereWithoutAuthorInput | QueryResponseUpdateManyWithWhereWithoutAuthorInput[]
    deleteMany?: QueryResponseScalarWhereInput | QueryResponseScalarWhereInput[]
  }

  export type AuditLogUpdateManyWithoutUserNestedInput = {
    create?: XOR<AuditLogCreateWithoutUserInput, AuditLogUncheckedCreateWithoutUserInput> | AuditLogCreateWithoutUserInput[] | AuditLogUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AuditLogCreateOrConnectWithoutUserInput | AuditLogCreateOrConnectWithoutUserInput[]
    upsert?: AuditLogUpsertWithWhereUniqueWithoutUserInput | AuditLogUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: AuditLogCreateManyUserInputEnvelope
    set?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    disconnect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    delete?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    connect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    update?: AuditLogUpdateWithWhereUniqueWithoutUserInput | AuditLogUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: AuditLogUpdateManyWithWhereWithoutUserInput | AuditLogUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: AuditLogScalarWhereInput | AuditLogScalarWhereInput[]
  }

  export type NotificationPreferenceUpdateOneWithoutUserNestedInput = {
    create?: XOR<NotificationPreferenceCreateWithoutUserInput, NotificationPreferenceUncheckedCreateWithoutUserInput>
    connectOrCreate?: NotificationPreferenceCreateOrConnectWithoutUserInput
    upsert?: NotificationPreferenceUpsertWithoutUserInput
    disconnect?: NotificationPreferenceWhereInput | boolean
    delete?: NotificationPreferenceWhereInput | boolean
    connect?: NotificationPreferenceWhereUniqueInput
    update?: XOR<XOR<NotificationPreferenceUpdateToOneWithWhereWithoutUserInput, NotificationPreferenceUpdateWithoutUserInput>, NotificationPreferenceUncheckedUpdateWithoutUserInput>
  }

  export type MaterialUpdateManyWithoutCreatedByNestedInput = {
    create?: XOR<MaterialCreateWithoutCreatedByInput, MaterialUncheckedCreateWithoutCreatedByInput> | MaterialCreateWithoutCreatedByInput[] | MaterialUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: MaterialCreateOrConnectWithoutCreatedByInput | MaterialCreateOrConnectWithoutCreatedByInput[]
    upsert?: MaterialUpsertWithWhereUniqueWithoutCreatedByInput | MaterialUpsertWithWhereUniqueWithoutCreatedByInput[]
    createMany?: MaterialCreateManyCreatedByInputEnvelope
    set?: MaterialWhereUniqueInput | MaterialWhereUniqueInput[]
    disconnect?: MaterialWhereUniqueInput | MaterialWhereUniqueInput[]
    delete?: MaterialWhereUniqueInput | MaterialWhereUniqueInput[]
    connect?: MaterialWhereUniqueInput | MaterialWhereUniqueInput[]
    update?: MaterialUpdateWithWhereUniqueWithoutCreatedByInput | MaterialUpdateWithWhereUniqueWithoutCreatedByInput[]
    updateMany?: MaterialUpdateManyWithWhereWithoutCreatedByInput | MaterialUpdateManyWithWhereWithoutCreatedByInput[]
    deleteMany?: MaterialScalarWhereInput | MaterialScalarWhereInput[]
  }

  export type UserUncheckedUpdateManyWithoutCreatedByNestedInput = {
    create?: XOR<UserCreateWithoutCreatedByInput, UserUncheckedCreateWithoutCreatedByInput> | UserCreateWithoutCreatedByInput[] | UserUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: UserCreateOrConnectWithoutCreatedByInput | UserCreateOrConnectWithoutCreatedByInput[]
    upsert?: UserUpsertWithWhereUniqueWithoutCreatedByInput | UserUpsertWithWhereUniqueWithoutCreatedByInput[]
    createMany?: UserCreateManyCreatedByInputEnvelope
    set?: UserWhereUniqueInput | UserWhereUniqueInput[]
    disconnect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    delete?: UserWhereUniqueInput | UserWhereUniqueInput[]
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    update?: UserUpdateWithWhereUniqueWithoutCreatedByInput | UserUpdateWithWhereUniqueWithoutCreatedByInput[]
    updateMany?: UserUpdateManyWithWhereWithoutCreatedByInput | UserUpdateManyWithWhereWithoutCreatedByInput[]
    deleteMany?: UserScalarWhereInput | UserScalarWhereInput[]
  }

  export type ProjectUncheckedUpdateManyWithoutManagerNestedInput = {
    create?: XOR<ProjectCreateWithoutManagerInput, ProjectUncheckedCreateWithoutManagerInput> | ProjectCreateWithoutManagerInput[] | ProjectUncheckedCreateWithoutManagerInput[]
    connectOrCreate?: ProjectCreateOrConnectWithoutManagerInput | ProjectCreateOrConnectWithoutManagerInput[]
    upsert?: ProjectUpsertWithWhereUniqueWithoutManagerInput | ProjectUpsertWithWhereUniqueWithoutManagerInput[]
    createMany?: ProjectCreateManyManagerInputEnvelope
    set?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
    disconnect?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
    delete?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
    connect?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
    update?: ProjectUpdateWithWhereUniqueWithoutManagerInput | ProjectUpdateWithWhereUniqueWithoutManagerInput[]
    updateMany?: ProjectUpdateManyWithWhereWithoutManagerInput | ProjectUpdateManyWithWhereWithoutManagerInput[]
    deleteMany?: ProjectScalarWhereInput | ProjectScalarWhereInput[]
  }

  export type ProjectUncheckedUpdateManyWithoutClientNestedInput = {
    create?: XOR<ProjectCreateWithoutClientInput, ProjectUncheckedCreateWithoutClientInput> | ProjectCreateWithoutClientInput[] | ProjectUncheckedCreateWithoutClientInput[]
    connectOrCreate?: ProjectCreateOrConnectWithoutClientInput | ProjectCreateOrConnectWithoutClientInput[]
    upsert?: ProjectUpsertWithWhereUniqueWithoutClientInput | ProjectUpsertWithWhereUniqueWithoutClientInput[]
    createMany?: ProjectCreateManyClientInputEnvelope
    set?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
    disconnect?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
    delete?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
    connect?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
    update?: ProjectUpdateWithWhereUniqueWithoutClientInput | ProjectUpdateWithWhereUniqueWithoutClientInput[]
    updateMany?: ProjectUpdateManyWithWhereWithoutClientInput | ProjectUpdateManyWithWhereWithoutClientInput[]
    deleteMany?: ProjectScalarWhereInput | ProjectScalarWhereInput[]
  }

  export type ProjectMemberUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<ProjectMemberCreateWithoutUserInput, ProjectMemberUncheckedCreateWithoutUserInput> | ProjectMemberCreateWithoutUserInput[] | ProjectMemberUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ProjectMemberCreateOrConnectWithoutUserInput | ProjectMemberCreateOrConnectWithoutUserInput[]
    upsert?: ProjectMemberUpsertWithWhereUniqueWithoutUserInput | ProjectMemberUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ProjectMemberCreateManyUserInputEnvelope
    set?: ProjectMemberWhereUniqueInput | ProjectMemberWhereUniqueInput[]
    disconnect?: ProjectMemberWhereUniqueInput | ProjectMemberWhereUniqueInput[]
    delete?: ProjectMemberWhereUniqueInput | ProjectMemberWhereUniqueInput[]
    connect?: ProjectMemberWhereUniqueInput | ProjectMemberWhereUniqueInput[]
    update?: ProjectMemberUpdateWithWhereUniqueWithoutUserInput | ProjectMemberUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ProjectMemberUpdateManyWithWhereWithoutUserInput | ProjectMemberUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ProjectMemberScalarWhereInput | ProjectMemberScalarWhereInput[]
  }

  export type ProjectUpdateUncheckedUpdateManyWithoutAuthorNestedInput = {
    create?: XOR<ProjectUpdateCreateWithoutAuthorInput, ProjectUpdateUncheckedCreateWithoutAuthorInput> | ProjectUpdateCreateWithoutAuthorInput[] | ProjectUpdateUncheckedCreateWithoutAuthorInput[]
    connectOrCreate?: ProjectUpdateCreateOrConnectWithoutAuthorInput | ProjectUpdateCreateOrConnectWithoutAuthorInput[]
    upsert?: ProjectUpdateUpsertWithWhereUniqueWithoutAuthorInput | ProjectUpdateUpsertWithWhereUniqueWithoutAuthorInput[]
    createMany?: ProjectUpdateCreateManyAuthorInputEnvelope
    set?: ProjectUpdateWhereUniqueInput | ProjectUpdateWhereUniqueInput[]
    disconnect?: ProjectUpdateWhereUniqueInput | ProjectUpdateWhereUniqueInput[]
    delete?: ProjectUpdateWhereUniqueInput | ProjectUpdateWhereUniqueInput[]
    connect?: ProjectUpdateWhereUniqueInput | ProjectUpdateWhereUniqueInput[]
    update?: ProjectUpdateUpdateWithWhereUniqueWithoutAuthorInput | ProjectUpdateUpdateWithWhereUniqueWithoutAuthorInput[]
    updateMany?: ProjectUpdateUpdateManyWithWhereWithoutAuthorInput | ProjectUpdateUpdateManyWithWhereWithoutAuthorInput[]
    deleteMany?: ProjectUpdateScalarWhereInput | ProjectUpdateScalarWhereInput[]
  }

  export type MediaUncheckedUpdateManyWithoutCreatedByNestedInput = {
    create?: XOR<MediaCreateWithoutCreatedByInput, MediaUncheckedCreateWithoutCreatedByInput> | MediaCreateWithoutCreatedByInput[] | MediaUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: MediaCreateOrConnectWithoutCreatedByInput | MediaCreateOrConnectWithoutCreatedByInput[]
    upsert?: MediaUpsertWithWhereUniqueWithoutCreatedByInput | MediaUpsertWithWhereUniqueWithoutCreatedByInput[]
    createMany?: MediaCreateManyCreatedByInputEnvelope
    set?: MediaWhereUniqueInput | MediaWhereUniqueInput[]
    disconnect?: MediaWhereUniqueInput | MediaWhereUniqueInput[]
    delete?: MediaWhereUniqueInput | MediaWhereUniqueInput[]
    connect?: MediaWhereUniqueInput | MediaWhereUniqueInput[]
    update?: MediaUpdateWithWhereUniqueWithoutCreatedByInput | MediaUpdateWithWhereUniqueWithoutCreatedByInput[]
    updateMany?: MediaUpdateManyWithWhereWithoutCreatedByInput | MediaUpdateManyWithWhereWithoutCreatedByInput[]
    deleteMany?: MediaScalarWhereInput | MediaScalarWhereInput[]
  }

  export type PaymentUncheckedUpdateManyWithoutCreatedByNestedInput = {
    create?: XOR<PaymentCreateWithoutCreatedByInput, PaymentUncheckedCreateWithoutCreatedByInput> | PaymentCreateWithoutCreatedByInput[] | PaymentUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: PaymentCreateOrConnectWithoutCreatedByInput | PaymentCreateOrConnectWithoutCreatedByInput[]
    upsert?: PaymentUpsertWithWhereUniqueWithoutCreatedByInput | PaymentUpsertWithWhereUniqueWithoutCreatedByInput[]
    createMany?: PaymentCreateManyCreatedByInputEnvelope
    set?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    disconnect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    delete?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    connect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    update?: PaymentUpdateWithWhereUniqueWithoutCreatedByInput | PaymentUpdateWithWhereUniqueWithoutCreatedByInput[]
    updateMany?: PaymentUpdateManyWithWhereWithoutCreatedByInput | PaymentUpdateManyWithWhereWithoutCreatedByInput[]
    deleteMany?: PaymentScalarWhereInput | PaymentScalarWhereInput[]
  }

  export type NotificationUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput> | NotificationCreateWithoutUserInput[] | NotificationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutUserInput | NotificationCreateOrConnectWithoutUserInput[]
    upsert?: NotificationUpsertWithWhereUniqueWithoutUserInput | NotificationUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: NotificationCreateManyUserInputEnvelope
    set?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    disconnect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    delete?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    update?: NotificationUpdateWithWhereUniqueWithoutUserInput | NotificationUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: NotificationUpdateManyWithWhereWithoutUserInput | NotificationUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
  }

  export type ProjectUncheckedUpdateManyWithoutCreatedByNestedInput = {
    create?: XOR<ProjectCreateWithoutCreatedByInput, ProjectUncheckedCreateWithoutCreatedByInput> | ProjectCreateWithoutCreatedByInput[] | ProjectUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: ProjectCreateOrConnectWithoutCreatedByInput | ProjectCreateOrConnectWithoutCreatedByInput[]
    upsert?: ProjectUpsertWithWhereUniqueWithoutCreatedByInput | ProjectUpsertWithWhereUniqueWithoutCreatedByInput[]
    createMany?: ProjectCreateManyCreatedByInputEnvelope
    set?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
    disconnect?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
    delete?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
    connect?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
    update?: ProjectUpdateWithWhereUniqueWithoutCreatedByInput | ProjectUpdateWithWhereUniqueWithoutCreatedByInput[]
    updateMany?: ProjectUpdateManyWithWhereWithoutCreatedByInput | ProjectUpdateManyWithWhereWithoutCreatedByInput[]
    deleteMany?: ProjectScalarWhereInput | ProjectScalarWhereInput[]
  }

  export type InspectionUncheckedUpdateManyWithoutEngineerNestedInput = {
    create?: XOR<InspectionCreateWithoutEngineerInput, InspectionUncheckedCreateWithoutEngineerInput> | InspectionCreateWithoutEngineerInput[] | InspectionUncheckedCreateWithoutEngineerInput[]
    connectOrCreate?: InspectionCreateOrConnectWithoutEngineerInput | InspectionCreateOrConnectWithoutEngineerInput[]
    upsert?: InspectionUpsertWithWhereUniqueWithoutEngineerInput | InspectionUpsertWithWhereUniqueWithoutEngineerInput[]
    createMany?: InspectionCreateManyEngineerInputEnvelope
    set?: InspectionWhereUniqueInput | InspectionWhereUniqueInput[]
    disconnect?: InspectionWhereUniqueInput | InspectionWhereUniqueInput[]
    delete?: InspectionWhereUniqueInput | InspectionWhereUniqueInput[]
    connect?: InspectionWhereUniqueInput | InspectionWhereUniqueInput[]
    update?: InspectionUpdateWithWhereUniqueWithoutEngineerInput | InspectionUpdateWithWhereUniqueWithoutEngineerInput[]
    updateMany?: InspectionUpdateManyWithWhereWithoutEngineerInput | InspectionUpdateManyWithWhereWithoutEngineerInput[]
    deleteMany?: InspectionScalarWhereInput | InspectionScalarWhereInput[]
  }

  export type InspectionUncheckedUpdateManyWithoutReviewedByNestedInput = {
    create?: XOR<InspectionCreateWithoutReviewedByInput, InspectionUncheckedCreateWithoutReviewedByInput> | InspectionCreateWithoutReviewedByInput[] | InspectionUncheckedCreateWithoutReviewedByInput[]
    connectOrCreate?: InspectionCreateOrConnectWithoutReviewedByInput | InspectionCreateOrConnectWithoutReviewedByInput[]
    upsert?: InspectionUpsertWithWhereUniqueWithoutReviewedByInput | InspectionUpsertWithWhereUniqueWithoutReviewedByInput[]
    createMany?: InspectionCreateManyReviewedByInputEnvelope
    set?: InspectionWhereUniqueInput | InspectionWhereUniqueInput[]
    disconnect?: InspectionWhereUniqueInput | InspectionWhereUniqueInput[]
    delete?: InspectionWhereUniqueInput | InspectionWhereUniqueInput[]
    connect?: InspectionWhereUniqueInput | InspectionWhereUniqueInput[]
    update?: InspectionUpdateWithWhereUniqueWithoutReviewedByInput | InspectionUpdateWithWhereUniqueWithoutReviewedByInput[]
    updateMany?: InspectionUpdateManyWithWhereWithoutReviewedByInput | InspectionUpdateManyWithWhereWithoutReviewedByInput[]
    deleteMany?: InspectionScalarWhereInput | InspectionScalarWhereInput[]
  }

  export type QueryUncheckedUpdateManyWithoutAuthorNestedInput = {
    create?: XOR<QueryCreateWithoutAuthorInput, QueryUncheckedCreateWithoutAuthorInput> | QueryCreateWithoutAuthorInput[] | QueryUncheckedCreateWithoutAuthorInput[]
    connectOrCreate?: QueryCreateOrConnectWithoutAuthorInput | QueryCreateOrConnectWithoutAuthorInput[]
    upsert?: QueryUpsertWithWhereUniqueWithoutAuthorInput | QueryUpsertWithWhereUniqueWithoutAuthorInput[]
    createMany?: QueryCreateManyAuthorInputEnvelope
    set?: QueryWhereUniqueInput | QueryWhereUniqueInput[]
    disconnect?: QueryWhereUniqueInput | QueryWhereUniqueInput[]
    delete?: QueryWhereUniqueInput | QueryWhereUniqueInput[]
    connect?: QueryWhereUniqueInput | QueryWhereUniqueInput[]
    update?: QueryUpdateWithWhereUniqueWithoutAuthorInput | QueryUpdateWithWhereUniqueWithoutAuthorInput[]
    updateMany?: QueryUpdateManyWithWhereWithoutAuthorInput | QueryUpdateManyWithWhereWithoutAuthorInput[]
    deleteMany?: QueryScalarWhereInput | QueryScalarWhereInput[]
  }

  export type QueryResponseUncheckedUpdateManyWithoutAuthorNestedInput = {
    create?: XOR<QueryResponseCreateWithoutAuthorInput, QueryResponseUncheckedCreateWithoutAuthorInput> | QueryResponseCreateWithoutAuthorInput[] | QueryResponseUncheckedCreateWithoutAuthorInput[]
    connectOrCreate?: QueryResponseCreateOrConnectWithoutAuthorInput | QueryResponseCreateOrConnectWithoutAuthorInput[]
    upsert?: QueryResponseUpsertWithWhereUniqueWithoutAuthorInput | QueryResponseUpsertWithWhereUniqueWithoutAuthorInput[]
    createMany?: QueryResponseCreateManyAuthorInputEnvelope
    set?: QueryResponseWhereUniqueInput | QueryResponseWhereUniqueInput[]
    disconnect?: QueryResponseWhereUniqueInput | QueryResponseWhereUniqueInput[]
    delete?: QueryResponseWhereUniqueInput | QueryResponseWhereUniqueInput[]
    connect?: QueryResponseWhereUniqueInput | QueryResponseWhereUniqueInput[]
    update?: QueryResponseUpdateWithWhereUniqueWithoutAuthorInput | QueryResponseUpdateWithWhereUniqueWithoutAuthorInput[]
    updateMany?: QueryResponseUpdateManyWithWhereWithoutAuthorInput | QueryResponseUpdateManyWithWhereWithoutAuthorInput[]
    deleteMany?: QueryResponseScalarWhereInput | QueryResponseScalarWhereInput[]
  }

  export type AuditLogUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<AuditLogCreateWithoutUserInput, AuditLogUncheckedCreateWithoutUserInput> | AuditLogCreateWithoutUserInput[] | AuditLogUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AuditLogCreateOrConnectWithoutUserInput | AuditLogCreateOrConnectWithoutUserInput[]
    upsert?: AuditLogUpsertWithWhereUniqueWithoutUserInput | AuditLogUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: AuditLogCreateManyUserInputEnvelope
    set?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    disconnect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    delete?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    connect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    update?: AuditLogUpdateWithWhereUniqueWithoutUserInput | AuditLogUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: AuditLogUpdateManyWithWhereWithoutUserInput | AuditLogUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: AuditLogScalarWhereInput | AuditLogScalarWhereInput[]
  }

  export type NotificationPreferenceUncheckedUpdateOneWithoutUserNestedInput = {
    create?: XOR<NotificationPreferenceCreateWithoutUserInput, NotificationPreferenceUncheckedCreateWithoutUserInput>
    connectOrCreate?: NotificationPreferenceCreateOrConnectWithoutUserInput
    upsert?: NotificationPreferenceUpsertWithoutUserInput
    disconnect?: NotificationPreferenceWhereInput | boolean
    delete?: NotificationPreferenceWhereInput | boolean
    connect?: NotificationPreferenceWhereUniqueInput
    update?: XOR<XOR<NotificationPreferenceUpdateToOneWithWhereWithoutUserInput, NotificationPreferenceUpdateWithoutUserInput>, NotificationPreferenceUncheckedUpdateWithoutUserInput>
  }

  export type MaterialUncheckedUpdateManyWithoutCreatedByNestedInput = {
    create?: XOR<MaterialCreateWithoutCreatedByInput, MaterialUncheckedCreateWithoutCreatedByInput> | MaterialCreateWithoutCreatedByInput[] | MaterialUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: MaterialCreateOrConnectWithoutCreatedByInput | MaterialCreateOrConnectWithoutCreatedByInput[]
    upsert?: MaterialUpsertWithWhereUniqueWithoutCreatedByInput | MaterialUpsertWithWhereUniqueWithoutCreatedByInput[]
    createMany?: MaterialCreateManyCreatedByInputEnvelope
    set?: MaterialWhereUniqueInput | MaterialWhereUniqueInput[]
    disconnect?: MaterialWhereUniqueInput | MaterialWhereUniqueInput[]
    delete?: MaterialWhereUniqueInput | MaterialWhereUniqueInput[]
    connect?: MaterialWhereUniqueInput | MaterialWhereUniqueInput[]
    update?: MaterialUpdateWithWhereUniqueWithoutCreatedByInput | MaterialUpdateWithWhereUniqueWithoutCreatedByInput[]
    updateMany?: MaterialUpdateManyWithWhereWithoutCreatedByInput | MaterialUpdateManyWithWhereWithoutCreatedByInput[]
    deleteMany?: MaterialScalarWhereInput | MaterialScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutProjectsCreatedInput = {
    create?: XOR<UserCreateWithoutProjectsCreatedInput, UserUncheckedCreateWithoutProjectsCreatedInput>
    connectOrCreate?: UserCreateOrConnectWithoutProjectsCreatedInput
    connect?: UserWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutManagedProjectsInput = {
    create?: XOR<UserCreateWithoutManagedProjectsInput, UserUncheckedCreateWithoutManagedProjectsInput>
    connectOrCreate?: UserCreateOrConnectWithoutManagedProjectsInput
    connect?: UserWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutClientProjectsInput = {
    create?: XOR<UserCreateWithoutClientProjectsInput, UserUncheckedCreateWithoutClientProjectsInput>
    connectOrCreate?: UserCreateOrConnectWithoutClientProjectsInput
    connect?: UserWhereUniqueInput
  }

  export type ProjectMemberCreateNestedManyWithoutProjectInput = {
    create?: XOR<ProjectMemberCreateWithoutProjectInput, ProjectMemberUncheckedCreateWithoutProjectInput> | ProjectMemberCreateWithoutProjectInput[] | ProjectMemberUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: ProjectMemberCreateOrConnectWithoutProjectInput | ProjectMemberCreateOrConnectWithoutProjectInput[]
    createMany?: ProjectMemberCreateManyProjectInputEnvelope
    connect?: ProjectMemberWhereUniqueInput | ProjectMemberWhereUniqueInput[]
  }

  export type ProjectUpdateCreateNestedManyWithoutProjectInput = {
    create?: XOR<ProjectUpdateCreateWithoutProjectInput, ProjectUpdateUncheckedCreateWithoutProjectInput> | ProjectUpdateCreateWithoutProjectInput[] | ProjectUpdateUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: ProjectUpdateCreateOrConnectWithoutProjectInput | ProjectUpdateCreateOrConnectWithoutProjectInput[]
    createMany?: ProjectUpdateCreateManyProjectInputEnvelope
    connect?: ProjectUpdateWhereUniqueInput | ProjectUpdateWhereUniqueInput[]
  }

  export type MediaCreateNestedManyWithoutProjectInput = {
    create?: XOR<MediaCreateWithoutProjectInput, MediaUncheckedCreateWithoutProjectInput> | MediaCreateWithoutProjectInput[] | MediaUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: MediaCreateOrConnectWithoutProjectInput | MediaCreateOrConnectWithoutProjectInput[]
    createMany?: MediaCreateManyProjectInputEnvelope
    connect?: MediaWhereUniqueInput | MediaWhereUniqueInput[]
  }

  export type PaymentCreateNestedManyWithoutProjectInput = {
    create?: XOR<PaymentCreateWithoutProjectInput, PaymentUncheckedCreateWithoutProjectInput> | PaymentCreateWithoutProjectInput[] | PaymentUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: PaymentCreateOrConnectWithoutProjectInput | PaymentCreateOrConnectWithoutProjectInput[]
    createMany?: PaymentCreateManyProjectInputEnvelope
    connect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
  }

  export type MilestoneCreateNestedManyWithoutProjectInput = {
    create?: XOR<MilestoneCreateWithoutProjectInput, MilestoneUncheckedCreateWithoutProjectInput> | MilestoneCreateWithoutProjectInput[] | MilestoneUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: MilestoneCreateOrConnectWithoutProjectInput | MilestoneCreateOrConnectWithoutProjectInput[]
    createMany?: MilestoneCreateManyProjectInputEnvelope
    connect?: MilestoneWhereUniqueInput | MilestoneWhereUniqueInput[]
  }

  export type InspectionCreateNestedManyWithoutProjectInput = {
    create?: XOR<InspectionCreateWithoutProjectInput, InspectionUncheckedCreateWithoutProjectInput> | InspectionCreateWithoutProjectInput[] | InspectionUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: InspectionCreateOrConnectWithoutProjectInput | InspectionCreateOrConnectWithoutProjectInput[]
    createMany?: InspectionCreateManyProjectInputEnvelope
    connect?: InspectionWhereUniqueInput | InspectionWhereUniqueInput[]
  }

  export type QueryCreateNestedManyWithoutProjectInput = {
    create?: XOR<QueryCreateWithoutProjectInput, QueryUncheckedCreateWithoutProjectInput> | QueryCreateWithoutProjectInput[] | QueryUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: QueryCreateOrConnectWithoutProjectInput | QueryCreateOrConnectWithoutProjectInput[]
    createMany?: QueryCreateManyProjectInputEnvelope
    connect?: QueryWhereUniqueInput | QueryWhereUniqueInput[]
  }

  export type MaterialCreateNestedManyWithoutProjectInput = {
    create?: XOR<MaterialCreateWithoutProjectInput, MaterialUncheckedCreateWithoutProjectInput> | MaterialCreateWithoutProjectInput[] | MaterialUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: MaterialCreateOrConnectWithoutProjectInput | MaterialCreateOrConnectWithoutProjectInput[]
    createMany?: MaterialCreateManyProjectInputEnvelope
    connect?: MaterialWhereUniqueInput | MaterialWhereUniqueInput[]
  }

  export type AuditLogCreateNestedManyWithoutProjectInput = {
    create?: XOR<AuditLogCreateWithoutProjectInput, AuditLogUncheckedCreateWithoutProjectInput> | AuditLogCreateWithoutProjectInput[] | AuditLogUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: AuditLogCreateOrConnectWithoutProjectInput | AuditLogCreateOrConnectWithoutProjectInput[]
    createMany?: AuditLogCreateManyProjectInputEnvelope
    connect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
  }

  export type ProjectMemberUncheckedCreateNestedManyWithoutProjectInput = {
    create?: XOR<ProjectMemberCreateWithoutProjectInput, ProjectMemberUncheckedCreateWithoutProjectInput> | ProjectMemberCreateWithoutProjectInput[] | ProjectMemberUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: ProjectMemberCreateOrConnectWithoutProjectInput | ProjectMemberCreateOrConnectWithoutProjectInput[]
    createMany?: ProjectMemberCreateManyProjectInputEnvelope
    connect?: ProjectMemberWhereUniqueInput | ProjectMemberWhereUniqueInput[]
  }

  export type ProjectUpdateUncheckedCreateNestedManyWithoutProjectInput = {
    create?: XOR<ProjectUpdateCreateWithoutProjectInput, ProjectUpdateUncheckedCreateWithoutProjectInput> | ProjectUpdateCreateWithoutProjectInput[] | ProjectUpdateUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: ProjectUpdateCreateOrConnectWithoutProjectInput | ProjectUpdateCreateOrConnectWithoutProjectInput[]
    createMany?: ProjectUpdateCreateManyProjectInputEnvelope
    connect?: ProjectUpdateWhereUniqueInput | ProjectUpdateWhereUniqueInput[]
  }

  export type MediaUncheckedCreateNestedManyWithoutProjectInput = {
    create?: XOR<MediaCreateWithoutProjectInput, MediaUncheckedCreateWithoutProjectInput> | MediaCreateWithoutProjectInput[] | MediaUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: MediaCreateOrConnectWithoutProjectInput | MediaCreateOrConnectWithoutProjectInput[]
    createMany?: MediaCreateManyProjectInputEnvelope
    connect?: MediaWhereUniqueInput | MediaWhereUniqueInput[]
  }

  export type PaymentUncheckedCreateNestedManyWithoutProjectInput = {
    create?: XOR<PaymentCreateWithoutProjectInput, PaymentUncheckedCreateWithoutProjectInput> | PaymentCreateWithoutProjectInput[] | PaymentUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: PaymentCreateOrConnectWithoutProjectInput | PaymentCreateOrConnectWithoutProjectInput[]
    createMany?: PaymentCreateManyProjectInputEnvelope
    connect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
  }

  export type MilestoneUncheckedCreateNestedManyWithoutProjectInput = {
    create?: XOR<MilestoneCreateWithoutProjectInput, MilestoneUncheckedCreateWithoutProjectInput> | MilestoneCreateWithoutProjectInput[] | MilestoneUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: MilestoneCreateOrConnectWithoutProjectInput | MilestoneCreateOrConnectWithoutProjectInput[]
    createMany?: MilestoneCreateManyProjectInputEnvelope
    connect?: MilestoneWhereUniqueInput | MilestoneWhereUniqueInput[]
  }

  export type InspectionUncheckedCreateNestedManyWithoutProjectInput = {
    create?: XOR<InspectionCreateWithoutProjectInput, InspectionUncheckedCreateWithoutProjectInput> | InspectionCreateWithoutProjectInput[] | InspectionUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: InspectionCreateOrConnectWithoutProjectInput | InspectionCreateOrConnectWithoutProjectInput[]
    createMany?: InspectionCreateManyProjectInputEnvelope
    connect?: InspectionWhereUniqueInput | InspectionWhereUniqueInput[]
  }

  export type QueryUncheckedCreateNestedManyWithoutProjectInput = {
    create?: XOR<QueryCreateWithoutProjectInput, QueryUncheckedCreateWithoutProjectInput> | QueryCreateWithoutProjectInput[] | QueryUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: QueryCreateOrConnectWithoutProjectInput | QueryCreateOrConnectWithoutProjectInput[]
    createMany?: QueryCreateManyProjectInputEnvelope
    connect?: QueryWhereUniqueInput | QueryWhereUniqueInput[]
  }

  export type MaterialUncheckedCreateNestedManyWithoutProjectInput = {
    create?: XOR<MaterialCreateWithoutProjectInput, MaterialUncheckedCreateWithoutProjectInput> | MaterialCreateWithoutProjectInput[] | MaterialUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: MaterialCreateOrConnectWithoutProjectInput | MaterialCreateOrConnectWithoutProjectInput[]
    createMany?: MaterialCreateManyProjectInputEnvelope
    connect?: MaterialWhereUniqueInput | MaterialWhereUniqueInput[]
  }

  export type AuditLogUncheckedCreateNestedManyWithoutProjectInput = {
    create?: XOR<AuditLogCreateWithoutProjectInput, AuditLogUncheckedCreateWithoutProjectInput> | AuditLogCreateWithoutProjectInput[] | AuditLogUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: AuditLogCreateOrConnectWithoutProjectInput | AuditLogCreateOrConnectWithoutProjectInput[]
    createMany?: AuditLogCreateManyProjectInputEnvelope
    connect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
  }

  export type EnumProjectStatusFieldUpdateOperationsInput = {
    set?: $Enums.ProjectStatus
  }

  export type UserUpdateOneRequiredWithoutProjectsCreatedNestedInput = {
    create?: XOR<UserCreateWithoutProjectsCreatedInput, UserUncheckedCreateWithoutProjectsCreatedInput>
    connectOrCreate?: UserCreateOrConnectWithoutProjectsCreatedInput
    upsert?: UserUpsertWithoutProjectsCreatedInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutProjectsCreatedInput, UserUpdateWithoutProjectsCreatedInput>, UserUncheckedUpdateWithoutProjectsCreatedInput>
  }

  export type UserUpdateOneRequiredWithoutManagedProjectsNestedInput = {
    create?: XOR<UserCreateWithoutManagedProjectsInput, UserUncheckedCreateWithoutManagedProjectsInput>
    connectOrCreate?: UserCreateOrConnectWithoutManagedProjectsInput
    upsert?: UserUpsertWithoutManagedProjectsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutManagedProjectsInput, UserUpdateWithoutManagedProjectsInput>, UserUncheckedUpdateWithoutManagedProjectsInput>
  }

  export type UserUpdateOneRequiredWithoutClientProjectsNestedInput = {
    create?: XOR<UserCreateWithoutClientProjectsInput, UserUncheckedCreateWithoutClientProjectsInput>
    connectOrCreate?: UserCreateOrConnectWithoutClientProjectsInput
    upsert?: UserUpsertWithoutClientProjectsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutClientProjectsInput, UserUpdateWithoutClientProjectsInput>, UserUncheckedUpdateWithoutClientProjectsInput>
  }

  export type ProjectMemberUpdateManyWithoutProjectNestedInput = {
    create?: XOR<ProjectMemberCreateWithoutProjectInput, ProjectMemberUncheckedCreateWithoutProjectInput> | ProjectMemberCreateWithoutProjectInput[] | ProjectMemberUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: ProjectMemberCreateOrConnectWithoutProjectInput | ProjectMemberCreateOrConnectWithoutProjectInput[]
    upsert?: ProjectMemberUpsertWithWhereUniqueWithoutProjectInput | ProjectMemberUpsertWithWhereUniqueWithoutProjectInput[]
    createMany?: ProjectMemberCreateManyProjectInputEnvelope
    set?: ProjectMemberWhereUniqueInput | ProjectMemberWhereUniqueInput[]
    disconnect?: ProjectMemberWhereUniqueInput | ProjectMemberWhereUniqueInput[]
    delete?: ProjectMemberWhereUniqueInput | ProjectMemberWhereUniqueInput[]
    connect?: ProjectMemberWhereUniqueInput | ProjectMemberWhereUniqueInput[]
    update?: ProjectMemberUpdateWithWhereUniqueWithoutProjectInput | ProjectMemberUpdateWithWhereUniqueWithoutProjectInput[]
    updateMany?: ProjectMemberUpdateManyWithWhereWithoutProjectInput | ProjectMemberUpdateManyWithWhereWithoutProjectInput[]
    deleteMany?: ProjectMemberScalarWhereInput | ProjectMemberScalarWhereInput[]
  }

  export type ProjectUpdateUpdateManyWithoutProjectNestedInput = {
    create?: XOR<ProjectUpdateCreateWithoutProjectInput, ProjectUpdateUncheckedCreateWithoutProjectInput> | ProjectUpdateCreateWithoutProjectInput[] | ProjectUpdateUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: ProjectUpdateCreateOrConnectWithoutProjectInput | ProjectUpdateCreateOrConnectWithoutProjectInput[]
    upsert?: ProjectUpdateUpsertWithWhereUniqueWithoutProjectInput | ProjectUpdateUpsertWithWhereUniqueWithoutProjectInput[]
    createMany?: ProjectUpdateCreateManyProjectInputEnvelope
    set?: ProjectUpdateWhereUniqueInput | ProjectUpdateWhereUniqueInput[]
    disconnect?: ProjectUpdateWhereUniqueInput | ProjectUpdateWhereUniqueInput[]
    delete?: ProjectUpdateWhereUniqueInput | ProjectUpdateWhereUniqueInput[]
    connect?: ProjectUpdateWhereUniqueInput | ProjectUpdateWhereUniqueInput[]
    update?: ProjectUpdateUpdateWithWhereUniqueWithoutProjectInput | ProjectUpdateUpdateWithWhereUniqueWithoutProjectInput[]
    updateMany?: ProjectUpdateUpdateManyWithWhereWithoutProjectInput | ProjectUpdateUpdateManyWithWhereWithoutProjectInput[]
    deleteMany?: ProjectUpdateScalarWhereInput | ProjectUpdateScalarWhereInput[]
  }

  export type MediaUpdateManyWithoutProjectNestedInput = {
    create?: XOR<MediaCreateWithoutProjectInput, MediaUncheckedCreateWithoutProjectInput> | MediaCreateWithoutProjectInput[] | MediaUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: MediaCreateOrConnectWithoutProjectInput | MediaCreateOrConnectWithoutProjectInput[]
    upsert?: MediaUpsertWithWhereUniqueWithoutProjectInput | MediaUpsertWithWhereUniqueWithoutProjectInput[]
    createMany?: MediaCreateManyProjectInputEnvelope
    set?: MediaWhereUniqueInput | MediaWhereUniqueInput[]
    disconnect?: MediaWhereUniqueInput | MediaWhereUniqueInput[]
    delete?: MediaWhereUniqueInput | MediaWhereUniqueInput[]
    connect?: MediaWhereUniqueInput | MediaWhereUniqueInput[]
    update?: MediaUpdateWithWhereUniqueWithoutProjectInput | MediaUpdateWithWhereUniqueWithoutProjectInput[]
    updateMany?: MediaUpdateManyWithWhereWithoutProjectInput | MediaUpdateManyWithWhereWithoutProjectInput[]
    deleteMany?: MediaScalarWhereInput | MediaScalarWhereInput[]
  }

  export type PaymentUpdateManyWithoutProjectNestedInput = {
    create?: XOR<PaymentCreateWithoutProjectInput, PaymentUncheckedCreateWithoutProjectInput> | PaymentCreateWithoutProjectInput[] | PaymentUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: PaymentCreateOrConnectWithoutProjectInput | PaymentCreateOrConnectWithoutProjectInput[]
    upsert?: PaymentUpsertWithWhereUniqueWithoutProjectInput | PaymentUpsertWithWhereUniqueWithoutProjectInput[]
    createMany?: PaymentCreateManyProjectInputEnvelope
    set?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    disconnect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    delete?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    connect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    update?: PaymentUpdateWithWhereUniqueWithoutProjectInput | PaymentUpdateWithWhereUniqueWithoutProjectInput[]
    updateMany?: PaymentUpdateManyWithWhereWithoutProjectInput | PaymentUpdateManyWithWhereWithoutProjectInput[]
    deleteMany?: PaymentScalarWhereInput | PaymentScalarWhereInput[]
  }

  export type MilestoneUpdateManyWithoutProjectNestedInput = {
    create?: XOR<MilestoneCreateWithoutProjectInput, MilestoneUncheckedCreateWithoutProjectInput> | MilestoneCreateWithoutProjectInput[] | MilestoneUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: MilestoneCreateOrConnectWithoutProjectInput | MilestoneCreateOrConnectWithoutProjectInput[]
    upsert?: MilestoneUpsertWithWhereUniqueWithoutProjectInput | MilestoneUpsertWithWhereUniqueWithoutProjectInput[]
    createMany?: MilestoneCreateManyProjectInputEnvelope
    set?: MilestoneWhereUniqueInput | MilestoneWhereUniqueInput[]
    disconnect?: MilestoneWhereUniqueInput | MilestoneWhereUniqueInput[]
    delete?: MilestoneWhereUniqueInput | MilestoneWhereUniqueInput[]
    connect?: MilestoneWhereUniqueInput | MilestoneWhereUniqueInput[]
    update?: MilestoneUpdateWithWhereUniqueWithoutProjectInput | MilestoneUpdateWithWhereUniqueWithoutProjectInput[]
    updateMany?: MilestoneUpdateManyWithWhereWithoutProjectInput | MilestoneUpdateManyWithWhereWithoutProjectInput[]
    deleteMany?: MilestoneScalarWhereInput | MilestoneScalarWhereInput[]
  }

  export type InspectionUpdateManyWithoutProjectNestedInput = {
    create?: XOR<InspectionCreateWithoutProjectInput, InspectionUncheckedCreateWithoutProjectInput> | InspectionCreateWithoutProjectInput[] | InspectionUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: InspectionCreateOrConnectWithoutProjectInput | InspectionCreateOrConnectWithoutProjectInput[]
    upsert?: InspectionUpsertWithWhereUniqueWithoutProjectInput | InspectionUpsertWithWhereUniqueWithoutProjectInput[]
    createMany?: InspectionCreateManyProjectInputEnvelope
    set?: InspectionWhereUniqueInput | InspectionWhereUniqueInput[]
    disconnect?: InspectionWhereUniqueInput | InspectionWhereUniqueInput[]
    delete?: InspectionWhereUniqueInput | InspectionWhereUniqueInput[]
    connect?: InspectionWhereUniqueInput | InspectionWhereUniqueInput[]
    update?: InspectionUpdateWithWhereUniqueWithoutProjectInput | InspectionUpdateWithWhereUniqueWithoutProjectInput[]
    updateMany?: InspectionUpdateManyWithWhereWithoutProjectInput | InspectionUpdateManyWithWhereWithoutProjectInput[]
    deleteMany?: InspectionScalarWhereInput | InspectionScalarWhereInput[]
  }

  export type QueryUpdateManyWithoutProjectNestedInput = {
    create?: XOR<QueryCreateWithoutProjectInput, QueryUncheckedCreateWithoutProjectInput> | QueryCreateWithoutProjectInput[] | QueryUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: QueryCreateOrConnectWithoutProjectInput | QueryCreateOrConnectWithoutProjectInput[]
    upsert?: QueryUpsertWithWhereUniqueWithoutProjectInput | QueryUpsertWithWhereUniqueWithoutProjectInput[]
    createMany?: QueryCreateManyProjectInputEnvelope
    set?: QueryWhereUniqueInput | QueryWhereUniqueInput[]
    disconnect?: QueryWhereUniqueInput | QueryWhereUniqueInput[]
    delete?: QueryWhereUniqueInput | QueryWhereUniqueInput[]
    connect?: QueryWhereUniqueInput | QueryWhereUniqueInput[]
    update?: QueryUpdateWithWhereUniqueWithoutProjectInput | QueryUpdateWithWhereUniqueWithoutProjectInput[]
    updateMany?: QueryUpdateManyWithWhereWithoutProjectInput | QueryUpdateManyWithWhereWithoutProjectInput[]
    deleteMany?: QueryScalarWhereInput | QueryScalarWhereInput[]
  }

  export type MaterialUpdateManyWithoutProjectNestedInput = {
    create?: XOR<MaterialCreateWithoutProjectInput, MaterialUncheckedCreateWithoutProjectInput> | MaterialCreateWithoutProjectInput[] | MaterialUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: MaterialCreateOrConnectWithoutProjectInput | MaterialCreateOrConnectWithoutProjectInput[]
    upsert?: MaterialUpsertWithWhereUniqueWithoutProjectInput | MaterialUpsertWithWhereUniqueWithoutProjectInput[]
    createMany?: MaterialCreateManyProjectInputEnvelope
    set?: MaterialWhereUniqueInput | MaterialWhereUniqueInput[]
    disconnect?: MaterialWhereUniqueInput | MaterialWhereUniqueInput[]
    delete?: MaterialWhereUniqueInput | MaterialWhereUniqueInput[]
    connect?: MaterialWhereUniqueInput | MaterialWhereUniqueInput[]
    update?: MaterialUpdateWithWhereUniqueWithoutProjectInput | MaterialUpdateWithWhereUniqueWithoutProjectInput[]
    updateMany?: MaterialUpdateManyWithWhereWithoutProjectInput | MaterialUpdateManyWithWhereWithoutProjectInput[]
    deleteMany?: MaterialScalarWhereInput | MaterialScalarWhereInput[]
  }

  export type AuditLogUpdateManyWithoutProjectNestedInput = {
    create?: XOR<AuditLogCreateWithoutProjectInput, AuditLogUncheckedCreateWithoutProjectInput> | AuditLogCreateWithoutProjectInput[] | AuditLogUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: AuditLogCreateOrConnectWithoutProjectInput | AuditLogCreateOrConnectWithoutProjectInput[]
    upsert?: AuditLogUpsertWithWhereUniqueWithoutProjectInput | AuditLogUpsertWithWhereUniqueWithoutProjectInput[]
    createMany?: AuditLogCreateManyProjectInputEnvelope
    set?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    disconnect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    delete?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    connect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    update?: AuditLogUpdateWithWhereUniqueWithoutProjectInput | AuditLogUpdateWithWhereUniqueWithoutProjectInput[]
    updateMany?: AuditLogUpdateManyWithWhereWithoutProjectInput | AuditLogUpdateManyWithWhereWithoutProjectInput[]
    deleteMany?: AuditLogScalarWhereInput | AuditLogScalarWhereInput[]
  }

  export type ProjectMemberUncheckedUpdateManyWithoutProjectNestedInput = {
    create?: XOR<ProjectMemberCreateWithoutProjectInput, ProjectMemberUncheckedCreateWithoutProjectInput> | ProjectMemberCreateWithoutProjectInput[] | ProjectMemberUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: ProjectMemberCreateOrConnectWithoutProjectInput | ProjectMemberCreateOrConnectWithoutProjectInput[]
    upsert?: ProjectMemberUpsertWithWhereUniqueWithoutProjectInput | ProjectMemberUpsertWithWhereUniqueWithoutProjectInput[]
    createMany?: ProjectMemberCreateManyProjectInputEnvelope
    set?: ProjectMemberWhereUniqueInput | ProjectMemberWhereUniqueInput[]
    disconnect?: ProjectMemberWhereUniqueInput | ProjectMemberWhereUniqueInput[]
    delete?: ProjectMemberWhereUniqueInput | ProjectMemberWhereUniqueInput[]
    connect?: ProjectMemberWhereUniqueInput | ProjectMemberWhereUniqueInput[]
    update?: ProjectMemberUpdateWithWhereUniqueWithoutProjectInput | ProjectMemberUpdateWithWhereUniqueWithoutProjectInput[]
    updateMany?: ProjectMemberUpdateManyWithWhereWithoutProjectInput | ProjectMemberUpdateManyWithWhereWithoutProjectInput[]
    deleteMany?: ProjectMemberScalarWhereInput | ProjectMemberScalarWhereInput[]
  }

  export type ProjectUpdateUncheckedUpdateManyWithoutProjectNestedInput = {
    create?: XOR<ProjectUpdateCreateWithoutProjectInput, ProjectUpdateUncheckedCreateWithoutProjectInput> | ProjectUpdateCreateWithoutProjectInput[] | ProjectUpdateUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: ProjectUpdateCreateOrConnectWithoutProjectInput | ProjectUpdateCreateOrConnectWithoutProjectInput[]
    upsert?: ProjectUpdateUpsertWithWhereUniqueWithoutProjectInput | ProjectUpdateUpsertWithWhereUniqueWithoutProjectInput[]
    createMany?: ProjectUpdateCreateManyProjectInputEnvelope
    set?: ProjectUpdateWhereUniqueInput | ProjectUpdateWhereUniqueInput[]
    disconnect?: ProjectUpdateWhereUniqueInput | ProjectUpdateWhereUniqueInput[]
    delete?: ProjectUpdateWhereUniqueInput | ProjectUpdateWhereUniqueInput[]
    connect?: ProjectUpdateWhereUniqueInput | ProjectUpdateWhereUniqueInput[]
    update?: ProjectUpdateUpdateWithWhereUniqueWithoutProjectInput | ProjectUpdateUpdateWithWhereUniqueWithoutProjectInput[]
    updateMany?: ProjectUpdateUpdateManyWithWhereWithoutProjectInput | ProjectUpdateUpdateManyWithWhereWithoutProjectInput[]
    deleteMany?: ProjectUpdateScalarWhereInput | ProjectUpdateScalarWhereInput[]
  }

  export type MediaUncheckedUpdateManyWithoutProjectNestedInput = {
    create?: XOR<MediaCreateWithoutProjectInput, MediaUncheckedCreateWithoutProjectInput> | MediaCreateWithoutProjectInput[] | MediaUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: MediaCreateOrConnectWithoutProjectInput | MediaCreateOrConnectWithoutProjectInput[]
    upsert?: MediaUpsertWithWhereUniqueWithoutProjectInput | MediaUpsertWithWhereUniqueWithoutProjectInput[]
    createMany?: MediaCreateManyProjectInputEnvelope
    set?: MediaWhereUniqueInput | MediaWhereUniqueInput[]
    disconnect?: MediaWhereUniqueInput | MediaWhereUniqueInput[]
    delete?: MediaWhereUniqueInput | MediaWhereUniqueInput[]
    connect?: MediaWhereUniqueInput | MediaWhereUniqueInput[]
    update?: MediaUpdateWithWhereUniqueWithoutProjectInput | MediaUpdateWithWhereUniqueWithoutProjectInput[]
    updateMany?: MediaUpdateManyWithWhereWithoutProjectInput | MediaUpdateManyWithWhereWithoutProjectInput[]
    deleteMany?: MediaScalarWhereInput | MediaScalarWhereInput[]
  }

  export type PaymentUncheckedUpdateManyWithoutProjectNestedInput = {
    create?: XOR<PaymentCreateWithoutProjectInput, PaymentUncheckedCreateWithoutProjectInput> | PaymentCreateWithoutProjectInput[] | PaymentUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: PaymentCreateOrConnectWithoutProjectInput | PaymentCreateOrConnectWithoutProjectInput[]
    upsert?: PaymentUpsertWithWhereUniqueWithoutProjectInput | PaymentUpsertWithWhereUniqueWithoutProjectInput[]
    createMany?: PaymentCreateManyProjectInputEnvelope
    set?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    disconnect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    delete?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    connect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    update?: PaymentUpdateWithWhereUniqueWithoutProjectInput | PaymentUpdateWithWhereUniqueWithoutProjectInput[]
    updateMany?: PaymentUpdateManyWithWhereWithoutProjectInput | PaymentUpdateManyWithWhereWithoutProjectInput[]
    deleteMany?: PaymentScalarWhereInput | PaymentScalarWhereInput[]
  }

  export type MilestoneUncheckedUpdateManyWithoutProjectNestedInput = {
    create?: XOR<MilestoneCreateWithoutProjectInput, MilestoneUncheckedCreateWithoutProjectInput> | MilestoneCreateWithoutProjectInput[] | MilestoneUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: MilestoneCreateOrConnectWithoutProjectInput | MilestoneCreateOrConnectWithoutProjectInput[]
    upsert?: MilestoneUpsertWithWhereUniqueWithoutProjectInput | MilestoneUpsertWithWhereUniqueWithoutProjectInput[]
    createMany?: MilestoneCreateManyProjectInputEnvelope
    set?: MilestoneWhereUniqueInput | MilestoneWhereUniqueInput[]
    disconnect?: MilestoneWhereUniqueInput | MilestoneWhereUniqueInput[]
    delete?: MilestoneWhereUniqueInput | MilestoneWhereUniqueInput[]
    connect?: MilestoneWhereUniqueInput | MilestoneWhereUniqueInput[]
    update?: MilestoneUpdateWithWhereUniqueWithoutProjectInput | MilestoneUpdateWithWhereUniqueWithoutProjectInput[]
    updateMany?: MilestoneUpdateManyWithWhereWithoutProjectInput | MilestoneUpdateManyWithWhereWithoutProjectInput[]
    deleteMany?: MilestoneScalarWhereInput | MilestoneScalarWhereInput[]
  }

  export type InspectionUncheckedUpdateManyWithoutProjectNestedInput = {
    create?: XOR<InspectionCreateWithoutProjectInput, InspectionUncheckedCreateWithoutProjectInput> | InspectionCreateWithoutProjectInput[] | InspectionUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: InspectionCreateOrConnectWithoutProjectInput | InspectionCreateOrConnectWithoutProjectInput[]
    upsert?: InspectionUpsertWithWhereUniqueWithoutProjectInput | InspectionUpsertWithWhereUniqueWithoutProjectInput[]
    createMany?: InspectionCreateManyProjectInputEnvelope
    set?: InspectionWhereUniqueInput | InspectionWhereUniqueInput[]
    disconnect?: InspectionWhereUniqueInput | InspectionWhereUniqueInput[]
    delete?: InspectionWhereUniqueInput | InspectionWhereUniqueInput[]
    connect?: InspectionWhereUniqueInput | InspectionWhereUniqueInput[]
    update?: InspectionUpdateWithWhereUniqueWithoutProjectInput | InspectionUpdateWithWhereUniqueWithoutProjectInput[]
    updateMany?: InspectionUpdateManyWithWhereWithoutProjectInput | InspectionUpdateManyWithWhereWithoutProjectInput[]
    deleteMany?: InspectionScalarWhereInput | InspectionScalarWhereInput[]
  }

  export type QueryUncheckedUpdateManyWithoutProjectNestedInput = {
    create?: XOR<QueryCreateWithoutProjectInput, QueryUncheckedCreateWithoutProjectInput> | QueryCreateWithoutProjectInput[] | QueryUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: QueryCreateOrConnectWithoutProjectInput | QueryCreateOrConnectWithoutProjectInput[]
    upsert?: QueryUpsertWithWhereUniqueWithoutProjectInput | QueryUpsertWithWhereUniqueWithoutProjectInput[]
    createMany?: QueryCreateManyProjectInputEnvelope
    set?: QueryWhereUniqueInput | QueryWhereUniqueInput[]
    disconnect?: QueryWhereUniqueInput | QueryWhereUniqueInput[]
    delete?: QueryWhereUniqueInput | QueryWhereUniqueInput[]
    connect?: QueryWhereUniqueInput | QueryWhereUniqueInput[]
    update?: QueryUpdateWithWhereUniqueWithoutProjectInput | QueryUpdateWithWhereUniqueWithoutProjectInput[]
    updateMany?: QueryUpdateManyWithWhereWithoutProjectInput | QueryUpdateManyWithWhereWithoutProjectInput[]
    deleteMany?: QueryScalarWhereInput | QueryScalarWhereInput[]
  }

  export type MaterialUncheckedUpdateManyWithoutProjectNestedInput = {
    create?: XOR<MaterialCreateWithoutProjectInput, MaterialUncheckedCreateWithoutProjectInput> | MaterialCreateWithoutProjectInput[] | MaterialUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: MaterialCreateOrConnectWithoutProjectInput | MaterialCreateOrConnectWithoutProjectInput[]
    upsert?: MaterialUpsertWithWhereUniqueWithoutProjectInput | MaterialUpsertWithWhereUniqueWithoutProjectInput[]
    createMany?: MaterialCreateManyProjectInputEnvelope
    set?: MaterialWhereUniqueInput | MaterialWhereUniqueInput[]
    disconnect?: MaterialWhereUniqueInput | MaterialWhereUniqueInput[]
    delete?: MaterialWhereUniqueInput | MaterialWhereUniqueInput[]
    connect?: MaterialWhereUniqueInput | MaterialWhereUniqueInput[]
    update?: MaterialUpdateWithWhereUniqueWithoutProjectInput | MaterialUpdateWithWhereUniqueWithoutProjectInput[]
    updateMany?: MaterialUpdateManyWithWhereWithoutProjectInput | MaterialUpdateManyWithWhereWithoutProjectInput[]
    deleteMany?: MaterialScalarWhereInput | MaterialScalarWhereInput[]
  }

  export type AuditLogUncheckedUpdateManyWithoutProjectNestedInput = {
    create?: XOR<AuditLogCreateWithoutProjectInput, AuditLogUncheckedCreateWithoutProjectInput> | AuditLogCreateWithoutProjectInput[] | AuditLogUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: AuditLogCreateOrConnectWithoutProjectInput | AuditLogCreateOrConnectWithoutProjectInput[]
    upsert?: AuditLogUpsertWithWhereUniqueWithoutProjectInput | AuditLogUpsertWithWhereUniqueWithoutProjectInput[]
    createMany?: AuditLogCreateManyProjectInputEnvelope
    set?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    disconnect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    delete?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    connect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    update?: AuditLogUpdateWithWhereUniqueWithoutProjectInput | AuditLogUpdateWithWhereUniqueWithoutProjectInput[]
    updateMany?: AuditLogUpdateManyWithWhereWithoutProjectInput | AuditLogUpdateManyWithWhereWithoutProjectInput[]
    deleteMany?: AuditLogScalarWhereInput | AuditLogScalarWhereInput[]
  }

  export type ProjectCreateNestedOneWithoutMembersInput = {
    create?: XOR<ProjectCreateWithoutMembersInput, ProjectUncheckedCreateWithoutMembersInput>
    connectOrCreate?: ProjectCreateOrConnectWithoutMembersInput
    connect?: ProjectWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutProjectMembersInput = {
    create?: XOR<UserCreateWithoutProjectMembersInput, UserUncheckedCreateWithoutProjectMembersInput>
    connectOrCreate?: UserCreateOrConnectWithoutProjectMembersInput
    connect?: UserWhereUniqueInput
  }

  export type EnumProjectMemberRoleFieldUpdateOperationsInput = {
    set?: $Enums.ProjectMemberRole
  }

  export type ProjectUpdateOneRequiredWithoutMembersNestedInput = {
    create?: XOR<ProjectCreateWithoutMembersInput, ProjectUncheckedCreateWithoutMembersInput>
    connectOrCreate?: ProjectCreateOrConnectWithoutMembersInput
    upsert?: ProjectUpsertWithoutMembersInput
    connect?: ProjectWhereUniqueInput
    update?: XOR<XOR<ProjectUpdateToOneWithWhereWithoutMembersInput, ProjectUpdateWithoutMembersInput>, ProjectUncheckedUpdateWithoutMembersInput>
  }

  export type UserUpdateOneRequiredWithoutProjectMembersNestedInput = {
    create?: XOR<UserCreateWithoutProjectMembersInput, UserUncheckedCreateWithoutProjectMembersInput>
    connectOrCreate?: UserCreateOrConnectWithoutProjectMembersInput
    upsert?: UserUpsertWithoutProjectMembersInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutProjectMembersInput, UserUpdateWithoutProjectMembersInput>, UserUncheckedUpdateWithoutProjectMembersInput>
  }

  export type ProjectCreateNestedOneWithoutUpdatesInput = {
    create?: XOR<ProjectCreateWithoutUpdatesInput, ProjectUncheckedCreateWithoutUpdatesInput>
    connectOrCreate?: ProjectCreateOrConnectWithoutUpdatesInput
    connect?: ProjectWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutProjectUpdatesInput = {
    create?: XOR<UserCreateWithoutProjectUpdatesInput, UserUncheckedCreateWithoutProjectUpdatesInput>
    connectOrCreate?: UserCreateOrConnectWithoutProjectUpdatesInput
    connect?: UserWhereUniqueInput
  }

  export type MediaCreateNestedManyWithoutProjectUpdateInput = {
    create?: XOR<MediaCreateWithoutProjectUpdateInput, MediaUncheckedCreateWithoutProjectUpdateInput> | MediaCreateWithoutProjectUpdateInput[] | MediaUncheckedCreateWithoutProjectUpdateInput[]
    connectOrCreate?: MediaCreateOrConnectWithoutProjectUpdateInput | MediaCreateOrConnectWithoutProjectUpdateInput[]
    createMany?: MediaCreateManyProjectUpdateInputEnvelope
    connect?: MediaWhereUniqueInput | MediaWhereUniqueInput[]
  }

  export type MediaUncheckedCreateNestedManyWithoutProjectUpdateInput = {
    create?: XOR<MediaCreateWithoutProjectUpdateInput, MediaUncheckedCreateWithoutProjectUpdateInput> | MediaCreateWithoutProjectUpdateInput[] | MediaUncheckedCreateWithoutProjectUpdateInput[]
    connectOrCreate?: MediaCreateOrConnectWithoutProjectUpdateInput | MediaCreateOrConnectWithoutProjectUpdateInput[]
    createMany?: MediaCreateManyProjectUpdateInputEnvelope
    connect?: MediaWhereUniqueInput | MediaWhereUniqueInput[]
  }

  export type ProjectUpdateOneRequiredWithoutUpdatesNestedInput = {
    create?: XOR<ProjectCreateWithoutUpdatesInput, ProjectUncheckedCreateWithoutUpdatesInput>
    connectOrCreate?: ProjectCreateOrConnectWithoutUpdatesInput
    upsert?: ProjectUpsertWithoutUpdatesInput
    connect?: ProjectWhereUniqueInput
    update?: XOR<XOR<ProjectUpdateToOneWithWhereWithoutUpdatesInput, ProjectUpdateWithoutUpdatesInput>, ProjectUncheckedUpdateWithoutUpdatesInput>
  }

  export type UserUpdateOneRequiredWithoutProjectUpdatesNestedInput = {
    create?: XOR<UserCreateWithoutProjectUpdatesInput, UserUncheckedCreateWithoutProjectUpdatesInput>
    connectOrCreate?: UserCreateOrConnectWithoutProjectUpdatesInput
    upsert?: UserUpsertWithoutProjectUpdatesInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutProjectUpdatesInput, UserUpdateWithoutProjectUpdatesInput>, UserUncheckedUpdateWithoutProjectUpdatesInput>
  }

  export type MediaUpdateManyWithoutProjectUpdateNestedInput = {
    create?: XOR<MediaCreateWithoutProjectUpdateInput, MediaUncheckedCreateWithoutProjectUpdateInput> | MediaCreateWithoutProjectUpdateInput[] | MediaUncheckedCreateWithoutProjectUpdateInput[]
    connectOrCreate?: MediaCreateOrConnectWithoutProjectUpdateInput | MediaCreateOrConnectWithoutProjectUpdateInput[]
    upsert?: MediaUpsertWithWhereUniqueWithoutProjectUpdateInput | MediaUpsertWithWhereUniqueWithoutProjectUpdateInput[]
    createMany?: MediaCreateManyProjectUpdateInputEnvelope
    set?: MediaWhereUniqueInput | MediaWhereUniqueInput[]
    disconnect?: MediaWhereUniqueInput | MediaWhereUniqueInput[]
    delete?: MediaWhereUniqueInput | MediaWhereUniqueInput[]
    connect?: MediaWhereUniqueInput | MediaWhereUniqueInput[]
    update?: MediaUpdateWithWhereUniqueWithoutProjectUpdateInput | MediaUpdateWithWhereUniqueWithoutProjectUpdateInput[]
    updateMany?: MediaUpdateManyWithWhereWithoutProjectUpdateInput | MediaUpdateManyWithWhereWithoutProjectUpdateInput[]
    deleteMany?: MediaScalarWhereInput | MediaScalarWhereInput[]
  }

  export type MediaUncheckedUpdateManyWithoutProjectUpdateNestedInput = {
    create?: XOR<MediaCreateWithoutProjectUpdateInput, MediaUncheckedCreateWithoutProjectUpdateInput> | MediaCreateWithoutProjectUpdateInput[] | MediaUncheckedCreateWithoutProjectUpdateInput[]
    connectOrCreate?: MediaCreateOrConnectWithoutProjectUpdateInput | MediaCreateOrConnectWithoutProjectUpdateInput[]
    upsert?: MediaUpsertWithWhereUniqueWithoutProjectUpdateInput | MediaUpsertWithWhereUniqueWithoutProjectUpdateInput[]
    createMany?: MediaCreateManyProjectUpdateInputEnvelope
    set?: MediaWhereUniqueInput | MediaWhereUniqueInput[]
    disconnect?: MediaWhereUniqueInput | MediaWhereUniqueInput[]
    delete?: MediaWhereUniqueInput | MediaWhereUniqueInput[]
    connect?: MediaWhereUniqueInput | MediaWhereUniqueInput[]
    update?: MediaUpdateWithWhereUniqueWithoutProjectUpdateInput | MediaUpdateWithWhereUniqueWithoutProjectUpdateInput[]
    updateMany?: MediaUpdateManyWithWhereWithoutProjectUpdateInput | MediaUpdateManyWithWhereWithoutProjectUpdateInput[]
    deleteMany?: MediaScalarWhereInput | MediaScalarWhereInput[]
  }

  export type ProjectCreateNestedOneWithoutMediaInput = {
    create?: XOR<ProjectCreateWithoutMediaInput, ProjectUncheckedCreateWithoutMediaInput>
    connectOrCreate?: ProjectCreateOrConnectWithoutMediaInput
    connect?: ProjectWhereUniqueInput
  }

  export type ProjectUpdateCreateNestedOneWithoutMediaInput = {
    create?: XOR<ProjectUpdateCreateWithoutMediaInput, ProjectUpdateUncheckedCreateWithoutMediaInput>
    connectOrCreate?: ProjectUpdateCreateOrConnectWithoutMediaInput
    connect?: ProjectUpdateWhereUniqueInput
  }

  export type PaymentCreateNestedOneWithoutMediaInput = {
    create?: XOR<PaymentCreateWithoutMediaInput, PaymentUncheckedCreateWithoutMediaInput>
    connectOrCreate?: PaymentCreateOrConnectWithoutMediaInput
    connect?: PaymentWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutMediaInput = {
    create?: XOR<UserCreateWithoutMediaInput, UserUncheckedCreateWithoutMediaInput>
    connectOrCreate?: UserCreateOrConnectWithoutMediaInput
    connect?: UserWhereUniqueInput
  }

  export type InspectionResponseCreateNestedManyWithoutMediaInput = {
    create?: XOR<InspectionResponseCreateWithoutMediaInput, InspectionResponseUncheckedCreateWithoutMediaInput> | InspectionResponseCreateWithoutMediaInput[] | InspectionResponseUncheckedCreateWithoutMediaInput[]
    connectOrCreate?: InspectionResponseCreateOrConnectWithoutMediaInput | InspectionResponseCreateOrConnectWithoutMediaInput[]
    createMany?: InspectionResponseCreateManyMediaInputEnvelope
    connect?: InspectionResponseWhereUniqueInput | InspectionResponseWhereUniqueInput[]
  }

  export type QueryCreateNestedOneWithoutAttachmentsInput = {
    create?: XOR<QueryCreateWithoutAttachmentsInput, QueryUncheckedCreateWithoutAttachmentsInput>
    connectOrCreate?: QueryCreateOrConnectWithoutAttachmentsInput
    connect?: QueryWhereUniqueInput
  }

  export type InspectionResponseUncheckedCreateNestedManyWithoutMediaInput = {
    create?: XOR<InspectionResponseCreateWithoutMediaInput, InspectionResponseUncheckedCreateWithoutMediaInput> | InspectionResponseCreateWithoutMediaInput[] | InspectionResponseUncheckedCreateWithoutMediaInput[]
    connectOrCreate?: InspectionResponseCreateOrConnectWithoutMediaInput | InspectionResponseCreateOrConnectWithoutMediaInput[]
    createMany?: InspectionResponseCreateManyMediaInputEnvelope
    connect?: InspectionResponseWhereUniqueInput | InspectionResponseWhereUniqueInput[]
  }

  export type EnumMediaTypeFieldUpdateOperationsInput = {
    set?: $Enums.MediaType
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type ProjectUpdateOneRequiredWithoutMediaNestedInput = {
    create?: XOR<ProjectCreateWithoutMediaInput, ProjectUncheckedCreateWithoutMediaInput>
    connectOrCreate?: ProjectCreateOrConnectWithoutMediaInput
    upsert?: ProjectUpsertWithoutMediaInput
    connect?: ProjectWhereUniqueInput
    update?: XOR<XOR<ProjectUpdateToOneWithWhereWithoutMediaInput, ProjectUpdateWithoutMediaInput>, ProjectUncheckedUpdateWithoutMediaInput>
  }

  export type ProjectUpdateUpdateOneWithoutMediaNestedInput = {
    create?: XOR<ProjectUpdateCreateWithoutMediaInput, ProjectUpdateUncheckedCreateWithoutMediaInput>
    connectOrCreate?: ProjectUpdateCreateOrConnectWithoutMediaInput
    upsert?: ProjectUpdateUpsertWithoutMediaInput
    disconnect?: ProjectUpdateWhereInput | boolean
    delete?: ProjectUpdateWhereInput | boolean
    connect?: ProjectUpdateWhereUniqueInput
    update?: XOR<XOR<ProjectUpdateUpdateToOneWithWhereWithoutMediaInput, ProjectUpdateUpdateWithoutMediaInput>, ProjectUpdateUncheckedUpdateWithoutMediaInput>
  }

  export type PaymentUpdateOneWithoutMediaNestedInput = {
    create?: XOR<PaymentCreateWithoutMediaInput, PaymentUncheckedCreateWithoutMediaInput>
    connectOrCreate?: PaymentCreateOrConnectWithoutMediaInput
    upsert?: PaymentUpsertWithoutMediaInput
    disconnect?: PaymentWhereInput | boolean
    delete?: PaymentWhereInput | boolean
    connect?: PaymentWhereUniqueInput
    update?: XOR<XOR<PaymentUpdateToOneWithWhereWithoutMediaInput, PaymentUpdateWithoutMediaInput>, PaymentUncheckedUpdateWithoutMediaInput>
  }

  export type UserUpdateOneRequiredWithoutMediaNestedInput = {
    create?: XOR<UserCreateWithoutMediaInput, UserUncheckedCreateWithoutMediaInput>
    connectOrCreate?: UserCreateOrConnectWithoutMediaInput
    upsert?: UserUpsertWithoutMediaInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutMediaInput, UserUpdateWithoutMediaInput>, UserUncheckedUpdateWithoutMediaInput>
  }

  export type InspectionResponseUpdateManyWithoutMediaNestedInput = {
    create?: XOR<InspectionResponseCreateWithoutMediaInput, InspectionResponseUncheckedCreateWithoutMediaInput> | InspectionResponseCreateWithoutMediaInput[] | InspectionResponseUncheckedCreateWithoutMediaInput[]
    connectOrCreate?: InspectionResponseCreateOrConnectWithoutMediaInput | InspectionResponseCreateOrConnectWithoutMediaInput[]
    upsert?: InspectionResponseUpsertWithWhereUniqueWithoutMediaInput | InspectionResponseUpsertWithWhereUniqueWithoutMediaInput[]
    createMany?: InspectionResponseCreateManyMediaInputEnvelope
    set?: InspectionResponseWhereUniqueInput | InspectionResponseWhereUniqueInput[]
    disconnect?: InspectionResponseWhereUniqueInput | InspectionResponseWhereUniqueInput[]
    delete?: InspectionResponseWhereUniqueInput | InspectionResponseWhereUniqueInput[]
    connect?: InspectionResponseWhereUniqueInput | InspectionResponseWhereUniqueInput[]
    update?: InspectionResponseUpdateWithWhereUniqueWithoutMediaInput | InspectionResponseUpdateWithWhereUniqueWithoutMediaInput[]
    updateMany?: InspectionResponseUpdateManyWithWhereWithoutMediaInput | InspectionResponseUpdateManyWithWhereWithoutMediaInput[]
    deleteMany?: InspectionResponseScalarWhereInput | InspectionResponseScalarWhereInput[]
  }

  export type QueryUpdateOneWithoutAttachmentsNestedInput = {
    create?: XOR<QueryCreateWithoutAttachmentsInput, QueryUncheckedCreateWithoutAttachmentsInput>
    connectOrCreate?: QueryCreateOrConnectWithoutAttachmentsInput
    upsert?: QueryUpsertWithoutAttachmentsInput
    disconnect?: QueryWhereInput | boolean
    delete?: QueryWhereInput | boolean
    connect?: QueryWhereUniqueInput
    update?: XOR<XOR<QueryUpdateToOneWithWhereWithoutAttachmentsInput, QueryUpdateWithoutAttachmentsInput>, QueryUncheckedUpdateWithoutAttachmentsInput>
  }

  export type InspectionResponseUncheckedUpdateManyWithoutMediaNestedInput = {
    create?: XOR<InspectionResponseCreateWithoutMediaInput, InspectionResponseUncheckedCreateWithoutMediaInput> | InspectionResponseCreateWithoutMediaInput[] | InspectionResponseUncheckedCreateWithoutMediaInput[]
    connectOrCreate?: InspectionResponseCreateOrConnectWithoutMediaInput | InspectionResponseCreateOrConnectWithoutMediaInput[]
    upsert?: InspectionResponseUpsertWithWhereUniqueWithoutMediaInput | InspectionResponseUpsertWithWhereUniqueWithoutMediaInput[]
    createMany?: InspectionResponseCreateManyMediaInputEnvelope
    set?: InspectionResponseWhereUniqueInput | InspectionResponseWhereUniqueInput[]
    disconnect?: InspectionResponseWhereUniqueInput | InspectionResponseWhereUniqueInput[]
    delete?: InspectionResponseWhereUniqueInput | InspectionResponseWhereUniqueInput[]
    connect?: InspectionResponseWhereUniqueInput | InspectionResponseWhereUniqueInput[]
    update?: InspectionResponseUpdateWithWhereUniqueWithoutMediaInput | InspectionResponseUpdateWithWhereUniqueWithoutMediaInput[]
    updateMany?: InspectionResponseUpdateManyWithWhereWithoutMediaInput | InspectionResponseUpdateManyWithWhereWithoutMediaInput[]
    deleteMany?: InspectionResponseScalarWhereInput | InspectionResponseScalarWhereInput[]
  }

  export type ProjectCreateNestedOneWithoutPaymentsInput = {
    create?: XOR<ProjectCreateWithoutPaymentsInput, ProjectUncheckedCreateWithoutPaymentsInput>
    connectOrCreate?: ProjectCreateOrConnectWithoutPaymentsInput
    connect?: ProjectWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutPaymentsCreatedInput = {
    create?: XOR<UserCreateWithoutPaymentsCreatedInput, UserUncheckedCreateWithoutPaymentsCreatedInput>
    connectOrCreate?: UserCreateOrConnectWithoutPaymentsCreatedInput
    connect?: UserWhereUniqueInput
  }

  export type MediaCreateNestedManyWithoutPaymentInput = {
    create?: XOR<MediaCreateWithoutPaymentInput, MediaUncheckedCreateWithoutPaymentInput> | MediaCreateWithoutPaymentInput[] | MediaUncheckedCreateWithoutPaymentInput[]
    connectOrCreate?: MediaCreateOrConnectWithoutPaymentInput | MediaCreateOrConnectWithoutPaymentInput[]
    createMany?: MediaCreateManyPaymentInputEnvelope
    connect?: MediaWhereUniqueInput | MediaWhereUniqueInput[]
  }

  export type MediaUncheckedCreateNestedManyWithoutPaymentInput = {
    create?: XOR<MediaCreateWithoutPaymentInput, MediaUncheckedCreateWithoutPaymentInput> | MediaCreateWithoutPaymentInput[] | MediaUncheckedCreateWithoutPaymentInput[]
    connectOrCreate?: MediaCreateOrConnectWithoutPaymentInput | MediaCreateOrConnectWithoutPaymentInput[]
    createMany?: MediaCreateManyPaymentInputEnvelope
    connect?: MediaWhereUniqueInput | MediaWhereUniqueInput[]
  }

  export type DecimalFieldUpdateOperationsInput = {
    set?: Decimal | DecimalJsLike | number | string
    increment?: Decimal | DecimalJsLike | number | string
    decrement?: Decimal | DecimalJsLike | number | string
    multiply?: Decimal | DecimalJsLike | number | string
    divide?: Decimal | DecimalJsLike | number | string
  }

  export type EnumPaymentStatusFieldUpdateOperationsInput = {
    set?: $Enums.PaymentStatus
  }

  export type NullableEnumPaymentCategoryFieldUpdateOperationsInput = {
    set?: $Enums.PaymentCategory | null
  }

  export type ProjectUpdateOneRequiredWithoutPaymentsNestedInput = {
    create?: XOR<ProjectCreateWithoutPaymentsInput, ProjectUncheckedCreateWithoutPaymentsInput>
    connectOrCreate?: ProjectCreateOrConnectWithoutPaymentsInput
    upsert?: ProjectUpsertWithoutPaymentsInput
    connect?: ProjectWhereUniqueInput
    update?: XOR<XOR<ProjectUpdateToOneWithWhereWithoutPaymentsInput, ProjectUpdateWithoutPaymentsInput>, ProjectUncheckedUpdateWithoutPaymentsInput>
  }

  export type UserUpdateOneRequiredWithoutPaymentsCreatedNestedInput = {
    create?: XOR<UserCreateWithoutPaymentsCreatedInput, UserUncheckedCreateWithoutPaymentsCreatedInput>
    connectOrCreate?: UserCreateOrConnectWithoutPaymentsCreatedInput
    upsert?: UserUpsertWithoutPaymentsCreatedInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutPaymentsCreatedInput, UserUpdateWithoutPaymentsCreatedInput>, UserUncheckedUpdateWithoutPaymentsCreatedInput>
  }

  export type MediaUpdateManyWithoutPaymentNestedInput = {
    create?: XOR<MediaCreateWithoutPaymentInput, MediaUncheckedCreateWithoutPaymentInput> | MediaCreateWithoutPaymentInput[] | MediaUncheckedCreateWithoutPaymentInput[]
    connectOrCreate?: MediaCreateOrConnectWithoutPaymentInput | MediaCreateOrConnectWithoutPaymentInput[]
    upsert?: MediaUpsertWithWhereUniqueWithoutPaymentInput | MediaUpsertWithWhereUniqueWithoutPaymentInput[]
    createMany?: MediaCreateManyPaymentInputEnvelope
    set?: MediaWhereUniqueInput | MediaWhereUniqueInput[]
    disconnect?: MediaWhereUniqueInput | MediaWhereUniqueInput[]
    delete?: MediaWhereUniqueInput | MediaWhereUniqueInput[]
    connect?: MediaWhereUniqueInput | MediaWhereUniqueInput[]
    update?: MediaUpdateWithWhereUniqueWithoutPaymentInput | MediaUpdateWithWhereUniqueWithoutPaymentInput[]
    updateMany?: MediaUpdateManyWithWhereWithoutPaymentInput | MediaUpdateManyWithWhereWithoutPaymentInput[]
    deleteMany?: MediaScalarWhereInput | MediaScalarWhereInput[]
  }

  export type MediaUncheckedUpdateManyWithoutPaymentNestedInput = {
    create?: XOR<MediaCreateWithoutPaymentInput, MediaUncheckedCreateWithoutPaymentInput> | MediaCreateWithoutPaymentInput[] | MediaUncheckedCreateWithoutPaymentInput[]
    connectOrCreate?: MediaCreateOrConnectWithoutPaymentInput | MediaCreateOrConnectWithoutPaymentInput[]
    upsert?: MediaUpsertWithWhereUniqueWithoutPaymentInput | MediaUpsertWithWhereUniqueWithoutPaymentInput[]
    createMany?: MediaCreateManyPaymentInputEnvelope
    set?: MediaWhereUniqueInput | MediaWhereUniqueInput[]
    disconnect?: MediaWhereUniqueInput | MediaWhereUniqueInput[]
    delete?: MediaWhereUniqueInput | MediaWhereUniqueInput[]
    connect?: MediaWhereUniqueInput | MediaWhereUniqueInput[]
    update?: MediaUpdateWithWhereUniqueWithoutPaymentInput | MediaUpdateWithWhereUniqueWithoutPaymentInput[]
    updateMany?: MediaUpdateManyWithWhereWithoutPaymentInput | MediaUpdateManyWithWhereWithoutPaymentInput[]
    deleteMany?: MediaScalarWhereInput | MediaScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutNotificationsInput = {
    create?: XOR<UserCreateWithoutNotificationsInput, UserUncheckedCreateWithoutNotificationsInput>
    connectOrCreate?: UserCreateOrConnectWithoutNotificationsInput
    connect?: UserWhereUniqueInput
  }

  export type EnumNotificationPriorityFieldUpdateOperationsInput = {
    set?: $Enums.NotificationPriority
  }

  export type UserUpdateOneRequiredWithoutNotificationsNestedInput = {
    create?: XOR<UserCreateWithoutNotificationsInput, UserUncheckedCreateWithoutNotificationsInput>
    connectOrCreate?: UserCreateOrConnectWithoutNotificationsInput
    upsert?: UserUpsertWithoutNotificationsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutNotificationsInput, UserUpdateWithoutNotificationsInput>, UserUncheckedUpdateWithoutNotificationsInput>
  }

  export type UserCreateNestedOneWithoutNotificationPrefsInput = {
    create?: XOR<UserCreateWithoutNotificationPrefsInput, UserUncheckedCreateWithoutNotificationPrefsInput>
    connectOrCreate?: UserCreateOrConnectWithoutNotificationPrefsInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutNotificationPrefsNestedInput = {
    create?: XOR<UserCreateWithoutNotificationPrefsInput, UserUncheckedCreateWithoutNotificationPrefsInput>
    connectOrCreate?: UserCreateOrConnectWithoutNotificationPrefsInput
    upsert?: UserUpsertWithoutNotificationPrefsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutNotificationPrefsInput, UserUpdateWithoutNotificationPrefsInput>, UserUncheckedUpdateWithoutNotificationPrefsInput>
  }

  export type ProjectCreateNestedOneWithoutMilestonesInput = {
    create?: XOR<ProjectCreateWithoutMilestonesInput, ProjectUncheckedCreateWithoutMilestonesInput>
    connectOrCreate?: ProjectCreateOrConnectWithoutMilestonesInput
    connect?: ProjectWhereUniqueInput
  }

  export type ChecklistItemCreateNestedManyWithoutMilestoneInput = {
    create?: XOR<ChecklistItemCreateWithoutMilestoneInput, ChecklistItemUncheckedCreateWithoutMilestoneInput> | ChecklistItemCreateWithoutMilestoneInput[] | ChecklistItemUncheckedCreateWithoutMilestoneInput[]
    connectOrCreate?: ChecklistItemCreateOrConnectWithoutMilestoneInput | ChecklistItemCreateOrConnectWithoutMilestoneInput[]
    createMany?: ChecklistItemCreateManyMilestoneInputEnvelope
    connect?: ChecklistItemWhereUniqueInput | ChecklistItemWhereUniqueInput[]
  }

  export type InspectionCreateNestedManyWithoutMilestoneInput = {
    create?: XOR<InspectionCreateWithoutMilestoneInput, InspectionUncheckedCreateWithoutMilestoneInput> | InspectionCreateWithoutMilestoneInput[] | InspectionUncheckedCreateWithoutMilestoneInput[]
    connectOrCreate?: InspectionCreateOrConnectWithoutMilestoneInput | InspectionCreateOrConnectWithoutMilestoneInput[]
    createMany?: InspectionCreateManyMilestoneInputEnvelope
    connect?: InspectionWhereUniqueInput | InspectionWhereUniqueInput[]
  }

  export type ChecklistItemUncheckedCreateNestedManyWithoutMilestoneInput = {
    create?: XOR<ChecklistItemCreateWithoutMilestoneInput, ChecklistItemUncheckedCreateWithoutMilestoneInput> | ChecklistItemCreateWithoutMilestoneInput[] | ChecklistItemUncheckedCreateWithoutMilestoneInput[]
    connectOrCreate?: ChecklistItemCreateOrConnectWithoutMilestoneInput | ChecklistItemCreateOrConnectWithoutMilestoneInput[]
    createMany?: ChecklistItemCreateManyMilestoneInputEnvelope
    connect?: ChecklistItemWhereUniqueInput | ChecklistItemWhereUniqueInput[]
  }

  export type InspectionUncheckedCreateNestedManyWithoutMilestoneInput = {
    create?: XOR<InspectionCreateWithoutMilestoneInput, InspectionUncheckedCreateWithoutMilestoneInput> | InspectionCreateWithoutMilestoneInput[] | InspectionUncheckedCreateWithoutMilestoneInput[]
    connectOrCreate?: InspectionCreateOrConnectWithoutMilestoneInput | InspectionCreateOrConnectWithoutMilestoneInput[]
    createMany?: InspectionCreateManyMilestoneInputEnvelope
    connect?: InspectionWhereUniqueInput | InspectionWhereUniqueInput[]
  }

  export type ProjectUpdateOneRequiredWithoutMilestonesNestedInput = {
    create?: XOR<ProjectCreateWithoutMilestonesInput, ProjectUncheckedCreateWithoutMilestonesInput>
    connectOrCreate?: ProjectCreateOrConnectWithoutMilestonesInput
    upsert?: ProjectUpsertWithoutMilestonesInput
    connect?: ProjectWhereUniqueInput
    update?: XOR<XOR<ProjectUpdateToOneWithWhereWithoutMilestonesInput, ProjectUpdateWithoutMilestonesInput>, ProjectUncheckedUpdateWithoutMilestonesInput>
  }

  export type ChecklistItemUpdateManyWithoutMilestoneNestedInput = {
    create?: XOR<ChecklistItemCreateWithoutMilestoneInput, ChecklistItemUncheckedCreateWithoutMilestoneInput> | ChecklistItemCreateWithoutMilestoneInput[] | ChecklistItemUncheckedCreateWithoutMilestoneInput[]
    connectOrCreate?: ChecklistItemCreateOrConnectWithoutMilestoneInput | ChecklistItemCreateOrConnectWithoutMilestoneInput[]
    upsert?: ChecklistItemUpsertWithWhereUniqueWithoutMilestoneInput | ChecklistItemUpsertWithWhereUniqueWithoutMilestoneInput[]
    createMany?: ChecklistItemCreateManyMilestoneInputEnvelope
    set?: ChecklistItemWhereUniqueInput | ChecklistItemWhereUniqueInput[]
    disconnect?: ChecklistItemWhereUniqueInput | ChecklistItemWhereUniqueInput[]
    delete?: ChecklistItemWhereUniqueInput | ChecklistItemWhereUniqueInput[]
    connect?: ChecklistItemWhereUniqueInput | ChecklistItemWhereUniqueInput[]
    update?: ChecklistItemUpdateWithWhereUniqueWithoutMilestoneInput | ChecklistItemUpdateWithWhereUniqueWithoutMilestoneInput[]
    updateMany?: ChecklistItemUpdateManyWithWhereWithoutMilestoneInput | ChecklistItemUpdateManyWithWhereWithoutMilestoneInput[]
    deleteMany?: ChecklistItemScalarWhereInput | ChecklistItemScalarWhereInput[]
  }

  export type InspectionUpdateManyWithoutMilestoneNestedInput = {
    create?: XOR<InspectionCreateWithoutMilestoneInput, InspectionUncheckedCreateWithoutMilestoneInput> | InspectionCreateWithoutMilestoneInput[] | InspectionUncheckedCreateWithoutMilestoneInput[]
    connectOrCreate?: InspectionCreateOrConnectWithoutMilestoneInput | InspectionCreateOrConnectWithoutMilestoneInput[]
    upsert?: InspectionUpsertWithWhereUniqueWithoutMilestoneInput | InspectionUpsertWithWhereUniqueWithoutMilestoneInput[]
    createMany?: InspectionCreateManyMilestoneInputEnvelope
    set?: InspectionWhereUniqueInput | InspectionWhereUniqueInput[]
    disconnect?: InspectionWhereUniqueInput | InspectionWhereUniqueInput[]
    delete?: InspectionWhereUniqueInput | InspectionWhereUniqueInput[]
    connect?: InspectionWhereUniqueInput | InspectionWhereUniqueInput[]
    update?: InspectionUpdateWithWhereUniqueWithoutMilestoneInput | InspectionUpdateWithWhereUniqueWithoutMilestoneInput[]
    updateMany?: InspectionUpdateManyWithWhereWithoutMilestoneInput | InspectionUpdateManyWithWhereWithoutMilestoneInput[]
    deleteMany?: InspectionScalarWhereInput | InspectionScalarWhereInput[]
  }

  export type ChecklistItemUncheckedUpdateManyWithoutMilestoneNestedInput = {
    create?: XOR<ChecklistItemCreateWithoutMilestoneInput, ChecklistItemUncheckedCreateWithoutMilestoneInput> | ChecklistItemCreateWithoutMilestoneInput[] | ChecklistItemUncheckedCreateWithoutMilestoneInput[]
    connectOrCreate?: ChecklistItemCreateOrConnectWithoutMilestoneInput | ChecklistItemCreateOrConnectWithoutMilestoneInput[]
    upsert?: ChecklistItemUpsertWithWhereUniqueWithoutMilestoneInput | ChecklistItemUpsertWithWhereUniqueWithoutMilestoneInput[]
    createMany?: ChecklistItemCreateManyMilestoneInputEnvelope
    set?: ChecklistItemWhereUniqueInput | ChecklistItemWhereUniqueInput[]
    disconnect?: ChecklistItemWhereUniqueInput | ChecklistItemWhereUniqueInput[]
    delete?: ChecklistItemWhereUniqueInput | ChecklistItemWhereUniqueInput[]
    connect?: ChecklistItemWhereUniqueInput | ChecklistItemWhereUniqueInput[]
    update?: ChecklistItemUpdateWithWhereUniqueWithoutMilestoneInput | ChecklistItemUpdateWithWhereUniqueWithoutMilestoneInput[]
    updateMany?: ChecklistItemUpdateManyWithWhereWithoutMilestoneInput | ChecklistItemUpdateManyWithWhereWithoutMilestoneInput[]
    deleteMany?: ChecklistItemScalarWhereInput | ChecklistItemScalarWhereInput[]
  }

  export type InspectionUncheckedUpdateManyWithoutMilestoneNestedInput = {
    create?: XOR<InspectionCreateWithoutMilestoneInput, InspectionUncheckedCreateWithoutMilestoneInput> | InspectionCreateWithoutMilestoneInput[] | InspectionUncheckedCreateWithoutMilestoneInput[]
    connectOrCreate?: InspectionCreateOrConnectWithoutMilestoneInput | InspectionCreateOrConnectWithoutMilestoneInput[]
    upsert?: InspectionUpsertWithWhereUniqueWithoutMilestoneInput | InspectionUpsertWithWhereUniqueWithoutMilestoneInput[]
    createMany?: InspectionCreateManyMilestoneInputEnvelope
    set?: InspectionWhereUniqueInput | InspectionWhereUniqueInput[]
    disconnect?: InspectionWhereUniqueInput | InspectionWhereUniqueInput[]
    delete?: InspectionWhereUniqueInput | InspectionWhereUniqueInput[]
    connect?: InspectionWhereUniqueInput | InspectionWhereUniqueInput[]
    update?: InspectionUpdateWithWhereUniqueWithoutMilestoneInput | InspectionUpdateWithWhereUniqueWithoutMilestoneInput[]
    updateMany?: InspectionUpdateManyWithWhereWithoutMilestoneInput | InspectionUpdateManyWithWhereWithoutMilestoneInput[]
    deleteMany?: InspectionScalarWhereInput | InspectionScalarWhereInput[]
  }

  export type MilestoneCreateNestedOneWithoutChecklistItemsInput = {
    create?: XOR<MilestoneCreateWithoutChecklistItemsInput, MilestoneUncheckedCreateWithoutChecklistItemsInput>
    connectOrCreate?: MilestoneCreateOrConnectWithoutChecklistItemsInput
    connect?: MilestoneWhereUniqueInput
  }

  export type InspectionResponseCreateNestedManyWithoutChecklistItemInput = {
    create?: XOR<InspectionResponseCreateWithoutChecklistItemInput, InspectionResponseUncheckedCreateWithoutChecklistItemInput> | InspectionResponseCreateWithoutChecklistItemInput[] | InspectionResponseUncheckedCreateWithoutChecklistItemInput[]
    connectOrCreate?: InspectionResponseCreateOrConnectWithoutChecklistItemInput | InspectionResponseCreateOrConnectWithoutChecklistItemInput[]
    createMany?: InspectionResponseCreateManyChecklistItemInputEnvelope
    connect?: InspectionResponseWhereUniqueInput | InspectionResponseWhereUniqueInput[]
  }

  export type InspectionResponseUncheckedCreateNestedManyWithoutChecklistItemInput = {
    create?: XOR<InspectionResponseCreateWithoutChecklistItemInput, InspectionResponseUncheckedCreateWithoutChecklistItemInput> | InspectionResponseCreateWithoutChecklistItemInput[] | InspectionResponseUncheckedCreateWithoutChecklistItemInput[]
    connectOrCreate?: InspectionResponseCreateOrConnectWithoutChecklistItemInput | InspectionResponseCreateOrConnectWithoutChecklistItemInput[]
    createMany?: InspectionResponseCreateManyChecklistItemInputEnvelope
    connect?: InspectionResponseWhereUniqueInput | InspectionResponseWhereUniqueInput[]
  }

  export type MilestoneUpdateOneRequiredWithoutChecklistItemsNestedInput = {
    create?: XOR<MilestoneCreateWithoutChecklistItemsInput, MilestoneUncheckedCreateWithoutChecklistItemsInput>
    connectOrCreate?: MilestoneCreateOrConnectWithoutChecklistItemsInput
    upsert?: MilestoneUpsertWithoutChecklistItemsInput
    connect?: MilestoneWhereUniqueInput
    update?: XOR<XOR<MilestoneUpdateToOneWithWhereWithoutChecklistItemsInput, MilestoneUpdateWithoutChecklistItemsInput>, MilestoneUncheckedUpdateWithoutChecklistItemsInput>
  }

  export type InspectionResponseUpdateManyWithoutChecklistItemNestedInput = {
    create?: XOR<InspectionResponseCreateWithoutChecklistItemInput, InspectionResponseUncheckedCreateWithoutChecklistItemInput> | InspectionResponseCreateWithoutChecklistItemInput[] | InspectionResponseUncheckedCreateWithoutChecklistItemInput[]
    connectOrCreate?: InspectionResponseCreateOrConnectWithoutChecklistItemInput | InspectionResponseCreateOrConnectWithoutChecklistItemInput[]
    upsert?: InspectionResponseUpsertWithWhereUniqueWithoutChecklistItemInput | InspectionResponseUpsertWithWhereUniqueWithoutChecklistItemInput[]
    createMany?: InspectionResponseCreateManyChecklistItemInputEnvelope
    set?: InspectionResponseWhereUniqueInput | InspectionResponseWhereUniqueInput[]
    disconnect?: InspectionResponseWhereUniqueInput | InspectionResponseWhereUniqueInput[]
    delete?: InspectionResponseWhereUniqueInput | InspectionResponseWhereUniqueInput[]
    connect?: InspectionResponseWhereUniqueInput | InspectionResponseWhereUniqueInput[]
    update?: InspectionResponseUpdateWithWhereUniqueWithoutChecklistItemInput | InspectionResponseUpdateWithWhereUniqueWithoutChecklistItemInput[]
    updateMany?: InspectionResponseUpdateManyWithWhereWithoutChecklistItemInput | InspectionResponseUpdateManyWithWhereWithoutChecklistItemInput[]
    deleteMany?: InspectionResponseScalarWhereInput | InspectionResponseScalarWhereInput[]
  }

  export type InspectionResponseUncheckedUpdateManyWithoutChecklistItemNestedInput = {
    create?: XOR<InspectionResponseCreateWithoutChecklistItemInput, InspectionResponseUncheckedCreateWithoutChecklistItemInput> | InspectionResponseCreateWithoutChecklistItemInput[] | InspectionResponseUncheckedCreateWithoutChecklistItemInput[]
    connectOrCreate?: InspectionResponseCreateOrConnectWithoutChecklistItemInput | InspectionResponseCreateOrConnectWithoutChecklistItemInput[]
    upsert?: InspectionResponseUpsertWithWhereUniqueWithoutChecklistItemInput | InspectionResponseUpsertWithWhereUniqueWithoutChecklistItemInput[]
    createMany?: InspectionResponseCreateManyChecklistItemInputEnvelope
    set?: InspectionResponseWhereUniqueInput | InspectionResponseWhereUniqueInput[]
    disconnect?: InspectionResponseWhereUniqueInput | InspectionResponseWhereUniqueInput[]
    delete?: InspectionResponseWhereUniqueInput | InspectionResponseWhereUniqueInput[]
    connect?: InspectionResponseWhereUniqueInput | InspectionResponseWhereUniqueInput[]
    update?: InspectionResponseUpdateWithWhereUniqueWithoutChecklistItemInput | InspectionResponseUpdateWithWhereUniqueWithoutChecklistItemInput[]
    updateMany?: InspectionResponseUpdateManyWithWhereWithoutChecklistItemInput | InspectionResponseUpdateManyWithWhereWithoutChecklistItemInput[]
    deleteMany?: InspectionResponseScalarWhereInput | InspectionResponseScalarWhereInput[]
  }

  export type ProjectCreateNestedOneWithoutInspectionsInput = {
    create?: XOR<ProjectCreateWithoutInspectionsInput, ProjectUncheckedCreateWithoutInspectionsInput>
    connectOrCreate?: ProjectCreateOrConnectWithoutInspectionsInput
    connect?: ProjectWhereUniqueInput
  }

  export type MilestoneCreateNestedOneWithoutInspectionsInput = {
    create?: XOR<MilestoneCreateWithoutInspectionsInput, MilestoneUncheckedCreateWithoutInspectionsInput>
    connectOrCreate?: MilestoneCreateOrConnectWithoutInspectionsInput
    connect?: MilestoneWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutInspectionsInput = {
    create?: XOR<UserCreateWithoutInspectionsInput, UserUncheckedCreateWithoutInspectionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutInspectionsInput
    connect?: UserWhereUniqueInput
  }

  export type InspectionResponseCreateNestedManyWithoutInspectionInput = {
    create?: XOR<InspectionResponseCreateWithoutInspectionInput, InspectionResponseUncheckedCreateWithoutInspectionInput> | InspectionResponseCreateWithoutInspectionInput[] | InspectionResponseUncheckedCreateWithoutInspectionInput[]
    connectOrCreate?: InspectionResponseCreateOrConnectWithoutInspectionInput | InspectionResponseCreateOrConnectWithoutInspectionInput[]
    createMany?: InspectionResponseCreateManyInspectionInputEnvelope
    connect?: InspectionResponseWhereUniqueInput | InspectionResponseWhereUniqueInput[]
  }

  export type UserCreateNestedOneWithoutReviewedInspectionsInput = {
    create?: XOR<UserCreateWithoutReviewedInspectionsInput, UserUncheckedCreateWithoutReviewedInspectionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutReviewedInspectionsInput
    connect?: UserWhereUniqueInput
  }

  export type InspectionResponseUncheckedCreateNestedManyWithoutInspectionInput = {
    create?: XOR<InspectionResponseCreateWithoutInspectionInput, InspectionResponseUncheckedCreateWithoutInspectionInput> | InspectionResponseCreateWithoutInspectionInput[] | InspectionResponseUncheckedCreateWithoutInspectionInput[]
    connectOrCreate?: InspectionResponseCreateOrConnectWithoutInspectionInput | InspectionResponseCreateOrConnectWithoutInspectionInput[]
    createMany?: InspectionResponseCreateManyInspectionInputEnvelope
    connect?: InspectionResponseWhereUniqueInput | InspectionResponseWhereUniqueInput[]
  }

  export type EnumInspectionStatusFieldUpdateOperationsInput = {
    set?: $Enums.InspectionStatus
  }

  export type ProjectUpdateOneRequiredWithoutInspectionsNestedInput = {
    create?: XOR<ProjectCreateWithoutInspectionsInput, ProjectUncheckedCreateWithoutInspectionsInput>
    connectOrCreate?: ProjectCreateOrConnectWithoutInspectionsInput
    upsert?: ProjectUpsertWithoutInspectionsInput
    connect?: ProjectWhereUniqueInput
    update?: XOR<XOR<ProjectUpdateToOneWithWhereWithoutInspectionsInput, ProjectUpdateWithoutInspectionsInput>, ProjectUncheckedUpdateWithoutInspectionsInput>
  }

  export type MilestoneUpdateOneRequiredWithoutInspectionsNestedInput = {
    create?: XOR<MilestoneCreateWithoutInspectionsInput, MilestoneUncheckedCreateWithoutInspectionsInput>
    connectOrCreate?: MilestoneCreateOrConnectWithoutInspectionsInput
    upsert?: MilestoneUpsertWithoutInspectionsInput
    connect?: MilestoneWhereUniqueInput
    update?: XOR<XOR<MilestoneUpdateToOneWithWhereWithoutInspectionsInput, MilestoneUpdateWithoutInspectionsInput>, MilestoneUncheckedUpdateWithoutInspectionsInput>
  }

  export type UserUpdateOneRequiredWithoutInspectionsNestedInput = {
    create?: XOR<UserCreateWithoutInspectionsInput, UserUncheckedCreateWithoutInspectionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutInspectionsInput
    upsert?: UserUpsertWithoutInspectionsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutInspectionsInput, UserUpdateWithoutInspectionsInput>, UserUncheckedUpdateWithoutInspectionsInput>
  }

  export type InspectionResponseUpdateManyWithoutInspectionNestedInput = {
    create?: XOR<InspectionResponseCreateWithoutInspectionInput, InspectionResponseUncheckedCreateWithoutInspectionInput> | InspectionResponseCreateWithoutInspectionInput[] | InspectionResponseUncheckedCreateWithoutInspectionInput[]
    connectOrCreate?: InspectionResponseCreateOrConnectWithoutInspectionInput | InspectionResponseCreateOrConnectWithoutInspectionInput[]
    upsert?: InspectionResponseUpsertWithWhereUniqueWithoutInspectionInput | InspectionResponseUpsertWithWhereUniqueWithoutInspectionInput[]
    createMany?: InspectionResponseCreateManyInspectionInputEnvelope
    set?: InspectionResponseWhereUniqueInput | InspectionResponseWhereUniqueInput[]
    disconnect?: InspectionResponseWhereUniqueInput | InspectionResponseWhereUniqueInput[]
    delete?: InspectionResponseWhereUniqueInput | InspectionResponseWhereUniqueInput[]
    connect?: InspectionResponseWhereUniqueInput | InspectionResponseWhereUniqueInput[]
    update?: InspectionResponseUpdateWithWhereUniqueWithoutInspectionInput | InspectionResponseUpdateWithWhereUniqueWithoutInspectionInput[]
    updateMany?: InspectionResponseUpdateManyWithWhereWithoutInspectionInput | InspectionResponseUpdateManyWithWhereWithoutInspectionInput[]
    deleteMany?: InspectionResponseScalarWhereInput | InspectionResponseScalarWhereInput[]
  }

  export type UserUpdateOneWithoutReviewedInspectionsNestedInput = {
    create?: XOR<UserCreateWithoutReviewedInspectionsInput, UserUncheckedCreateWithoutReviewedInspectionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutReviewedInspectionsInput
    upsert?: UserUpsertWithoutReviewedInspectionsInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutReviewedInspectionsInput, UserUpdateWithoutReviewedInspectionsInput>, UserUncheckedUpdateWithoutReviewedInspectionsInput>
  }

  export type InspectionResponseUncheckedUpdateManyWithoutInspectionNestedInput = {
    create?: XOR<InspectionResponseCreateWithoutInspectionInput, InspectionResponseUncheckedCreateWithoutInspectionInput> | InspectionResponseCreateWithoutInspectionInput[] | InspectionResponseUncheckedCreateWithoutInspectionInput[]
    connectOrCreate?: InspectionResponseCreateOrConnectWithoutInspectionInput | InspectionResponseCreateOrConnectWithoutInspectionInput[]
    upsert?: InspectionResponseUpsertWithWhereUniqueWithoutInspectionInput | InspectionResponseUpsertWithWhereUniqueWithoutInspectionInput[]
    createMany?: InspectionResponseCreateManyInspectionInputEnvelope
    set?: InspectionResponseWhereUniqueInput | InspectionResponseWhereUniqueInput[]
    disconnect?: InspectionResponseWhereUniqueInput | InspectionResponseWhereUniqueInput[]
    delete?: InspectionResponseWhereUniqueInput | InspectionResponseWhereUniqueInput[]
    connect?: InspectionResponseWhereUniqueInput | InspectionResponseWhereUniqueInput[]
    update?: InspectionResponseUpdateWithWhereUniqueWithoutInspectionInput | InspectionResponseUpdateWithWhereUniqueWithoutInspectionInput[]
    updateMany?: InspectionResponseUpdateManyWithWhereWithoutInspectionInput | InspectionResponseUpdateManyWithWhereWithoutInspectionInput[]
    deleteMany?: InspectionResponseScalarWhereInput | InspectionResponseScalarWhereInput[]
  }

  export type InspectionCreateNestedOneWithoutResponsesInput = {
    create?: XOR<InspectionCreateWithoutResponsesInput, InspectionUncheckedCreateWithoutResponsesInput>
    connectOrCreate?: InspectionCreateOrConnectWithoutResponsesInput
    connect?: InspectionWhereUniqueInput
  }

  export type ChecklistItemCreateNestedOneWithoutResponsesInput = {
    create?: XOR<ChecklistItemCreateWithoutResponsesInput, ChecklistItemUncheckedCreateWithoutResponsesInput>
    connectOrCreate?: ChecklistItemCreateOrConnectWithoutResponsesInput
    connect?: ChecklistItemWhereUniqueInput
  }

  export type MediaCreateNestedOneWithoutInspectionResponsesInput = {
    create?: XOR<MediaCreateWithoutInspectionResponsesInput, MediaUncheckedCreateWithoutInspectionResponsesInput>
    connectOrCreate?: MediaCreateOrConnectWithoutInspectionResponsesInput
    connect?: MediaWhereUniqueInput
  }

  export type EnumChecklistResultFieldUpdateOperationsInput = {
    set?: $Enums.ChecklistResult
  }

  export type InspectionUpdateOneRequiredWithoutResponsesNestedInput = {
    create?: XOR<InspectionCreateWithoutResponsesInput, InspectionUncheckedCreateWithoutResponsesInput>
    connectOrCreate?: InspectionCreateOrConnectWithoutResponsesInput
    upsert?: InspectionUpsertWithoutResponsesInput
    connect?: InspectionWhereUniqueInput
    update?: XOR<XOR<InspectionUpdateToOneWithWhereWithoutResponsesInput, InspectionUpdateWithoutResponsesInput>, InspectionUncheckedUpdateWithoutResponsesInput>
  }

  export type ChecklistItemUpdateOneRequiredWithoutResponsesNestedInput = {
    create?: XOR<ChecklistItemCreateWithoutResponsesInput, ChecklistItemUncheckedCreateWithoutResponsesInput>
    connectOrCreate?: ChecklistItemCreateOrConnectWithoutResponsesInput
    upsert?: ChecklistItemUpsertWithoutResponsesInput
    connect?: ChecklistItemWhereUniqueInput
    update?: XOR<XOR<ChecklistItemUpdateToOneWithWhereWithoutResponsesInput, ChecklistItemUpdateWithoutResponsesInput>, ChecklistItemUncheckedUpdateWithoutResponsesInput>
  }

  export type MediaUpdateOneWithoutInspectionResponsesNestedInput = {
    create?: XOR<MediaCreateWithoutInspectionResponsesInput, MediaUncheckedCreateWithoutInspectionResponsesInput>
    connectOrCreate?: MediaCreateOrConnectWithoutInspectionResponsesInput
    upsert?: MediaUpsertWithoutInspectionResponsesInput
    disconnect?: MediaWhereInput | boolean
    delete?: MediaWhereInput | boolean
    connect?: MediaWhereUniqueInput
    update?: XOR<XOR<MediaUpdateToOneWithWhereWithoutInspectionResponsesInput, MediaUpdateWithoutInspectionResponsesInput>, MediaUncheckedUpdateWithoutInspectionResponsesInput>
  }

  export type ProjectCreateNestedOneWithoutQueriesInput = {
    create?: XOR<ProjectCreateWithoutQueriesInput, ProjectUncheckedCreateWithoutQueriesInput>
    connectOrCreate?: ProjectCreateOrConnectWithoutQueriesInput
    connect?: ProjectWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutQueriesInput = {
    create?: XOR<UserCreateWithoutQueriesInput, UserUncheckedCreateWithoutQueriesInput>
    connectOrCreate?: UserCreateOrConnectWithoutQueriesInput
    connect?: UserWhereUniqueInput
  }

  export type MediaCreateNestedManyWithoutQueryInput = {
    create?: XOR<MediaCreateWithoutQueryInput, MediaUncheckedCreateWithoutQueryInput> | MediaCreateWithoutQueryInput[] | MediaUncheckedCreateWithoutQueryInput[]
    connectOrCreate?: MediaCreateOrConnectWithoutQueryInput | MediaCreateOrConnectWithoutQueryInput[]
    createMany?: MediaCreateManyQueryInputEnvelope
    connect?: MediaWhereUniqueInput | MediaWhereUniqueInput[]
  }

  export type QueryResponseCreateNestedManyWithoutQueryInput = {
    create?: XOR<QueryResponseCreateWithoutQueryInput, QueryResponseUncheckedCreateWithoutQueryInput> | QueryResponseCreateWithoutQueryInput[] | QueryResponseUncheckedCreateWithoutQueryInput[]
    connectOrCreate?: QueryResponseCreateOrConnectWithoutQueryInput | QueryResponseCreateOrConnectWithoutQueryInput[]
    createMany?: QueryResponseCreateManyQueryInputEnvelope
    connect?: QueryResponseWhereUniqueInput | QueryResponseWhereUniqueInput[]
  }

  export type MediaUncheckedCreateNestedManyWithoutQueryInput = {
    create?: XOR<MediaCreateWithoutQueryInput, MediaUncheckedCreateWithoutQueryInput> | MediaCreateWithoutQueryInput[] | MediaUncheckedCreateWithoutQueryInput[]
    connectOrCreate?: MediaCreateOrConnectWithoutQueryInput | MediaCreateOrConnectWithoutQueryInput[]
    createMany?: MediaCreateManyQueryInputEnvelope
    connect?: MediaWhereUniqueInput | MediaWhereUniqueInput[]
  }

  export type QueryResponseUncheckedCreateNestedManyWithoutQueryInput = {
    create?: XOR<QueryResponseCreateWithoutQueryInput, QueryResponseUncheckedCreateWithoutQueryInput> | QueryResponseCreateWithoutQueryInput[] | QueryResponseUncheckedCreateWithoutQueryInput[]
    connectOrCreate?: QueryResponseCreateOrConnectWithoutQueryInput | QueryResponseCreateOrConnectWithoutQueryInput[]
    createMany?: QueryResponseCreateManyQueryInputEnvelope
    connect?: QueryResponseWhereUniqueInput | QueryResponseWhereUniqueInput[]
  }

  export type EnumQueryStatusFieldUpdateOperationsInput = {
    set?: $Enums.QueryStatus
  }

  export type EnumQueryPriorityFieldUpdateOperationsInput = {
    set?: $Enums.QueryPriority
  }

  export type ProjectUpdateOneRequiredWithoutQueriesNestedInput = {
    create?: XOR<ProjectCreateWithoutQueriesInput, ProjectUncheckedCreateWithoutQueriesInput>
    connectOrCreate?: ProjectCreateOrConnectWithoutQueriesInput
    upsert?: ProjectUpsertWithoutQueriesInput
    connect?: ProjectWhereUniqueInput
    update?: XOR<XOR<ProjectUpdateToOneWithWhereWithoutQueriesInput, ProjectUpdateWithoutQueriesInput>, ProjectUncheckedUpdateWithoutQueriesInput>
  }

  export type UserUpdateOneRequiredWithoutQueriesNestedInput = {
    create?: XOR<UserCreateWithoutQueriesInput, UserUncheckedCreateWithoutQueriesInput>
    connectOrCreate?: UserCreateOrConnectWithoutQueriesInput
    upsert?: UserUpsertWithoutQueriesInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutQueriesInput, UserUpdateWithoutQueriesInput>, UserUncheckedUpdateWithoutQueriesInput>
  }

  export type MediaUpdateManyWithoutQueryNestedInput = {
    create?: XOR<MediaCreateWithoutQueryInput, MediaUncheckedCreateWithoutQueryInput> | MediaCreateWithoutQueryInput[] | MediaUncheckedCreateWithoutQueryInput[]
    connectOrCreate?: MediaCreateOrConnectWithoutQueryInput | MediaCreateOrConnectWithoutQueryInput[]
    upsert?: MediaUpsertWithWhereUniqueWithoutQueryInput | MediaUpsertWithWhereUniqueWithoutQueryInput[]
    createMany?: MediaCreateManyQueryInputEnvelope
    set?: MediaWhereUniqueInput | MediaWhereUniqueInput[]
    disconnect?: MediaWhereUniqueInput | MediaWhereUniqueInput[]
    delete?: MediaWhereUniqueInput | MediaWhereUniqueInput[]
    connect?: MediaWhereUniqueInput | MediaWhereUniqueInput[]
    update?: MediaUpdateWithWhereUniqueWithoutQueryInput | MediaUpdateWithWhereUniqueWithoutQueryInput[]
    updateMany?: MediaUpdateManyWithWhereWithoutQueryInput | MediaUpdateManyWithWhereWithoutQueryInput[]
    deleteMany?: MediaScalarWhereInput | MediaScalarWhereInput[]
  }

  export type QueryResponseUpdateManyWithoutQueryNestedInput = {
    create?: XOR<QueryResponseCreateWithoutQueryInput, QueryResponseUncheckedCreateWithoutQueryInput> | QueryResponseCreateWithoutQueryInput[] | QueryResponseUncheckedCreateWithoutQueryInput[]
    connectOrCreate?: QueryResponseCreateOrConnectWithoutQueryInput | QueryResponseCreateOrConnectWithoutQueryInput[]
    upsert?: QueryResponseUpsertWithWhereUniqueWithoutQueryInput | QueryResponseUpsertWithWhereUniqueWithoutQueryInput[]
    createMany?: QueryResponseCreateManyQueryInputEnvelope
    set?: QueryResponseWhereUniqueInput | QueryResponseWhereUniqueInput[]
    disconnect?: QueryResponseWhereUniqueInput | QueryResponseWhereUniqueInput[]
    delete?: QueryResponseWhereUniqueInput | QueryResponseWhereUniqueInput[]
    connect?: QueryResponseWhereUniqueInput | QueryResponseWhereUniqueInput[]
    update?: QueryResponseUpdateWithWhereUniqueWithoutQueryInput | QueryResponseUpdateWithWhereUniqueWithoutQueryInput[]
    updateMany?: QueryResponseUpdateManyWithWhereWithoutQueryInput | QueryResponseUpdateManyWithWhereWithoutQueryInput[]
    deleteMany?: QueryResponseScalarWhereInput | QueryResponseScalarWhereInput[]
  }

  export type MediaUncheckedUpdateManyWithoutQueryNestedInput = {
    create?: XOR<MediaCreateWithoutQueryInput, MediaUncheckedCreateWithoutQueryInput> | MediaCreateWithoutQueryInput[] | MediaUncheckedCreateWithoutQueryInput[]
    connectOrCreate?: MediaCreateOrConnectWithoutQueryInput | MediaCreateOrConnectWithoutQueryInput[]
    upsert?: MediaUpsertWithWhereUniqueWithoutQueryInput | MediaUpsertWithWhereUniqueWithoutQueryInput[]
    createMany?: MediaCreateManyQueryInputEnvelope
    set?: MediaWhereUniqueInput | MediaWhereUniqueInput[]
    disconnect?: MediaWhereUniqueInput | MediaWhereUniqueInput[]
    delete?: MediaWhereUniqueInput | MediaWhereUniqueInput[]
    connect?: MediaWhereUniqueInput | MediaWhereUniqueInput[]
    update?: MediaUpdateWithWhereUniqueWithoutQueryInput | MediaUpdateWithWhereUniqueWithoutQueryInput[]
    updateMany?: MediaUpdateManyWithWhereWithoutQueryInput | MediaUpdateManyWithWhereWithoutQueryInput[]
    deleteMany?: MediaScalarWhereInput | MediaScalarWhereInput[]
  }

  export type QueryResponseUncheckedUpdateManyWithoutQueryNestedInput = {
    create?: XOR<QueryResponseCreateWithoutQueryInput, QueryResponseUncheckedCreateWithoutQueryInput> | QueryResponseCreateWithoutQueryInput[] | QueryResponseUncheckedCreateWithoutQueryInput[]
    connectOrCreate?: QueryResponseCreateOrConnectWithoutQueryInput | QueryResponseCreateOrConnectWithoutQueryInput[]
    upsert?: QueryResponseUpsertWithWhereUniqueWithoutQueryInput | QueryResponseUpsertWithWhereUniqueWithoutQueryInput[]
    createMany?: QueryResponseCreateManyQueryInputEnvelope
    set?: QueryResponseWhereUniqueInput | QueryResponseWhereUniqueInput[]
    disconnect?: QueryResponseWhereUniqueInput | QueryResponseWhereUniqueInput[]
    delete?: QueryResponseWhereUniqueInput | QueryResponseWhereUniqueInput[]
    connect?: QueryResponseWhereUniqueInput | QueryResponseWhereUniqueInput[]
    update?: QueryResponseUpdateWithWhereUniqueWithoutQueryInput | QueryResponseUpdateWithWhereUniqueWithoutQueryInput[]
    updateMany?: QueryResponseUpdateManyWithWhereWithoutQueryInput | QueryResponseUpdateManyWithWhereWithoutQueryInput[]
    deleteMany?: QueryResponseScalarWhereInput | QueryResponseScalarWhereInput[]
  }

  export type QueryCreateNestedOneWithoutResponsesInput = {
    create?: XOR<QueryCreateWithoutResponsesInput, QueryUncheckedCreateWithoutResponsesInput>
    connectOrCreate?: QueryCreateOrConnectWithoutResponsesInput
    connect?: QueryWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutQueryResponsesInput = {
    create?: XOR<UserCreateWithoutQueryResponsesInput, UserUncheckedCreateWithoutQueryResponsesInput>
    connectOrCreate?: UserCreateOrConnectWithoutQueryResponsesInput
    connect?: UserWhereUniqueInput
  }

  export type QueryUpdateOneRequiredWithoutResponsesNestedInput = {
    create?: XOR<QueryCreateWithoutResponsesInput, QueryUncheckedCreateWithoutResponsesInput>
    connectOrCreate?: QueryCreateOrConnectWithoutResponsesInput
    upsert?: QueryUpsertWithoutResponsesInput
    connect?: QueryWhereUniqueInput
    update?: XOR<XOR<QueryUpdateToOneWithWhereWithoutResponsesInput, QueryUpdateWithoutResponsesInput>, QueryUncheckedUpdateWithoutResponsesInput>
  }

  export type UserUpdateOneRequiredWithoutQueryResponsesNestedInput = {
    create?: XOR<UserCreateWithoutQueryResponsesInput, UserUncheckedCreateWithoutQueryResponsesInput>
    connectOrCreate?: UserCreateOrConnectWithoutQueryResponsesInput
    upsert?: UserUpsertWithoutQueryResponsesInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutQueryResponsesInput, UserUpdateWithoutQueryResponsesInput>, UserUncheckedUpdateWithoutQueryResponsesInput>
  }

  export type UserCreateNestedOneWithoutAuditLogsInput = {
    create?: XOR<UserCreateWithoutAuditLogsInput, UserUncheckedCreateWithoutAuditLogsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAuditLogsInput
    connect?: UserWhereUniqueInput
  }

  export type ProjectCreateNestedOneWithoutAuditLogsInput = {
    create?: XOR<ProjectCreateWithoutAuditLogsInput, ProjectUncheckedCreateWithoutAuditLogsInput>
    connectOrCreate?: ProjectCreateOrConnectWithoutAuditLogsInput
    connect?: ProjectWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutAuditLogsNestedInput = {
    create?: XOR<UserCreateWithoutAuditLogsInput, UserUncheckedCreateWithoutAuditLogsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAuditLogsInput
    upsert?: UserUpsertWithoutAuditLogsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutAuditLogsInput, UserUpdateWithoutAuditLogsInput>, UserUncheckedUpdateWithoutAuditLogsInput>
  }

  export type ProjectUpdateOneWithoutAuditLogsNestedInput = {
    create?: XOR<ProjectCreateWithoutAuditLogsInput, ProjectUncheckedCreateWithoutAuditLogsInput>
    connectOrCreate?: ProjectCreateOrConnectWithoutAuditLogsInput
    upsert?: ProjectUpsertWithoutAuditLogsInput
    disconnect?: ProjectWhereInput | boolean
    delete?: ProjectWhereInput | boolean
    connect?: ProjectWhereUniqueInput
    update?: XOR<XOR<ProjectUpdateToOneWithWhereWithoutAuditLogsInput, ProjectUpdateWithoutAuditLogsInput>, ProjectUncheckedUpdateWithoutAuditLogsInput>
  }

  export type ProjectCreateNestedOneWithoutMaterialsInput = {
    create?: XOR<ProjectCreateWithoutMaterialsInput, ProjectUncheckedCreateWithoutMaterialsInput>
    connectOrCreate?: ProjectCreateOrConnectWithoutMaterialsInput
    connect?: ProjectWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutMaterialsCreatedInput = {
    create?: XOR<UserCreateWithoutMaterialsCreatedInput, UserUncheckedCreateWithoutMaterialsCreatedInput>
    connectOrCreate?: UserCreateOrConnectWithoutMaterialsCreatedInput
    connect?: UserWhereUniqueInput
  }

  export type FloatFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type EnumMaterialStatusFieldUpdateOperationsInput = {
    set?: $Enums.MaterialStatus
  }

  export type ProjectUpdateOneRequiredWithoutMaterialsNestedInput = {
    create?: XOR<ProjectCreateWithoutMaterialsInput, ProjectUncheckedCreateWithoutMaterialsInput>
    connectOrCreate?: ProjectCreateOrConnectWithoutMaterialsInput
    upsert?: ProjectUpsertWithoutMaterialsInput
    connect?: ProjectWhereUniqueInput
    update?: XOR<XOR<ProjectUpdateToOneWithWhereWithoutMaterialsInput, ProjectUpdateWithoutMaterialsInput>, ProjectUncheckedUpdateWithoutMaterialsInput>
  }

  export type UserUpdateOneRequiredWithoutMaterialsCreatedNestedInput = {
    create?: XOR<UserCreateWithoutMaterialsCreatedInput, UserUncheckedCreateWithoutMaterialsCreatedInput>
    connectOrCreate?: UserCreateOrConnectWithoutMaterialsCreatedInput
    upsert?: UserUpsertWithoutMaterialsCreatedInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutMaterialsCreatedInput, UserUpdateWithoutMaterialsCreatedInput>, UserUncheckedUpdateWithoutMaterialsCreatedInput>
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedEnumRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.Role | EnumRoleFieldRefInput<$PrismaModel>
    in?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumRoleFilter<$PrismaModel> | $Enums.Role
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedEnumRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Role | EnumRoleFieldRefInput<$PrismaModel>
    in?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumRoleWithAggregatesFilter<$PrismaModel> | $Enums.Role
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumRoleFilter<$PrismaModel>
    _max?: NestedEnumRoleFilter<$PrismaModel>
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedEnumProjectStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.ProjectStatus | EnumProjectStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ProjectStatus[] | ListEnumProjectStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ProjectStatus[] | ListEnumProjectStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumProjectStatusFilter<$PrismaModel> | $Enums.ProjectStatus
  }

  export type NestedEnumProjectStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ProjectStatus | EnumProjectStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ProjectStatus[] | ListEnumProjectStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ProjectStatus[] | ListEnumProjectStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumProjectStatusWithAggregatesFilter<$PrismaModel> | $Enums.ProjectStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumProjectStatusFilter<$PrismaModel>
    _max?: NestedEnumProjectStatusFilter<$PrismaModel>
  }

  export type NestedEnumProjectMemberRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.ProjectMemberRole | EnumProjectMemberRoleFieldRefInput<$PrismaModel>
    in?: $Enums.ProjectMemberRole[] | ListEnumProjectMemberRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.ProjectMemberRole[] | ListEnumProjectMemberRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumProjectMemberRoleFilter<$PrismaModel> | $Enums.ProjectMemberRole
  }

  export type NestedEnumProjectMemberRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ProjectMemberRole | EnumProjectMemberRoleFieldRefInput<$PrismaModel>
    in?: $Enums.ProjectMemberRole[] | ListEnumProjectMemberRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.ProjectMemberRole[] | ListEnumProjectMemberRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumProjectMemberRoleWithAggregatesFilter<$PrismaModel> | $Enums.ProjectMemberRole
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumProjectMemberRoleFilter<$PrismaModel>
    _max?: NestedEnumProjectMemberRoleFilter<$PrismaModel>
  }

  export type NestedEnumMediaTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.MediaType | EnumMediaTypeFieldRefInput<$PrismaModel>
    in?: $Enums.MediaType[] | ListEnumMediaTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.MediaType[] | ListEnumMediaTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumMediaTypeFilter<$PrismaModel> | $Enums.MediaType
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedEnumMediaTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.MediaType | EnumMediaTypeFieldRefInput<$PrismaModel>
    in?: $Enums.MediaType[] | ListEnumMediaTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.MediaType[] | ListEnumMediaTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumMediaTypeWithAggregatesFilter<$PrismaModel> | $Enums.MediaType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumMediaTypeFilter<$PrismaModel>
    _max?: NestedEnumMediaTypeFilter<$PrismaModel>
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedDecimalFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
  }

  export type NestedEnumPaymentStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentStatus | EnumPaymentStatusFieldRefInput<$PrismaModel>
    in?: $Enums.PaymentStatus[] | ListEnumPaymentStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.PaymentStatus[] | ListEnumPaymentStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumPaymentStatusFilter<$PrismaModel> | $Enums.PaymentStatus
  }

  export type NestedEnumPaymentCategoryNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentCategory | EnumPaymentCategoryFieldRefInput<$PrismaModel> | null
    in?: $Enums.PaymentCategory[] | ListEnumPaymentCategoryFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.PaymentCategory[] | ListEnumPaymentCategoryFieldRefInput<$PrismaModel> | null
    not?: NestedEnumPaymentCategoryNullableFilter<$PrismaModel> | $Enums.PaymentCategory | null
  }

  export type NestedDecimalWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedDecimalFilter<$PrismaModel>
    _sum?: NestedDecimalFilter<$PrismaModel>
    _min?: NestedDecimalFilter<$PrismaModel>
    _max?: NestedDecimalFilter<$PrismaModel>
  }

  export type NestedEnumPaymentStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentStatus | EnumPaymentStatusFieldRefInput<$PrismaModel>
    in?: $Enums.PaymentStatus[] | ListEnumPaymentStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.PaymentStatus[] | ListEnumPaymentStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumPaymentStatusWithAggregatesFilter<$PrismaModel> | $Enums.PaymentStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPaymentStatusFilter<$PrismaModel>
    _max?: NestedEnumPaymentStatusFilter<$PrismaModel>
  }

  export type NestedEnumPaymentCategoryNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentCategory | EnumPaymentCategoryFieldRefInput<$PrismaModel> | null
    in?: $Enums.PaymentCategory[] | ListEnumPaymentCategoryFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.PaymentCategory[] | ListEnumPaymentCategoryFieldRefInput<$PrismaModel> | null
    not?: NestedEnumPaymentCategoryNullableWithAggregatesFilter<$PrismaModel> | $Enums.PaymentCategory | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumPaymentCategoryNullableFilter<$PrismaModel>
    _max?: NestedEnumPaymentCategoryNullableFilter<$PrismaModel>
  }

  export type NestedEnumNotificationPriorityFilter<$PrismaModel = never> = {
    equals?: $Enums.NotificationPriority | EnumNotificationPriorityFieldRefInput<$PrismaModel>
    in?: $Enums.NotificationPriority[] | ListEnumNotificationPriorityFieldRefInput<$PrismaModel>
    notIn?: $Enums.NotificationPriority[] | ListEnumNotificationPriorityFieldRefInput<$PrismaModel>
    not?: NestedEnumNotificationPriorityFilter<$PrismaModel> | $Enums.NotificationPriority
  }

  export type NestedEnumNotificationPriorityWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.NotificationPriority | EnumNotificationPriorityFieldRefInput<$PrismaModel>
    in?: $Enums.NotificationPriority[] | ListEnumNotificationPriorityFieldRefInput<$PrismaModel>
    notIn?: $Enums.NotificationPriority[] | ListEnumNotificationPriorityFieldRefInput<$PrismaModel>
    not?: NestedEnumNotificationPriorityWithAggregatesFilter<$PrismaModel> | $Enums.NotificationPriority
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumNotificationPriorityFilter<$PrismaModel>
    _max?: NestedEnumNotificationPriorityFilter<$PrismaModel>
  }

  export type NestedEnumInspectionStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.InspectionStatus | EnumInspectionStatusFieldRefInput<$PrismaModel>
    in?: $Enums.InspectionStatus[] | ListEnumInspectionStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.InspectionStatus[] | ListEnumInspectionStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumInspectionStatusFilter<$PrismaModel> | $Enums.InspectionStatus
  }

  export type NestedEnumInspectionStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.InspectionStatus | EnumInspectionStatusFieldRefInput<$PrismaModel>
    in?: $Enums.InspectionStatus[] | ListEnumInspectionStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.InspectionStatus[] | ListEnumInspectionStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumInspectionStatusWithAggregatesFilter<$PrismaModel> | $Enums.InspectionStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumInspectionStatusFilter<$PrismaModel>
    _max?: NestedEnumInspectionStatusFilter<$PrismaModel>
  }

  export type NestedEnumChecklistResultFilter<$PrismaModel = never> = {
    equals?: $Enums.ChecklistResult | EnumChecklistResultFieldRefInput<$PrismaModel>
    in?: $Enums.ChecklistResult[] | ListEnumChecklistResultFieldRefInput<$PrismaModel>
    notIn?: $Enums.ChecklistResult[] | ListEnumChecklistResultFieldRefInput<$PrismaModel>
    not?: NestedEnumChecklistResultFilter<$PrismaModel> | $Enums.ChecklistResult
  }

  export type NestedEnumChecklistResultWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ChecklistResult | EnumChecklistResultFieldRefInput<$PrismaModel>
    in?: $Enums.ChecklistResult[] | ListEnumChecklistResultFieldRefInput<$PrismaModel>
    notIn?: $Enums.ChecklistResult[] | ListEnumChecklistResultFieldRefInput<$PrismaModel>
    not?: NestedEnumChecklistResultWithAggregatesFilter<$PrismaModel> | $Enums.ChecklistResult
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumChecklistResultFilter<$PrismaModel>
    _max?: NestedEnumChecklistResultFilter<$PrismaModel>
  }

  export type NestedEnumQueryStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.QueryStatus | EnumQueryStatusFieldRefInput<$PrismaModel>
    in?: $Enums.QueryStatus[] | ListEnumQueryStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.QueryStatus[] | ListEnumQueryStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumQueryStatusFilter<$PrismaModel> | $Enums.QueryStatus
  }

  export type NestedEnumQueryPriorityFilter<$PrismaModel = never> = {
    equals?: $Enums.QueryPriority | EnumQueryPriorityFieldRefInput<$PrismaModel>
    in?: $Enums.QueryPriority[] | ListEnumQueryPriorityFieldRefInput<$PrismaModel>
    notIn?: $Enums.QueryPriority[] | ListEnumQueryPriorityFieldRefInput<$PrismaModel>
    not?: NestedEnumQueryPriorityFilter<$PrismaModel> | $Enums.QueryPriority
  }

  export type NestedEnumQueryStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.QueryStatus | EnumQueryStatusFieldRefInput<$PrismaModel>
    in?: $Enums.QueryStatus[] | ListEnumQueryStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.QueryStatus[] | ListEnumQueryStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumQueryStatusWithAggregatesFilter<$PrismaModel> | $Enums.QueryStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumQueryStatusFilter<$PrismaModel>
    _max?: NestedEnumQueryStatusFilter<$PrismaModel>
  }

  export type NestedEnumQueryPriorityWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.QueryPriority | EnumQueryPriorityFieldRefInput<$PrismaModel>
    in?: $Enums.QueryPriority[] | ListEnumQueryPriorityFieldRefInput<$PrismaModel>
    notIn?: $Enums.QueryPriority[] | ListEnumQueryPriorityFieldRefInput<$PrismaModel>
    not?: NestedEnumQueryPriorityWithAggregatesFilter<$PrismaModel> | $Enums.QueryPriority
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumQueryPriorityFilter<$PrismaModel>
    _max?: NestedEnumQueryPriorityFilter<$PrismaModel>
  }
  export type NestedJsonNullableFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<NestedJsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type NestedEnumMaterialStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.MaterialStatus | EnumMaterialStatusFieldRefInput<$PrismaModel>
    in?: $Enums.MaterialStatus[] | ListEnumMaterialStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.MaterialStatus[] | ListEnumMaterialStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumMaterialStatusFilter<$PrismaModel> | $Enums.MaterialStatus
  }

  export type NestedFloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type NestedEnumMaterialStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.MaterialStatus | EnumMaterialStatusFieldRefInput<$PrismaModel>
    in?: $Enums.MaterialStatus[] | ListEnumMaterialStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.MaterialStatus[] | ListEnumMaterialStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumMaterialStatusWithAggregatesFilter<$PrismaModel> | $Enums.MaterialStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumMaterialStatusFilter<$PrismaModel>
    _max?: NestedEnumMaterialStatusFilter<$PrismaModel>
  }

  export type UserCreateWithoutCreatedUsersInput = {
    id?: string
    name: string
    email: string
    passwordHash: string
    role: $Enums.Role
    isActive?: boolean
    createdAt?: Date | string
    phone?: string | null
    designation?: string | null
    createdBy?: UserCreateNestedOneWithoutCreatedUsersInput
    managedProjects?: ProjectCreateNestedManyWithoutManagerInput
    clientProjects?: ProjectCreateNestedManyWithoutClientInput
    projectMembers?: ProjectMemberCreateNestedManyWithoutUserInput
    projectUpdates?: ProjectUpdateCreateNestedManyWithoutAuthorInput
    media?: MediaCreateNestedManyWithoutCreatedByInput
    paymentsCreated?: PaymentCreateNestedManyWithoutCreatedByInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    projectsCreated?: ProjectCreateNestedManyWithoutCreatedByInput
    inspections?: InspectionCreateNestedManyWithoutEngineerInput
    reviewedInspections?: InspectionCreateNestedManyWithoutReviewedByInput
    queries?: QueryCreateNestedManyWithoutAuthorInput
    queryResponses?: QueryResponseCreateNestedManyWithoutAuthorInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
    notificationPrefs?: NotificationPreferenceCreateNestedOneWithoutUserInput
    materialsCreated?: MaterialCreateNestedManyWithoutCreatedByInput
  }

  export type UserUncheckedCreateWithoutCreatedUsersInput = {
    id?: string
    name: string
    email: string
    passwordHash: string
    role: $Enums.Role
    isActive?: boolean
    createdById?: string | null
    createdAt?: Date | string
    phone?: string | null
    designation?: string | null
    managedProjects?: ProjectUncheckedCreateNestedManyWithoutManagerInput
    clientProjects?: ProjectUncheckedCreateNestedManyWithoutClientInput
    projectMembers?: ProjectMemberUncheckedCreateNestedManyWithoutUserInput
    projectUpdates?: ProjectUpdateUncheckedCreateNestedManyWithoutAuthorInput
    media?: MediaUncheckedCreateNestedManyWithoutCreatedByInput
    paymentsCreated?: PaymentUncheckedCreateNestedManyWithoutCreatedByInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    projectsCreated?: ProjectUncheckedCreateNestedManyWithoutCreatedByInput
    inspections?: InspectionUncheckedCreateNestedManyWithoutEngineerInput
    reviewedInspections?: InspectionUncheckedCreateNestedManyWithoutReviewedByInput
    queries?: QueryUncheckedCreateNestedManyWithoutAuthorInput
    queryResponses?: QueryResponseUncheckedCreateNestedManyWithoutAuthorInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    notificationPrefs?: NotificationPreferenceUncheckedCreateNestedOneWithoutUserInput
    materialsCreated?: MaterialUncheckedCreateNestedManyWithoutCreatedByInput
  }

  export type UserCreateOrConnectWithoutCreatedUsersInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutCreatedUsersInput, UserUncheckedCreateWithoutCreatedUsersInput>
  }

  export type UserCreateWithoutCreatedByInput = {
    id?: string
    name: string
    email: string
    passwordHash: string
    role: $Enums.Role
    isActive?: boolean
    createdAt?: Date | string
    phone?: string | null
    designation?: string | null
    createdUsers?: UserCreateNestedManyWithoutCreatedByInput
    managedProjects?: ProjectCreateNestedManyWithoutManagerInput
    clientProjects?: ProjectCreateNestedManyWithoutClientInput
    projectMembers?: ProjectMemberCreateNestedManyWithoutUserInput
    projectUpdates?: ProjectUpdateCreateNestedManyWithoutAuthorInput
    media?: MediaCreateNestedManyWithoutCreatedByInput
    paymentsCreated?: PaymentCreateNestedManyWithoutCreatedByInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    projectsCreated?: ProjectCreateNestedManyWithoutCreatedByInput
    inspections?: InspectionCreateNestedManyWithoutEngineerInput
    reviewedInspections?: InspectionCreateNestedManyWithoutReviewedByInput
    queries?: QueryCreateNestedManyWithoutAuthorInput
    queryResponses?: QueryResponseCreateNestedManyWithoutAuthorInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
    notificationPrefs?: NotificationPreferenceCreateNestedOneWithoutUserInput
    materialsCreated?: MaterialCreateNestedManyWithoutCreatedByInput
  }

  export type UserUncheckedCreateWithoutCreatedByInput = {
    id?: string
    name: string
    email: string
    passwordHash: string
    role: $Enums.Role
    isActive?: boolean
    createdAt?: Date | string
    phone?: string | null
    designation?: string | null
    createdUsers?: UserUncheckedCreateNestedManyWithoutCreatedByInput
    managedProjects?: ProjectUncheckedCreateNestedManyWithoutManagerInput
    clientProjects?: ProjectUncheckedCreateNestedManyWithoutClientInput
    projectMembers?: ProjectMemberUncheckedCreateNestedManyWithoutUserInput
    projectUpdates?: ProjectUpdateUncheckedCreateNestedManyWithoutAuthorInput
    media?: MediaUncheckedCreateNestedManyWithoutCreatedByInput
    paymentsCreated?: PaymentUncheckedCreateNestedManyWithoutCreatedByInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    projectsCreated?: ProjectUncheckedCreateNestedManyWithoutCreatedByInput
    inspections?: InspectionUncheckedCreateNestedManyWithoutEngineerInput
    reviewedInspections?: InspectionUncheckedCreateNestedManyWithoutReviewedByInput
    queries?: QueryUncheckedCreateNestedManyWithoutAuthorInput
    queryResponses?: QueryResponseUncheckedCreateNestedManyWithoutAuthorInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    notificationPrefs?: NotificationPreferenceUncheckedCreateNestedOneWithoutUserInput
    materialsCreated?: MaterialUncheckedCreateNestedManyWithoutCreatedByInput
  }

  export type UserCreateOrConnectWithoutCreatedByInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutCreatedByInput, UserUncheckedCreateWithoutCreatedByInput>
  }

  export type UserCreateManyCreatedByInputEnvelope = {
    data: UserCreateManyCreatedByInput | UserCreateManyCreatedByInput[]
    skipDuplicates?: boolean
  }

  export type ProjectCreateWithoutManagerInput = {
    id?: string
    name: string
    description?: string | null
    status?: $Enums.ProjectStatus
    isArchived?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy: UserCreateNestedOneWithoutProjectsCreatedInput
    client: UserCreateNestedOneWithoutClientProjectsInput
    members?: ProjectMemberCreateNestedManyWithoutProjectInput
    updates?: ProjectUpdateCreateNestedManyWithoutProjectInput
    media?: MediaCreateNestedManyWithoutProjectInput
    payments?: PaymentCreateNestedManyWithoutProjectInput
    milestones?: MilestoneCreateNestedManyWithoutProjectInput
    inspections?: InspectionCreateNestedManyWithoutProjectInput
    queries?: QueryCreateNestedManyWithoutProjectInput
    materials?: MaterialCreateNestedManyWithoutProjectInput
    auditLogs?: AuditLogCreateNestedManyWithoutProjectInput
  }

  export type ProjectUncheckedCreateWithoutManagerInput = {
    id?: string
    name: string
    description?: string | null
    status?: $Enums.ProjectStatus
    isArchived?: boolean
    createdById: string
    clientId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    members?: ProjectMemberUncheckedCreateNestedManyWithoutProjectInput
    updates?: ProjectUpdateUncheckedCreateNestedManyWithoutProjectInput
    media?: MediaUncheckedCreateNestedManyWithoutProjectInput
    payments?: PaymentUncheckedCreateNestedManyWithoutProjectInput
    milestones?: MilestoneUncheckedCreateNestedManyWithoutProjectInput
    inspections?: InspectionUncheckedCreateNestedManyWithoutProjectInput
    queries?: QueryUncheckedCreateNestedManyWithoutProjectInput
    materials?: MaterialUncheckedCreateNestedManyWithoutProjectInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutProjectInput
  }

  export type ProjectCreateOrConnectWithoutManagerInput = {
    where: ProjectWhereUniqueInput
    create: XOR<ProjectCreateWithoutManagerInput, ProjectUncheckedCreateWithoutManagerInput>
  }

  export type ProjectCreateManyManagerInputEnvelope = {
    data: ProjectCreateManyManagerInput | ProjectCreateManyManagerInput[]
    skipDuplicates?: boolean
  }

  export type ProjectCreateWithoutClientInput = {
    id?: string
    name: string
    description?: string | null
    status?: $Enums.ProjectStatus
    isArchived?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy: UserCreateNestedOneWithoutProjectsCreatedInput
    manager: UserCreateNestedOneWithoutManagedProjectsInput
    members?: ProjectMemberCreateNestedManyWithoutProjectInput
    updates?: ProjectUpdateCreateNestedManyWithoutProjectInput
    media?: MediaCreateNestedManyWithoutProjectInput
    payments?: PaymentCreateNestedManyWithoutProjectInput
    milestones?: MilestoneCreateNestedManyWithoutProjectInput
    inspections?: InspectionCreateNestedManyWithoutProjectInput
    queries?: QueryCreateNestedManyWithoutProjectInput
    materials?: MaterialCreateNestedManyWithoutProjectInput
    auditLogs?: AuditLogCreateNestedManyWithoutProjectInput
  }

  export type ProjectUncheckedCreateWithoutClientInput = {
    id?: string
    name: string
    description?: string | null
    status?: $Enums.ProjectStatus
    isArchived?: boolean
    createdById: string
    managerId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    members?: ProjectMemberUncheckedCreateNestedManyWithoutProjectInput
    updates?: ProjectUpdateUncheckedCreateNestedManyWithoutProjectInput
    media?: MediaUncheckedCreateNestedManyWithoutProjectInput
    payments?: PaymentUncheckedCreateNestedManyWithoutProjectInput
    milestones?: MilestoneUncheckedCreateNestedManyWithoutProjectInput
    inspections?: InspectionUncheckedCreateNestedManyWithoutProjectInput
    queries?: QueryUncheckedCreateNestedManyWithoutProjectInput
    materials?: MaterialUncheckedCreateNestedManyWithoutProjectInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutProjectInput
  }

  export type ProjectCreateOrConnectWithoutClientInput = {
    where: ProjectWhereUniqueInput
    create: XOR<ProjectCreateWithoutClientInput, ProjectUncheckedCreateWithoutClientInput>
  }

  export type ProjectCreateManyClientInputEnvelope = {
    data: ProjectCreateManyClientInput | ProjectCreateManyClientInput[]
    skipDuplicates?: boolean
  }

  export type ProjectMemberCreateWithoutUserInput = {
    id?: string
    role: $Enums.ProjectMemberRole
    createdAt?: Date | string
    project: ProjectCreateNestedOneWithoutMembersInput
  }

  export type ProjectMemberUncheckedCreateWithoutUserInput = {
    id?: string
    projectId: string
    role: $Enums.ProjectMemberRole
    createdAt?: Date | string
  }

  export type ProjectMemberCreateOrConnectWithoutUserInput = {
    where: ProjectMemberWhereUniqueInput
    create: XOR<ProjectMemberCreateWithoutUserInput, ProjectMemberUncheckedCreateWithoutUserInput>
  }

  export type ProjectMemberCreateManyUserInputEnvelope = {
    data: ProjectMemberCreateManyUserInput | ProjectMemberCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type ProjectUpdateCreateWithoutAuthorInput = {
    id?: string
    notes: string
    statusSnapshot?: string | null
    createdAt?: Date | string
    project: ProjectCreateNestedOneWithoutUpdatesInput
    media?: MediaCreateNestedManyWithoutProjectUpdateInput
  }

  export type ProjectUpdateUncheckedCreateWithoutAuthorInput = {
    id?: string
    projectId: string
    notes: string
    statusSnapshot?: string | null
    createdAt?: Date | string
    media?: MediaUncheckedCreateNestedManyWithoutProjectUpdateInput
  }

  export type ProjectUpdateCreateOrConnectWithoutAuthorInput = {
    where: ProjectUpdateWhereUniqueInput
    create: XOR<ProjectUpdateCreateWithoutAuthorInput, ProjectUpdateUncheckedCreateWithoutAuthorInput>
  }

  export type ProjectUpdateCreateManyAuthorInputEnvelope = {
    data: ProjectUpdateCreateManyAuthorInput | ProjectUpdateCreateManyAuthorInput[]
    skipDuplicates?: boolean
  }

  export type MediaCreateWithoutCreatedByInput = {
    id?: string
    type: $Enums.MediaType
    fileKey: string
    fileUrl: string
    mimeType: string
    fileSize: number
    approvedBy?: string | null
    approvedAt?: Date | string | null
    version?: number | null
    createdAt?: Date | string
    project: ProjectCreateNestedOneWithoutMediaInput
    projectUpdate?: ProjectUpdateCreateNestedOneWithoutMediaInput
    payment?: PaymentCreateNestedOneWithoutMediaInput
    inspectionResponses?: InspectionResponseCreateNestedManyWithoutMediaInput
    query?: QueryCreateNestedOneWithoutAttachmentsInput
  }

  export type MediaUncheckedCreateWithoutCreatedByInput = {
    id?: string
    projectId: string
    projectUpdateId?: string | null
    paymentId?: string | null
    type: $Enums.MediaType
    fileKey: string
    fileUrl: string
    mimeType: string
    fileSize: number
    approvedBy?: string | null
    approvedAt?: Date | string | null
    version?: number | null
    createdAt?: Date | string
    queryId?: string | null
    inspectionResponses?: InspectionResponseUncheckedCreateNestedManyWithoutMediaInput
  }

  export type MediaCreateOrConnectWithoutCreatedByInput = {
    where: MediaWhereUniqueInput
    create: XOR<MediaCreateWithoutCreatedByInput, MediaUncheckedCreateWithoutCreatedByInput>
  }

  export type MediaCreateManyCreatedByInputEnvelope = {
    data: MediaCreateManyCreatedByInput | MediaCreateManyCreatedByInput[]
    skipDuplicates?: boolean
  }

  export type PaymentCreateWithoutCreatedByInput = {
    id?: string
    amount: Decimal | DecimalJsLike | number | string
    currency?: string
    status?: $Enums.PaymentStatus
    category?: $Enums.PaymentCategory | null
    invoiceNumber?: string | null
    paidAt?: Date | string | null
    dueDate?: Date | string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    project: ProjectCreateNestedOneWithoutPaymentsInput
    media?: MediaCreateNestedManyWithoutPaymentInput
  }

  export type PaymentUncheckedCreateWithoutCreatedByInput = {
    id?: string
    projectId: string
    amount: Decimal | DecimalJsLike | number | string
    currency?: string
    status?: $Enums.PaymentStatus
    category?: $Enums.PaymentCategory | null
    invoiceNumber?: string | null
    paidAt?: Date | string | null
    dueDate?: Date | string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    media?: MediaUncheckedCreateNestedManyWithoutPaymentInput
  }

  export type PaymentCreateOrConnectWithoutCreatedByInput = {
    where: PaymentWhereUniqueInput
    create: XOR<PaymentCreateWithoutCreatedByInput, PaymentUncheckedCreateWithoutCreatedByInput>
  }

  export type PaymentCreateManyCreatedByInputEnvelope = {
    data: PaymentCreateManyCreatedByInput | PaymentCreateManyCreatedByInput[]
    skipDuplicates?: boolean
  }

  export type NotificationCreateWithoutUserInput = {
    id?: string
    title: string
    message: string
    type: string
    priority?: $Enums.NotificationPriority
    actionUrl?: string | null
    isRead?: boolean
    createdAt?: Date | string
  }

  export type NotificationUncheckedCreateWithoutUserInput = {
    id?: string
    title: string
    message: string
    type: string
    priority?: $Enums.NotificationPriority
    actionUrl?: string | null
    isRead?: boolean
    createdAt?: Date | string
  }

  export type NotificationCreateOrConnectWithoutUserInput = {
    where: NotificationWhereUniqueInput
    create: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput>
  }

  export type NotificationCreateManyUserInputEnvelope = {
    data: NotificationCreateManyUserInput | NotificationCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type ProjectCreateWithoutCreatedByInput = {
    id?: string
    name: string
    description?: string | null
    status?: $Enums.ProjectStatus
    isArchived?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    manager: UserCreateNestedOneWithoutManagedProjectsInput
    client: UserCreateNestedOneWithoutClientProjectsInput
    members?: ProjectMemberCreateNestedManyWithoutProjectInput
    updates?: ProjectUpdateCreateNestedManyWithoutProjectInput
    media?: MediaCreateNestedManyWithoutProjectInput
    payments?: PaymentCreateNestedManyWithoutProjectInput
    milestones?: MilestoneCreateNestedManyWithoutProjectInput
    inspections?: InspectionCreateNestedManyWithoutProjectInput
    queries?: QueryCreateNestedManyWithoutProjectInput
    materials?: MaterialCreateNestedManyWithoutProjectInput
    auditLogs?: AuditLogCreateNestedManyWithoutProjectInput
  }

  export type ProjectUncheckedCreateWithoutCreatedByInput = {
    id?: string
    name: string
    description?: string | null
    status?: $Enums.ProjectStatus
    isArchived?: boolean
    managerId: string
    clientId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    members?: ProjectMemberUncheckedCreateNestedManyWithoutProjectInput
    updates?: ProjectUpdateUncheckedCreateNestedManyWithoutProjectInput
    media?: MediaUncheckedCreateNestedManyWithoutProjectInput
    payments?: PaymentUncheckedCreateNestedManyWithoutProjectInput
    milestones?: MilestoneUncheckedCreateNestedManyWithoutProjectInput
    inspections?: InspectionUncheckedCreateNestedManyWithoutProjectInput
    queries?: QueryUncheckedCreateNestedManyWithoutProjectInput
    materials?: MaterialUncheckedCreateNestedManyWithoutProjectInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutProjectInput
  }

  export type ProjectCreateOrConnectWithoutCreatedByInput = {
    where: ProjectWhereUniqueInput
    create: XOR<ProjectCreateWithoutCreatedByInput, ProjectUncheckedCreateWithoutCreatedByInput>
  }

  export type ProjectCreateManyCreatedByInputEnvelope = {
    data: ProjectCreateManyCreatedByInput | ProjectCreateManyCreatedByInput[]
    skipDuplicates?: boolean
  }

  export type InspectionCreateWithoutEngineerInput = {
    id?: string
    status?: $Enums.InspectionStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    project: ProjectCreateNestedOneWithoutInspectionsInput
    milestone: MilestoneCreateNestedOneWithoutInspectionsInput
    responses?: InspectionResponseCreateNestedManyWithoutInspectionInput
    reviewedBy?: UserCreateNestedOneWithoutReviewedInspectionsInput
  }

  export type InspectionUncheckedCreateWithoutEngineerInput = {
    id?: string
    status?: $Enums.InspectionStatus
    projectId: string
    milestoneId: string
    reviewedById?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    responses?: InspectionResponseUncheckedCreateNestedManyWithoutInspectionInput
  }

  export type InspectionCreateOrConnectWithoutEngineerInput = {
    where: InspectionWhereUniqueInput
    create: XOR<InspectionCreateWithoutEngineerInput, InspectionUncheckedCreateWithoutEngineerInput>
  }

  export type InspectionCreateManyEngineerInputEnvelope = {
    data: InspectionCreateManyEngineerInput | InspectionCreateManyEngineerInput[]
    skipDuplicates?: boolean
  }

  export type InspectionCreateWithoutReviewedByInput = {
    id?: string
    status?: $Enums.InspectionStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    project: ProjectCreateNestedOneWithoutInspectionsInput
    milestone: MilestoneCreateNestedOneWithoutInspectionsInput
    engineer: UserCreateNestedOneWithoutInspectionsInput
    responses?: InspectionResponseCreateNestedManyWithoutInspectionInput
  }

  export type InspectionUncheckedCreateWithoutReviewedByInput = {
    id?: string
    status?: $Enums.InspectionStatus
    projectId: string
    milestoneId: string
    engineerId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    responses?: InspectionResponseUncheckedCreateNestedManyWithoutInspectionInput
  }

  export type InspectionCreateOrConnectWithoutReviewedByInput = {
    where: InspectionWhereUniqueInput
    create: XOR<InspectionCreateWithoutReviewedByInput, InspectionUncheckedCreateWithoutReviewedByInput>
  }

  export type InspectionCreateManyReviewedByInputEnvelope = {
    data: InspectionCreateManyReviewedByInput | InspectionCreateManyReviewedByInput[]
    skipDuplicates?: boolean
  }

  export type QueryCreateWithoutAuthorInput = {
    id?: string
    title: string
    description: string
    status?: $Enums.QueryStatus
    priority?: $Enums.QueryPriority
    createdAt?: Date | string
    updatedAt?: Date | string
    project: ProjectCreateNestedOneWithoutQueriesInput
    attachments?: MediaCreateNestedManyWithoutQueryInput
    responses?: QueryResponseCreateNestedManyWithoutQueryInput
  }

  export type QueryUncheckedCreateWithoutAuthorInput = {
    id?: string
    projectId: string
    title: string
    description: string
    status?: $Enums.QueryStatus
    priority?: $Enums.QueryPriority
    createdAt?: Date | string
    updatedAt?: Date | string
    attachments?: MediaUncheckedCreateNestedManyWithoutQueryInput
    responses?: QueryResponseUncheckedCreateNestedManyWithoutQueryInput
  }

  export type QueryCreateOrConnectWithoutAuthorInput = {
    where: QueryWhereUniqueInput
    create: XOR<QueryCreateWithoutAuthorInput, QueryUncheckedCreateWithoutAuthorInput>
  }

  export type QueryCreateManyAuthorInputEnvelope = {
    data: QueryCreateManyAuthorInput | QueryCreateManyAuthorInput[]
    skipDuplicates?: boolean
  }

  export type QueryResponseCreateWithoutAuthorInput = {
    id?: string
    message: string
    createdAt?: Date | string
    query: QueryCreateNestedOneWithoutResponsesInput
  }

  export type QueryResponseUncheckedCreateWithoutAuthorInput = {
    id?: string
    queryId: string
    message: string
    createdAt?: Date | string
  }

  export type QueryResponseCreateOrConnectWithoutAuthorInput = {
    where: QueryResponseWhereUniqueInput
    create: XOR<QueryResponseCreateWithoutAuthorInput, QueryResponseUncheckedCreateWithoutAuthorInput>
  }

  export type QueryResponseCreateManyAuthorInputEnvelope = {
    data: QueryResponseCreateManyAuthorInput | QueryResponseCreateManyAuthorInput[]
    skipDuplicates?: boolean
  }

  export type AuditLogCreateWithoutUserInput = {
    id?: string
    action: string
    entity: string
    entityId: string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    project?: ProjectCreateNestedOneWithoutAuditLogsInput
  }

  export type AuditLogUncheckedCreateWithoutUserInput = {
    id?: string
    action: string
    entity: string
    entityId: string
    projectId?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type AuditLogCreateOrConnectWithoutUserInput = {
    where: AuditLogWhereUniqueInput
    create: XOR<AuditLogCreateWithoutUserInput, AuditLogUncheckedCreateWithoutUserInput>
  }

  export type AuditLogCreateManyUserInputEnvelope = {
    data: AuditLogCreateManyUserInput | AuditLogCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type NotificationPreferenceCreateWithoutUserInput = {
    id?: string
    inspectionSubmitted?: boolean
    paymentOverdue?: boolean
    newAssignment?: boolean
    queryCreated?: boolean
    drawingApproved?: boolean
    emailEnabled?: boolean
    inAppEnabled?: boolean
    updatedAt?: Date | string
  }

  export type NotificationPreferenceUncheckedCreateWithoutUserInput = {
    id?: string
    inspectionSubmitted?: boolean
    paymentOverdue?: boolean
    newAssignment?: boolean
    queryCreated?: boolean
    drawingApproved?: boolean
    emailEnabled?: boolean
    inAppEnabled?: boolean
    updatedAt?: Date | string
  }

  export type NotificationPreferenceCreateOrConnectWithoutUserInput = {
    where: NotificationPreferenceWhereUniqueInput
    create: XOR<NotificationPreferenceCreateWithoutUserInput, NotificationPreferenceUncheckedCreateWithoutUserInput>
  }

  export type MaterialCreateWithoutCreatedByInput = {
    id?: string
    name: string
    quantity: number
    unit: string
    unitCost: number
    totalCost: number
    supplier?: string | null
    status?: $Enums.MaterialStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    project: ProjectCreateNestedOneWithoutMaterialsInput
  }

  export type MaterialUncheckedCreateWithoutCreatedByInput = {
    id?: string
    projectId: string
    name: string
    quantity: number
    unit: string
    unitCost: number
    totalCost: number
    supplier?: string | null
    status?: $Enums.MaterialStatus
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MaterialCreateOrConnectWithoutCreatedByInput = {
    where: MaterialWhereUniqueInput
    create: XOR<MaterialCreateWithoutCreatedByInput, MaterialUncheckedCreateWithoutCreatedByInput>
  }

  export type MaterialCreateManyCreatedByInputEnvelope = {
    data: MaterialCreateManyCreatedByInput | MaterialCreateManyCreatedByInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutCreatedUsersInput = {
    update: XOR<UserUpdateWithoutCreatedUsersInput, UserUncheckedUpdateWithoutCreatedUsersInput>
    create: XOR<UserCreateWithoutCreatedUsersInput, UserUncheckedCreateWithoutCreatedUsersInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutCreatedUsersInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutCreatedUsersInput, UserUncheckedUpdateWithoutCreatedUsersInput>
  }

  export type UserUpdateWithoutCreatedUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    designation?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: UserUpdateOneWithoutCreatedUsersNestedInput
    managedProjects?: ProjectUpdateManyWithoutManagerNestedInput
    clientProjects?: ProjectUpdateManyWithoutClientNestedInput
    projectMembers?: ProjectMemberUpdateManyWithoutUserNestedInput
    projectUpdates?: ProjectUpdateUpdateManyWithoutAuthorNestedInput
    media?: MediaUpdateManyWithoutCreatedByNestedInput
    paymentsCreated?: PaymentUpdateManyWithoutCreatedByNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    projectsCreated?: ProjectUpdateManyWithoutCreatedByNestedInput
    inspections?: InspectionUpdateManyWithoutEngineerNestedInput
    reviewedInspections?: InspectionUpdateManyWithoutReviewedByNestedInput
    queries?: QueryUpdateManyWithoutAuthorNestedInput
    queryResponses?: QueryResponseUpdateManyWithoutAuthorNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
    notificationPrefs?: NotificationPreferenceUpdateOneWithoutUserNestedInput
    materialsCreated?: MaterialUpdateManyWithoutCreatedByNestedInput
  }

  export type UserUncheckedUpdateWithoutCreatedUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    designation?: NullableStringFieldUpdateOperationsInput | string | null
    managedProjects?: ProjectUncheckedUpdateManyWithoutManagerNestedInput
    clientProjects?: ProjectUncheckedUpdateManyWithoutClientNestedInput
    projectMembers?: ProjectMemberUncheckedUpdateManyWithoutUserNestedInput
    projectUpdates?: ProjectUpdateUncheckedUpdateManyWithoutAuthorNestedInput
    media?: MediaUncheckedUpdateManyWithoutCreatedByNestedInput
    paymentsCreated?: PaymentUncheckedUpdateManyWithoutCreatedByNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    projectsCreated?: ProjectUncheckedUpdateManyWithoutCreatedByNestedInput
    inspections?: InspectionUncheckedUpdateManyWithoutEngineerNestedInput
    reviewedInspections?: InspectionUncheckedUpdateManyWithoutReviewedByNestedInput
    queries?: QueryUncheckedUpdateManyWithoutAuthorNestedInput
    queryResponses?: QueryResponseUncheckedUpdateManyWithoutAuthorNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    notificationPrefs?: NotificationPreferenceUncheckedUpdateOneWithoutUserNestedInput
    materialsCreated?: MaterialUncheckedUpdateManyWithoutCreatedByNestedInput
  }

  export type UserUpsertWithWhereUniqueWithoutCreatedByInput = {
    where: UserWhereUniqueInput
    update: XOR<UserUpdateWithoutCreatedByInput, UserUncheckedUpdateWithoutCreatedByInput>
    create: XOR<UserCreateWithoutCreatedByInput, UserUncheckedCreateWithoutCreatedByInput>
  }

  export type UserUpdateWithWhereUniqueWithoutCreatedByInput = {
    where: UserWhereUniqueInput
    data: XOR<UserUpdateWithoutCreatedByInput, UserUncheckedUpdateWithoutCreatedByInput>
  }

  export type UserUpdateManyWithWhereWithoutCreatedByInput = {
    where: UserScalarWhereInput
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyWithoutCreatedByInput>
  }

  export type UserScalarWhereInput = {
    AND?: UserScalarWhereInput | UserScalarWhereInput[]
    OR?: UserScalarWhereInput[]
    NOT?: UserScalarWhereInput | UserScalarWhereInput[]
    id?: StringFilter<"User"> | string
    name?: StringFilter<"User"> | string
    email?: StringFilter<"User"> | string
    passwordHash?: StringFilter<"User"> | string
    role?: EnumRoleFilter<"User"> | $Enums.Role
    isActive?: BoolFilter<"User"> | boolean
    createdById?: StringNullableFilter<"User"> | string | null
    createdAt?: DateTimeFilter<"User"> | Date | string
    phone?: StringNullableFilter<"User"> | string | null
    designation?: StringNullableFilter<"User"> | string | null
  }

  export type ProjectUpsertWithWhereUniqueWithoutManagerInput = {
    where: ProjectWhereUniqueInput
    update: XOR<ProjectUpdateWithoutManagerInput, ProjectUncheckedUpdateWithoutManagerInput>
    create: XOR<ProjectCreateWithoutManagerInput, ProjectUncheckedCreateWithoutManagerInput>
  }

  export type ProjectUpdateWithWhereUniqueWithoutManagerInput = {
    where: ProjectWhereUniqueInput
    data: XOR<ProjectUpdateWithoutManagerInput, ProjectUncheckedUpdateWithoutManagerInput>
  }

  export type ProjectUpdateManyWithWhereWithoutManagerInput = {
    where: ProjectScalarWhereInput
    data: XOR<ProjectUpdateManyMutationInput, ProjectUncheckedUpdateManyWithoutManagerInput>
  }

  export type ProjectScalarWhereInput = {
    AND?: ProjectScalarWhereInput | ProjectScalarWhereInput[]
    OR?: ProjectScalarWhereInput[]
    NOT?: ProjectScalarWhereInput | ProjectScalarWhereInput[]
    id?: StringFilter<"Project"> | string
    name?: StringFilter<"Project"> | string
    description?: StringNullableFilter<"Project"> | string | null
    status?: EnumProjectStatusFilter<"Project"> | $Enums.ProjectStatus
    isArchived?: BoolFilter<"Project"> | boolean
    createdById?: StringFilter<"Project"> | string
    managerId?: StringFilter<"Project"> | string
    clientId?: StringFilter<"Project"> | string
    createdAt?: DateTimeFilter<"Project"> | Date | string
    updatedAt?: DateTimeFilter<"Project"> | Date | string
  }

  export type ProjectUpsertWithWhereUniqueWithoutClientInput = {
    where: ProjectWhereUniqueInput
    update: XOR<ProjectUpdateWithoutClientInput, ProjectUncheckedUpdateWithoutClientInput>
    create: XOR<ProjectCreateWithoutClientInput, ProjectUncheckedCreateWithoutClientInput>
  }

  export type ProjectUpdateWithWhereUniqueWithoutClientInput = {
    where: ProjectWhereUniqueInput
    data: XOR<ProjectUpdateWithoutClientInput, ProjectUncheckedUpdateWithoutClientInput>
  }

  export type ProjectUpdateManyWithWhereWithoutClientInput = {
    where: ProjectScalarWhereInput
    data: XOR<ProjectUpdateManyMutationInput, ProjectUncheckedUpdateManyWithoutClientInput>
  }

  export type ProjectMemberUpsertWithWhereUniqueWithoutUserInput = {
    where: ProjectMemberWhereUniqueInput
    update: XOR<ProjectMemberUpdateWithoutUserInput, ProjectMemberUncheckedUpdateWithoutUserInput>
    create: XOR<ProjectMemberCreateWithoutUserInput, ProjectMemberUncheckedCreateWithoutUserInput>
  }

  export type ProjectMemberUpdateWithWhereUniqueWithoutUserInput = {
    where: ProjectMemberWhereUniqueInput
    data: XOR<ProjectMemberUpdateWithoutUserInput, ProjectMemberUncheckedUpdateWithoutUserInput>
  }

  export type ProjectMemberUpdateManyWithWhereWithoutUserInput = {
    where: ProjectMemberScalarWhereInput
    data: XOR<ProjectMemberUpdateManyMutationInput, ProjectMemberUncheckedUpdateManyWithoutUserInput>
  }

  export type ProjectMemberScalarWhereInput = {
    AND?: ProjectMemberScalarWhereInput | ProjectMemberScalarWhereInput[]
    OR?: ProjectMemberScalarWhereInput[]
    NOT?: ProjectMemberScalarWhereInput | ProjectMemberScalarWhereInput[]
    id?: StringFilter<"ProjectMember"> | string
    projectId?: StringFilter<"ProjectMember"> | string
    userId?: StringFilter<"ProjectMember"> | string
    role?: EnumProjectMemberRoleFilter<"ProjectMember"> | $Enums.ProjectMemberRole
    createdAt?: DateTimeFilter<"ProjectMember"> | Date | string
  }

  export type ProjectUpdateUpsertWithWhereUniqueWithoutAuthorInput = {
    where: ProjectUpdateWhereUniqueInput
    update: XOR<ProjectUpdateUpdateWithoutAuthorInput, ProjectUpdateUncheckedUpdateWithoutAuthorInput>
    create: XOR<ProjectUpdateCreateWithoutAuthorInput, ProjectUpdateUncheckedCreateWithoutAuthorInput>
  }

  export type ProjectUpdateUpdateWithWhereUniqueWithoutAuthorInput = {
    where: ProjectUpdateWhereUniqueInput
    data: XOR<ProjectUpdateUpdateWithoutAuthorInput, ProjectUpdateUncheckedUpdateWithoutAuthorInput>
  }

  export type ProjectUpdateUpdateManyWithWhereWithoutAuthorInput = {
    where: ProjectUpdateScalarWhereInput
    data: XOR<ProjectUpdateUpdateManyMutationInput, ProjectUpdateUncheckedUpdateManyWithoutAuthorInput>
  }

  export type ProjectUpdateScalarWhereInput = {
    AND?: ProjectUpdateScalarWhereInput | ProjectUpdateScalarWhereInput[]
    OR?: ProjectUpdateScalarWhereInput[]
    NOT?: ProjectUpdateScalarWhereInput | ProjectUpdateScalarWhereInput[]
    id?: StringFilter<"ProjectUpdate"> | string
    projectId?: StringFilter<"ProjectUpdate"> | string
    authorId?: StringFilter<"ProjectUpdate"> | string
    notes?: StringFilter<"ProjectUpdate"> | string
    statusSnapshot?: StringNullableFilter<"ProjectUpdate"> | string | null
    createdAt?: DateTimeFilter<"ProjectUpdate"> | Date | string
  }

  export type MediaUpsertWithWhereUniqueWithoutCreatedByInput = {
    where: MediaWhereUniqueInput
    update: XOR<MediaUpdateWithoutCreatedByInput, MediaUncheckedUpdateWithoutCreatedByInput>
    create: XOR<MediaCreateWithoutCreatedByInput, MediaUncheckedCreateWithoutCreatedByInput>
  }

  export type MediaUpdateWithWhereUniqueWithoutCreatedByInput = {
    where: MediaWhereUniqueInput
    data: XOR<MediaUpdateWithoutCreatedByInput, MediaUncheckedUpdateWithoutCreatedByInput>
  }

  export type MediaUpdateManyWithWhereWithoutCreatedByInput = {
    where: MediaScalarWhereInput
    data: XOR<MediaUpdateManyMutationInput, MediaUncheckedUpdateManyWithoutCreatedByInput>
  }

  export type MediaScalarWhereInput = {
    AND?: MediaScalarWhereInput | MediaScalarWhereInput[]
    OR?: MediaScalarWhereInput[]
    NOT?: MediaScalarWhereInput | MediaScalarWhereInput[]
    id?: StringFilter<"Media"> | string
    projectId?: StringFilter<"Media"> | string
    projectUpdateId?: StringNullableFilter<"Media"> | string | null
    paymentId?: StringNullableFilter<"Media"> | string | null
    type?: EnumMediaTypeFilter<"Media"> | $Enums.MediaType
    fileKey?: StringFilter<"Media"> | string
    fileUrl?: StringFilter<"Media"> | string
    mimeType?: StringFilter<"Media"> | string
    fileSize?: IntFilter<"Media"> | number
    createdById?: StringFilter<"Media"> | string
    approvedBy?: StringNullableFilter<"Media"> | string | null
    approvedAt?: DateTimeNullableFilter<"Media"> | Date | string | null
    version?: IntNullableFilter<"Media"> | number | null
    createdAt?: DateTimeFilter<"Media"> | Date | string
    queryId?: StringNullableFilter<"Media"> | string | null
  }

  export type PaymentUpsertWithWhereUniqueWithoutCreatedByInput = {
    where: PaymentWhereUniqueInput
    update: XOR<PaymentUpdateWithoutCreatedByInput, PaymentUncheckedUpdateWithoutCreatedByInput>
    create: XOR<PaymentCreateWithoutCreatedByInput, PaymentUncheckedCreateWithoutCreatedByInput>
  }

  export type PaymentUpdateWithWhereUniqueWithoutCreatedByInput = {
    where: PaymentWhereUniqueInput
    data: XOR<PaymentUpdateWithoutCreatedByInput, PaymentUncheckedUpdateWithoutCreatedByInput>
  }

  export type PaymentUpdateManyWithWhereWithoutCreatedByInput = {
    where: PaymentScalarWhereInput
    data: XOR<PaymentUpdateManyMutationInput, PaymentUncheckedUpdateManyWithoutCreatedByInput>
  }

  export type PaymentScalarWhereInput = {
    AND?: PaymentScalarWhereInput | PaymentScalarWhereInput[]
    OR?: PaymentScalarWhereInput[]
    NOT?: PaymentScalarWhereInput | PaymentScalarWhereInput[]
    id?: StringFilter<"Payment"> | string
    projectId?: StringFilter<"Payment"> | string
    createdById?: StringFilter<"Payment"> | string
    amount?: DecimalFilter<"Payment"> | Decimal | DecimalJsLike | number | string
    currency?: StringFilter<"Payment"> | string
    status?: EnumPaymentStatusFilter<"Payment"> | $Enums.PaymentStatus
    category?: EnumPaymentCategoryNullableFilter<"Payment"> | $Enums.PaymentCategory | null
    invoiceNumber?: StringNullableFilter<"Payment"> | string | null
    paidAt?: DateTimeNullableFilter<"Payment"> | Date | string | null
    dueDate?: DateTimeNullableFilter<"Payment"> | Date | string | null
    notes?: StringNullableFilter<"Payment"> | string | null
    createdAt?: DateTimeFilter<"Payment"> | Date | string
    updatedAt?: DateTimeFilter<"Payment"> | Date | string
  }

  export type NotificationUpsertWithWhereUniqueWithoutUserInput = {
    where: NotificationWhereUniqueInput
    update: XOR<NotificationUpdateWithoutUserInput, NotificationUncheckedUpdateWithoutUserInput>
    create: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput>
  }

  export type NotificationUpdateWithWhereUniqueWithoutUserInput = {
    where: NotificationWhereUniqueInput
    data: XOR<NotificationUpdateWithoutUserInput, NotificationUncheckedUpdateWithoutUserInput>
  }

  export type NotificationUpdateManyWithWhereWithoutUserInput = {
    where: NotificationScalarWhereInput
    data: XOR<NotificationUpdateManyMutationInput, NotificationUncheckedUpdateManyWithoutUserInput>
  }

  export type NotificationScalarWhereInput = {
    AND?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
    OR?: NotificationScalarWhereInput[]
    NOT?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
    id?: StringFilter<"Notification"> | string
    userId?: StringFilter<"Notification"> | string
    title?: StringFilter<"Notification"> | string
    message?: StringFilter<"Notification"> | string
    type?: StringFilter<"Notification"> | string
    priority?: EnumNotificationPriorityFilter<"Notification"> | $Enums.NotificationPriority
    actionUrl?: StringNullableFilter<"Notification"> | string | null
    isRead?: BoolFilter<"Notification"> | boolean
    createdAt?: DateTimeFilter<"Notification"> | Date | string
  }

  export type ProjectUpsertWithWhereUniqueWithoutCreatedByInput = {
    where: ProjectWhereUniqueInput
    update: XOR<ProjectUpdateWithoutCreatedByInput, ProjectUncheckedUpdateWithoutCreatedByInput>
    create: XOR<ProjectCreateWithoutCreatedByInput, ProjectUncheckedCreateWithoutCreatedByInput>
  }

  export type ProjectUpdateWithWhereUniqueWithoutCreatedByInput = {
    where: ProjectWhereUniqueInput
    data: XOR<ProjectUpdateWithoutCreatedByInput, ProjectUncheckedUpdateWithoutCreatedByInput>
  }

  export type ProjectUpdateManyWithWhereWithoutCreatedByInput = {
    where: ProjectScalarWhereInput
    data: XOR<ProjectUpdateManyMutationInput, ProjectUncheckedUpdateManyWithoutCreatedByInput>
  }

  export type InspectionUpsertWithWhereUniqueWithoutEngineerInput = {
    where: InspectionWhereUniqueInput
    update: XOR<InspectionUpdateWithoutEngineerInput, InspectionUncheckedUpdateWithoutEngineerInput>
    create: XOR<InspectionCreateWithoutEngineerInput, InspectionUncheckedCreateWithoutEngineerInput>
  }

  export type InspectionUpdateWithWhereUniqueWithoutEngineerInput = {
    where: InspectionWhereUniqueInput
    data: XOR<InspectionUpdateWithoutEngineerInput, InspectionUncheckedUpdateWithoutEngineerInput>
  }

  export type InspectionUpdateManyWithWhereWithoutEngineerInput = {
    where: InspectionScalarWhereInput
    data: XOR<InspectionUpdateManyMutationInput, InspectionUncheckedUpdateManyWithoutEngineerInput>
  }

  export type InspectionScalarWhereInput = {
    AND?: InspectionScalarWhereInput | InspectionScalarWhereInput[]
    OR?: InspectionScalarWhereInput[]
    NOT?: InspectionScalarWhereInput | InspectionScalarWhereInput[]
    id?: StringFilter<"Inspection"> | string
    status?: EnumInspectionStatusFilter<"Inspection"> | $Enums.InspectionStatus
    projectId?: StringFilter<"Inspection"> | string
    milestoneId?: StringFilter<"Inspection"> | string
    engineerId?: StringFilter<"Inspection"> | string
    reviewedById?: StringNullableFilter<"Inspection"> | string | null
    createdAt?: DateTimeFilter<"Inspection"> | Date | string
    updatedAt?: DateTimeFilter<"Inspection"> | Date | string
  }

  export type InspectionUpsertWithWhereUniqueWithoutReviewedByInput = {
    where: InspectionWhereUniqueInput
    update: XOR<InspectionUpdateWithoutReviewedByInput, InspectionUncheckedUpdateWithoutReviewedByInput>
    create: XOR<InspectionCreateWithoutReviewedByInput, InspectionUncheckedCreateWithoutReviewedByInput>
  }

  export type InspectionUpdateWithWhereUniqueWithoutReviewedByInput = {
    where: InspectionWhereUniqueInput
    data: XOR<InspectionUpdateWithoutReviewedByInput, InspectionUncheckedUpdateWithoutReviewedByInput>
  }

  export type InspectionUpdateManyWithWhereWithoutReviewedByInput = {
    where: InspectionScalarWhereInput
    data: XOR<InspectionUpdateManyMutationInput, InspectionUncheckedUpdateManyWithoutReviewedByInput>
  }

  export type QueryUpsertWithWhereUniqueWithoutAuthorInput = {
    where: QueryWhereUniqueInput
    update: XOR<QueryUpdateWithoutAuthorInput, QueryUncheckedUpdateWithoutAuthorInput>
    create: XOR<QueryCreateWithoutAuthorInput, QueryUncheckedCreateWithoutAuthorInput>
  }

  export type QueryUpdateWithWhereUniqueWithoutAuthorInput = {
    where: QueryWhereUniqueInput
    data: XOR<QueryUpdateWithoutAuthorInput, QueryUncheckedUpdateWithoutAuthorInput>
  }

  export type QueryUpdateManyWithWhereWithoutAuthorInput = {
    where: QueryScalarWhereInput
    data: XOR<QueryUpdateManyMutationInput, QueryUncheckedUpdateManyWithoutAuthorInput>
  }

  export type QueryScalarWhereInput = {
    AND?: QueryScalarWhereInput | QueryScalarWhereInput[]
    OR?: QueryScalarWhereInput[]
    NOT?: QueryScalarWhereInput | QueryScalarWhereInput[]
    id?: StringFilter<"Query"> | string
    projectId?: StringFilter<"Query"> | string
    authorId?: StringFilter<"Query"> | string
    title?: StringFilter<"Query"> | string
    description?: StringFilter<"Query"> | string
    status?: EnumQueryStatusFilter<"Query"> | $Enums.QueryStatus
    priority?: EnumQueryPriorityFilter<"Query"> | $Enums.QueryPriority
    createdAt?: DateTimeFilter<"Query"> | Date | string
    updatedAt?: DateTimeFilter<"Query"> | Date | string
  }

  export type QueryResponseUpsertWithWhereUniqueWithoutAuthorInput = {
    where: QueryResponseWhereUniqueInput
    update: XOR<QueryResponseUpdateWithoutAuthorInput, QueryResponseUncheckedUpdateWithoutAuthorInput>
    create: XOR<QueryResponseCreateWithoutAuthorInput, QueryResponseUncheckedCreateWithoutAuthorInput>
  }

  export type QueryResponseUpdateWithWhereUniqueWithoutAuthorInput = {
    where: QueryResponseWhereUniqueInput
    data: XOR<QueryResponseUpdateWithoutAuthorInput, QueryResponseUncheckedUpdateWithoutAuthorInput>
  }

  export type QueryResponseUpdateManyWithWhereWithoutAuthorInput = {
    where: QueryResponseScalarWhereInput
    data: XOR<QueryResponseUpdateManyMutationInput, QueryResponseUncheckedUpdateManyWithoutAuthorInput>
  }

  export type QueryResponseScalarWhereInput = {
    AND?: QueryResponseScalarWhereInput | QueryResponseScalarWhereInput[]
    OR?: QueryResponseScalarWhereInput[]
    NOT?: QueryResponseScalarWhereInput | QueryResponseScalarWhereInput[]
    id?: StringFilter<"QueryResponse"> | string
    queryId?: StringFilter<"QueryResponse"> | string
    authorId?: StringFilter<"QueryResponse"> | string
    message?: StringFilter<"QueryResponse"> | string
    createdAt?: DateTimeFilter<"QueryResponse"> | Date | string
  }

  export type AuditLogUpsertWithWhereUniqueWithoutUserInput = {
    where: AuditLogWhereUniqueInput
    update: XOR<AuditLogUpdateWithoutUserInput, AuditLogUncheckedUpdateWithoutUserInput>
    create: XOR<AuditLogCreateWithoutUserInput, AuditLogUncheckedCreateWithoutUserInput>
  }

  export type AuditLogUpdateWithWhereUniqueWithoutUserInput = {
    where: AuditLogWhereUniqueInput
    data: XOR<AuditLogUpdateWithoutUserInput, AuditLogUncheckedUpdateWithoutUserInput>
  }

  export type AuditLogUpdateManyWithWhereWithoutUserInput = {
    where: AuditLogScalarWhereInput
    data: XOR<AuditLogUpdateManyMutationInput, AuditLogUncheckedUpdateManyWithoutUserInput>
  }

  export type AuditLogScalarWhereInput = {
    AND?: AuditLogScalarWhereInput | AuditLogScalarWhereInput[]
    OR?: AuditLogScalarWhereInput[]
    NOT?: AuditLogScalarWhereInput | AuditLogScalarWhereInput[]
    id?: StringFilter<"AuditLog"> | string
    userId?: StringFilter<"AuditLog"> | string
    action?: StringFilter<"AuditLog"> | string
    entity?: StringFilter<"AuditLog"> | string
    entityId?: StringFilter<"AuditLog"> | string
    projectId?: StringNullableFilter<"AuditLog"> | string | null
    metadata?: JsonNullableFilter<"AuditLog">
    createdAt?: DateTimeFilter<"AuditLog"> | Date | string
  }

  export type NotificationPreferenceUpsertWithoutUserInput = {
    update: XOR<NotificationPreferenceUpdateWithoutUserInput, NotificationPreferenceUncheckedUpdateWithoutUserInput>
    create: XOR<NotificationPreferenceCreateWithoutUserInput, NotificationPreferenceUncheckedCreateWithoutUserInput>
    where?: NotificationPreferenceWhereInput
  }

  export type NotificationPreferenceUpdateToOneWithWhereWithoutUserInput = {
    where?: NotificationPreferenceWhereInput
    data: XOR<NotificationPreferenceUpdateWithoutUserInput, NotificationPreferenceUncheckedUpdateWithoutUserInput>
  }

  export type NotificationPreferenceUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    inspectionSubmitted?: BoolFieldUpdateOperationsInput | boolean
    paymentOverdue?: BoolFieldUpdateOperationsInput | boolean
    newAssignment?: BoolFieldUpdateOperationsInput | boolean
    queryCreated?: BoolFieldUpdateOperationsInput | boolean
    drawingApproved?: BoolFieldUpdateOperationsInput | boolean
    emailEnabled?: BoolFieldUpdateOperationsInput | boolean
    inAppEnabled?: BoolFieldUpdateOperationsInput | boolean
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationPreferenceUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    inspectionSubmitted?: BoolFieldUpdateOperationsInput | boolean
    paymentOverdue?: BoolFieldUpdateOperationsInput | boolean
    newAssignment?: BoolFieldUpdateOperationsInput | boolean
    queryCreated?: BoolFieldUpdateOperationsInput | boolean
    drawingApproved?: BoolFieldUpdateOperationsInput | boolean
    emailEnabled?: BoolFieldUpdateOperationsInput | boolean
    inAppEnabled?: BoolFieldUpdateOperationsInput | boolean
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MaterialUpsertWithWhereUniqueWithoutCreatedByInput = {
    where: MaterialWhereUniqueInput
    update: XOR<MaterialUpdateWithoutCreatedByInput, MaterialUncheckedUpdateWithoutCreatedByInput>
    create: XOR<MaterialCreateWithoutCreatedByInput, MaterialUncheckedCreateWithoutCreatedByInput>
  }

  export type MaterialUpdateWithWhereUniqueWithoutCreatedByInput = {
    where: MaterialWhereUniqueInput
    data: XOR<MaterialUpdateWithoutCreatedByInput, MaterialUncheckedUpdateWithoutCreatedByInput>
  }

  export type MaterialUpdateManyWithWhereWithoutCreatedByInput = {
    where: MaterialScalarWhereInput
    data: XOR<MaterialUpdateManyMutationInput, MaterialUncheckedUpdateManyWithoutCreatedByInput>
  }

  export type MaterialScalarWhereInput = {
    AND?: MaterialScalarWhereInput | MaterialScalarWhereInput[]
    OR?: MaterialScalarWhereInput[]
    NOT?: MaterialScalarWhereInput | MaterialScalarWhereInput[]
    id?: StringFilter<"Material"> | string
    projectId?: StringFilter<"Material"> | string
    name?: StringFilter<"Material"> | string
    quantity?: FloatFilter<"Material"> | number
    unit?: StringFilter<"Material"> | string
    unitCost?: FloatFilter<"Material"> | number
    totalCost?: FloatFilter<"Material"> | number
    supplier?: StringNullableFilter<"Material"> | string | null
    status?: EnumMaterialStatusFilter<"Material"> | $Enums.MaterialStatus
    createdById?: StringFilter<"Material"> | string
    createdAt?: DateTimeFilter<"Material"> | Date | string
    updatedAt?: DateTimeFilter<"Material"> | Date | string
  }

  export type UserCreateWithoutProjectsCreatedInput = {
    id?: string
    name: string
    email: string
    passwordHash: string
    role: $Enums.Role
    isActive?: boolean
    createdAt?: Date | string
    phone?: string | null
    designation?: string | null
    createdBy?: UserCreateNestedOneWithoutCreatedUsersInput
    createdUsers?: UserCreateNestedManyWithoutCreatedByInput
    managedProjects?: ProjectCreateNestedManyWithoutManagerInput
    clientProjects?: ProjectCreateNestedManyWithoutClientInput
    projectMembers?: ProjectMemberCreateNestedManyWithoutUserInput
    projectUpdates?: ProjectUpdateCreateNestedManyWithoutAuthorInput
    media?: MediaCreateNestedManyWithoutCreatedByInput
    paymentsCreated?: PaymentCreateNestedManyWithoutCreatedByInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    inspections?: InspectionCreateNestedManyWithoutEngineerInput
    reviewedInspections?: InspectionCreateNestedManyWithoutReviewedByInput
    queries?: QueryCreateNestedManyWithoutAuthorInput
    queryResponses?: QueryResponseCreateNestedManyWithoutAuthorInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
    notificationPrefs?: NotificationPreferenceCreateNestedOneWithoutUserInput
    materialsCreated?: MaterialCreateNestedManyWithoutCreatedByInput
  }

  export type UserUncheckedCreateWithoutProjectsCreatedInput = {
    id?: string
    name: string
    email: string
    passwordHash: string
    role: $Enums.Role
    isActive?: boolean
    createdById?: string | null
    createdAt?: Date | string
    phone?: string | null
    designation?: string | null
    createdUsers?: UserUncheckedCreateNestedManyWithoutCreatedByInput
    managedProjects?: ProjectUncheckedCreateNestedManyWithoutManagerInput
    clientProjects?: ProjectUncheckedCreateNestedManyWithoutClientInput
    projectMembers?: ProjectMemberUncheckedCreateNestedManyWithoutUserInput
    projectUpdates?: ProjectUpdateUncheckedCreateNestedManyWithoutAuthorInput
    media?: MediaUncheckedCreateNestedManyWithoutCreatedByInput
    paymentsCreated?: PaymentUncheckedCreateNestedManyWithoutCreatedByInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    inspections?: InspectionUncheckedCreateNestedManyWithoutEngineerInput
    reviewedInspections?: InspectionUncheckedCreateNestedManyWithoutReviewedByInput
    queries?: QueryUncheckedCreateNestedManyWithoutAuthorInput
    queryResponses?: QueryResponseUncheckedCreateNestedManyWithoutAuthorInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    notificationPrefs?: NotificationPreferenceUncheckedCreateNestedOneWithoutUserInput
    materialsCreated?: MaterialUncheckedCreateNestedManyWithoutCreatedByInput
  }

  export type UserCreateOrConnectWithoutProjectsCreatedInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutProjectsCreatedInput, UserUncheckedCreateWithoutProjectsCreatedInput>
  }

  export type UserCreateWithoutManagedProjectsInput = {
    id?: string
    name: string
    email: string
    passwordHash: string
    role: $Enums.Role
    isActive?: boolean
    createdAt?: Date | string
    phone?: string | null
    designation?: string | null
    createdBy?: UserCreateNestedOneWithoutCreatedUsersInput
    createdUsers?: UserCreateNestedManyWithoutCreatedByInput
    clientProjects?: ProjectCreateNestedManyWithoutClientInput
    projectMembers?: ProjectMemberCreateNestedManyWithoutUserInput
    projectUpdates?: ProjectUpdateCreateNestedManyWithoutAuthorInput
    media?: MediaCreateNestedManyWithoutCreatedByInput
    paymentsCreated?: PaymentCreateNestedManyWithoutCreatedByInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    projectsCreated?: ProjectCreateNestedManyWithoutCreatedByInput
    inspections?: InspectionCreateNestedManyWithoutEngineerInput
    reviewedInspections?: InspectionCreateNestedManyWithoutReviewedByInput
    queries?: QueryCreateNestedManyWithoutAuthorInput
    queryResponses?: QueryResponseCreateNestedManyWithoutAuthorInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
    notificationPrefs?: NotificationPreferenceCreateNestedOneWithoutUserInput
    materialsCreated?: MaterialCreateNestedManyWithoutCreatedByInput
  }

  export type UserUncheckedCreateWithoutManagedProjectsInput = {
    id?: string
    name: string
    email: string
    passwordHash: string
    role: $Enums.Role
    isActive?: boolean
    createdById?: string | null
    createdAt?: Date | string
    phone?: string | null
    designation?: string | null
    createdUsers?: UserUncheckedCreateNestedManyWithoutCreatedByInput
    clientProjects?: ProjectUncheckedCreateNestedManyWithoutClientInput
    projectMembers?: ProjectMemberUncheckedCreateNestedManyWithoutUserInput
    projectUpdates?: ProjectUpdateUncheckedCreateNestedManyWithoutAuthorInput
    media?: MediaUncheckedCreateNestedManyWithoutCreatedByInput
    paymentsCreated?: PaymentUncheckedCreateNestedManyWithoutCreatedByInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    projectsCreated?: ProjectUncheckedCreateNestedManyWithoutCreatedByInput
    inspections?: InspectionUncheckedCreateNestedManyWithoutEngineerInput
    reviewedInspections?: InspectionUncheckedCreateNestedManyWithoutReviewedByInput
    queries?: QueryUncheckedCreateNestedManyWithoutAuthorInput
    queryResponses?: QueryResponseUncheckedCreateNestedManyWithoutAuthorInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    notificationPrefs?: NotificationPreferenceUncheckedCreateNestedOneWithoutUserInput
    materialsCreated?: MaterialUncheckedCreateNestedManyWithoutCreatedByInput
  }

  export type UserCreateOrConnectWithoutManagedProjectsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutManagedProjectsInput, UserUncheckedCreateWithoutManagedProjectsInput>
  }

  export type UserCreateWithoutClientProjectsInput = {
    id?: string
    name: string
    email: string
    passwordHash: string
    role: $Enums.Role
    isActive?: boolean
    createdAt?: Date | string
    phone?: string | null
    designation?: string | null
    createdBy?: UserCreateNestedOneWithoutCreatedUsersInput
    createdUsers?: UserCreateNestedManyWithoutCreatedByInput
    managedProjects?: ProjectCreateNestedManyWithoutManagerInput
    projectMembers?: ProjectMemberCreateNestedManyWithoutUserInput
    projectUpdates?: ProjectUpdateCreateNestedManyWithoutAuthorInput
    media?: MediaCreateNestedManyWithoutCreatedByInput
    paymentsCreated?: PaymentCreateNestedManyWithoutCreatedByInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    projectsCreated?: ProjectCreateNestedManyWithoutCreatedByInput
    inspections?: InspectionCreateNestedManyWithoutEngineerInput
    reviewedInspections?: InspectionCreateNestedManyWithoutReviewedByInput
    queries?: QueryCreateNestedManyWithoutAuthorInput
    queryResponses?: QueryResponseCreateNestedManyWithoutAuthorInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
    notificationPrefs?: NotificationPreferenceCreateNestedOneWithoutUserInput
    materialsCreated?: MaterialCreateNestedManyWithoutCreatedByInput
  }

  export type UserUncheckedCreateWithoutClientProjectsInput = {
    id?: string
    name: string
    email: string
    passwordHash: string
    role: $Enums.Role
    isActive?: boolean
    createdById?: string | null
    createdAt?: Date | string
    phone?: string | null
    designation?: string | null
    createdUsers?: UserUncheckedCreateNestedManyWithoutCreatedByInput
    managedProjects?: ProjectUncheckedCreateNestedManyWithoutManagerInput
    projectMembers?: ProjectMemberUncheckedCreateNestedManyWithoutUserInput
    projectUpdates?: ProjectUpdateUncheckedCreateNestedManyWithoutAuthorInput
    media?: MediaUncheckedCreateNestedManyWithoutCreatedByInput
    paymentsCreated?: PaymentUncheckedCreateNestedManyWithoutCreatedByInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    projectsCreated?: ProjectUncheckedCreateNestedManyWithoutCreatedByInput
    inspections?: InspectionUncheckedCreateNestedManyWithoutEngineerInput
    reviewedInspections?: InspectionUncheckedCreateNestedManyWithoutReviewedByInput
    queries?: QueryUncheckedCreateNestedManyWithoutAuthorInput
    queryResponses?: QueryResponseUncheckedCreateNestedManyWithoutAuthorInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    notificationPrefs?: NotificationPreferenceUncheckedCreateNestedOneWithoutUserInput
    materialsCreated?: MaterialUncheckedCreateNestedManyWithoutCreatedByInput
  }

  export type UserCreateOrConnectWithoutClientProjectsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutClientProjectsInput, UserUncheckedCreateWithoutClientProjectsInput>
  }

  export type ProjectMemberCreateWithoutProjectInput = {
    id?: string
    role: $Enums.ProjectMemberRole
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutProjectMembersInput
  }

  export type ProjectMemberUncheckedCreateWithoutProjectInput = {
    id?: string
    userId: string
    role: $Enums.ProjectMemberRole
    createdAt?: Date | string
  }

  export type ProjectMemberCreateOrConnectWithoutProjectInput = {
    where: ProjectMemberWhereUniqueInput
    create: XOR<ProjectMemberCreateWithoutProjectInput, ProjectMemberUncheckedCreateWithoutProjectInput>
  }

  export type ProjectMemberCreateManyProjectInputEnvelope = {
    data: ProjectMemberCreateManyProjectInput | ProjectMemberCreateManyProjectInput[]
    skipDuplicates?: boolean
  }

  export type ProjectUpdateCreateWithoutProjectInput = {
    id?: string
    notes: string
    statusSnapshot?: string | null
    createdAt?: Date | string
    author: UserCreateNestedOneWithoutProjectUpdatesInput
    media?: MediaCreateNestedManyWithoutProjectUpdateInput
  }

  export type ProjectUpdateUncheckedCreateWithoutProjectInput = {
    id?: string
    authorId: string
    notes: string
    statusSnapshot?: string | null
    createdAt?: Date | string
    media?: MediaUncheckedCreateNestedManyWithoutProjectUpdateInput
  }

  export type ProjectUpdateCreateOrConnectWithoutProjectInput = {
    where: ProjectUpdateWhereUniqueInput
    create: XOR<ProjectUpdateCreateWithoutProjectInput, ProjectUpdateUncheckedCreateWithoutProjectInput>
  }

  export type ProjectUpdateCreateManyProjectInputEnvelope = {
    data: ProjectUpdateCreateManyProjectInput | ProjectUpdateCreateManyProjectInput[]
    skipDuplicates?: boolean
  }

  export type MediaCreateWithoutProjectInput = {
    id?: string
    type: $Enums.MediaType
    fileKey: string
    fileUrl: string
    mimeType: string
    fileSize: number
    approvedBy?: string | null
    approvedAt?: Date | string | null
    version?: number | null
    createdAt?: Date | string
    projectUpdate?: ProjectUpdateCreateNestedOneWithoutMediaInput
    payment?: PaymentCreateNestedOneWithoutMediaInput
    createdBy: UserCreateNestedOneWithoutMediaInput
    inspectionResponses?: InspectionResponseCreateNestedManyWithoutMediaInput
    query?: QueryCreateNestedOneWithoutAttachmentsInput
  }

  export type MediaUncheckedCreateWithoutProjectInput = {
    id?: string
    projectUpdateId?: string | null
    paymentId?: string | null
    type: $Enums.MediaType
    fileKey: string
    fileUrl: string
    mimeType: string
    fileSize: number
    createdById: string
    approvedBy?: string | null
    approvedAt?: Date | string | null
    version?: number | null
    createdAt?: Date | string
    queryId?: string | null
    inspectionResponses?: InspectionResponseUncheckedCreateNestedManyWithoutMediaInput
  }

  export type MediaCreateOrConnectWithoutProjectInput = {
    where: MediaWhereUniqueInput
    create: XOR<MediaCreateWithoutProjectInput, MediaUncheckedCreateWithoutProjectInput>
  }

  export type MediaCreateManyProjectInputEnvelope = {
    data: MediaCreateManyProjectInput | MediaCreateManyProjectInput[]
    skipDuplicates?: boolean
  }

  export type PaymentCreateWithoutProjectInput = {
    id?: string
    amount: Decimal | DecimalJsLike | number | string
    currency?: string
    status?: $Enums.PaymentStatus
    category?: $Enums.PaymentCategory | null
    invoiceNumber?: string | null
    paidAt?: Date | string | null
    dueDate?: Date | string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy: UserCreateNestedOneWithoutPaymentsCreatedInput
    media?: MediaCreateNestedManyWithoutPaymentInput
  }

  export type PaymentUncheckedCreateWithoutProjectInput = {
    id?: string
    createdById: string
    amount: Decimal | DecimalJsLike | number | string
    currency?: string
    status?: $Enums.PaymentStatus
    category?: $Enums.PaymentCategory | null
    invoiceNumber?: string | null
    paidAt?: Date | string | null
    dueDate?: Date | string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    media?: MediaUncheckedCreateNestedManyWithoutPaymentInput
  }

  export type PaymentCreateOrConnectWithoutProjectInput = {
    where: PaymentWhereUniqueInput
    create: XOR<PaymentCreateWithoutProjectInput, PaymentUncheckedCreateWithoutProjectInput>
  }

  export type PaymentCreateManyProjectInputEnvelope = {
    data: PaymentCreateManyProjectInput | PaymentCreateManyProjectInput[]
    skipDuplicates?: boolean
  }

  export type MilestoneCreateWithoutProjectInput = {
    id?: string
    name: string
    description?: string | null
    order: number
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    checklistItems?: ChecklistItemCreateNestedManyWithoutMilestoneInput
    inspections?: InspectionCreateNestedManyWithoutMilestoneInput
  }

  export type MilestoneUncheckedCreateWithoutProjectInput = {
    id?: string
    name: string
    description?: string | null
    order: number
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    checklistItems?: ChecklistItemUncheckedCreateNestedManyWithoutMilestoneInput
    inspections?: InspectionUncheckedCreateNestedManyWithoutMilestoneInput
  }

  export type MilestoneCreateOrConnectWithoutProjectInput = {
    where: MilestoneWhereUniqueInput
    create: XOR<MilestoneCreateWithoutProjectInput, MilestoneUncheckedCreateWithoutProjectInput>
  }

  export type MilestoneCreateManyProjectInputEnvelope = {
    data: MilestoneCreateManyProjectInput | MilestoneCreateManyProjectInput[]
    skipDuplicates?: boolean
  }

  export type InspectionCreateWithoutProjectInput = {
    id?: string
    status?: $Enums.InspectionStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    milestone: MilestoneCreateNestedOneWithoutInspectionsInput
    engineer: UserCreateNestedOneWithoutInspectionsInput
    responses?: InspectionResponseCreateNestedManyWithoutInspectionInput
    reviewedBy?: UserCreateNestedOneWithoutReviewedInspectionsInput
  }

  export type InspectionUncheckedCreateWithoutProjectInput = {
    id?: string
    status?: $Enums.InspectionStatus
    milestoneId: string
    engineerId: string
    reviewedById?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    responses?: InspectionResponseUncheckedCreateNestedManyWithoutInspectionInput
  }

  export type InspectionCreateOrConnectWithoutProjectInput = {
    where: InspectionWhereUniqueInput
    create: XOR<InspectionCreateWithoutProjectInput, InspectionUncheckedCreateWithoutProjectInput>
  }

  export type InspectionCreateManyProjectInputEnvelope = {
    data: InspectionCreateManyProjectInput | InspectionCreateManyProjectInput[]
    skipDuplicates?: boolean
  }

  export type QueryCreateWithoutProjectInput = {
    id?: string
    title: string
    description: string
    status?: $Enums.QueryStatus
    priority?: $Enums.QueryPriority
    createdAt?: Date | string
    updatedAt?: Date | string
    author: UserCreateNestedOneWithoutQueriesInput
    attachments?: MediaCreateNestedManyWithoutQueryInput
    responses?: QueryResponseCreateNestedManyWithoutQueryInput
  }

  export type QueryUncheckedCreateWithoutProjectInput = {
    id?: string
    authorId: string
    title: string
    description: string
    status?: $Enums.QueryStatus
    priority?: $Enums.QueryPriority
    createdAt?: Date | string
    updatedAt?: Date | string
    attachments?: MediaUncheckedCreateNestedManyWithoutQueryInput
    responses?: QueryResponseUncheckedCreateNestedManyWithoutQueryInput
  }

  export type QueryCreateOrConnectWithoutProjectInput = {
    where: QueryWhereUniqueInput
    create: XOR<QueryCreateWithoutProjectInput, QueryUncheckedCreateWithoutProjectInput>
  }

  export type QueryCreateManyProjectInputEnvelope = {
    data: QueryCreateManyProjectInput | QueryCreateManyProjectInput[]
    skipDuplicates?: boolean
  }

  export type MaterialCreateWithoutProjectInput = {
    id?: string
    name: string
    quantity: number
    unit: string
    unitCost: number
    totalCost: number
    supplier?: string | null
    status?: $Enums.MaterialStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy: UserCreateNestedOneWithoutMaterialsCreatedInput
  }

  export type MaterialUncheckedCreateWithoutProjectInput = {
    id?: string
    name: string
    quantity: number
    unit: string
    unitCost: number
    totalCost: number
    supplier?: string | null
    status?: $Enums.MaterialStatus
    createdById: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MaterialCreateOrConnectWithoutProjectInput = {
    where: MaterialWhereUniqueInput
    create: XOR<MaterialCreateWithoutProjectInput, MaterialUncheckedCreateWithoutProjectInput>
  }

  export type MaterialCreateManyProjectInputEnvelope = {
    data: MaterialCreateManyProjectInput | MaterialCreateManyProjectInput[]
    skipDuplicates?: boolean
  }

  export type AuditLogCreateWithoutProjectInput = {
    id?: string
    action: string
    entity: string
    entityId: string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutAuditLogsInput
  }

  export type AuditLogUncheckedCreateWithoutProjectInput = {
    id?: string
    userId: string
    action: string
    entity: string
    entityId: string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type AuditLogCreateOrConnectWithoutProjectInput = {
    where: AuditLogWhereUniqueInput
    create: XOR<AuditLogCreateWithoutProjectInput, AuditLogUncheckedCreateWithoutProjectInput>
  }

  export type AuditLogCreateManyProjectInputEnvelope = {
    data: AuditLogCreateManyProjectInput | AuditLogCreateManyProjectInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutProjectsCreatedInput = {
    update: XOR<UserUpdateWithoutProjectsCreatedInput, UserUncheckedUpdateWithoutProjectsCreatedInput>
    create: XOR<UserCreateWithoutProjectsCreatedInput, UserUncheckedCreateWithoutProjectsCreatedInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutProjectsCreatedInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutProjectsCreatedInput, UserUncheckedUpdateWithoutProjectsCreatedInput>
  }

  export type UserUpdateWithoutProjectsCreatedInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    designation?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: UserUpdateOneWithoutCreatedUsersNestedInput
    createdUsers?: UserUpdateManyWithoutCreatedByNestedInput
    managedProjects?: ProjectUpdateManyWithoutManagerNestedInput
    clientProjects?: ProjectUpdateManyWithoutClientNestedInput
    projectMembers?: ProjectMemberUpdateManyWithoutUserNestedInput
    projectUpdates?: ProjectUpdateUpdateManyWithoutAuthorNestedInput
    media?: MediaUpdateManyWithoutCreatedByNestedInput
    paymentsCreated?: PaymentUpdateManyWithoutCreatedByNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    inspections?: InspectionUpdateManyWithoutEngineerNestedInput
    reviewedInspections?: InspectionUpdateManyWithoutReviewedByNestedInput
    queries?: QueryUpdateManyWithoutAuthorNestedInput
    queryResponses?: QueryResponseUpdateManyWithoutAuthorNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
    notificationPrefs?: NotificationPreferenceUpdateOneWithoutUserNestedInput
    materialsCreated?: MaterialUpdateManyWithoutCreatedByNestedInput
  }

  export type UserUncheckedUpdateWithoutProjectsCreatedInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    designation?: NullableStringFieldUpdateOperationsInput | string | null
    createdUsers?: UserUncheckedUpdateManyWithoutCreatedByNestedInput
    managedProjects?: ProjectUncheckedUpdateManyWithoutManagerNestedInput
    clientProjects?: ProjectUncheckedUpdateManyWithoutClientNestedInput
    projectMembers?: ProjectMemberUncheckedUpdateManyWithoutUserNestedInput
    projectUpdates?: ProjectUpdateUncheckedUpdateManyWithoutAuthorNestedInput
    media?: MediaUncheckedUpdateManyWithoutCreatedByNestedInput
    paymentsCreated?: PaymentUncheckedUpdateManyWithoutCreatedByNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    inspections?: InspectionUncheckedUpdateManyWithoutEngineerNestedInput
    reviewedInspections?: InspectionUncheckedUpdateManyWithoutReviewedByNestedInput
    queries?: QueryUncheckedUpdateManyWithoutAuthorNestedInput
    queryResponses?: QueryResponseUncheckedUpdateManyWithoutAuthorNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    notificationPrefs?: NotificationPreferenceUncheckedUpdateOneWithoutUserNestedInput
    materialsCreated?: MaterialUncheckedUpdateManyWithoutCreatedByNestedInput
  }

  export type UserUpsertWithoutManagedProjectsInput = {
    update: XOR<UserUpdateWithoutManagedProjectsInput, UserUncheckedUpdateWithoutManagedProjectsInput>
    create: XOR<UserCreateWithoutManagedProjectsInput, UserUncheckedCreateWithoutManagedProjectsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutManagedProjectsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutManagedProjectsInput, UserUncheckedUpdateWithoutManagedProjectsInput>
  }

  export type UserUpdateWithoutManagedProjectsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    designation?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: UserUpdateOneWithoutCreatedUsersNestedInput
    createdUsers?: UserUpdateManyWithoutCreatedByNestedInput
    clientProjects?: ProjectUpdateManyWithoutClientNestedInput
    projectMembers?: ProjectMemberUpdateManyWithoutUserNestedInput
    projectUpdates?: ProjectUpdateUpdateManyWithoutAuthorNestedInput
    media?: MediaUpdateManyWithoutCreatedByNestedInput
    paymentsCreated?: PaymentUpdateManyWithoutCreatedByNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    projectsCreated?: ProjectUpdateManyWithoutCreatedByNestedInput
    inspections?: InspectionUpdateManyWithoutEngineerNestedInput
    reviewedInspections?: InspectionUpdateManyWithoutReviewedByNestedInput
    queries?: QueryUpdateManyWithoutAuthorNestedInput
    queryResponses?: QueryResponseUpdateManyWithoutAuthorNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
    notificationPrefs?: NotificationPreferenceUpdateOneWithoutUserNestedInput
    materialsCreated?: MaterialUpdateManyWithoutCreatedByNestedInput
  }

  export type UserUncheckedUpdateWithoutManagedProjectsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    designation?: NullableStringFieldUpdateOperationsInput | string | null
    createdUsers?: UserUncheckedUpdateManyWithoutCreatedByNestedInput
    clientProjects?: ProjectUncheckedUpdateManyWithoutClientNestedInput
    projectMembers?: ProjectMemberUncheckedUpdateManyWithoutUserNestedInput
    projectUpdates?: ProjectUpdateUncheckedUpdateManyWithoutAuthorNestedInput
    media?: MediaUncheckedUpdateManyWithoutCreatedByNestedInput
    paymentsCreated?: PaymentUncheckedUpdateManyWithoutCreatedByNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    projectsCreated?: ProjectUncheckedUpdateManyWithoutCreatedByNestedInput
    inspections?: InspectionUncheckedUpdateManyWithoutEngineerNestedInput
    reviewedInspections?: InspectionUncheckedUpdateManyWithoutReviewedByNestedInput
    queries?: QueryUncheckedUpdateManyWithoutAuthorNestedInput
    queryResponses?: QueryResponseUncheckedUpdateManyWithoutAuthorNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    notificationPrefs?: NotificationPreferenceUncheckedUpdateOneWithoutUserNestedInput
    materialsCreated?: MaterialUncheckedUpdateManyWithoutCreatedByNestedInput
  }

  export type UserUpsertWithoutClientProjectsInput = {
    update: XOR<UserUpdateWithoutClientProjectsInput, UserUncheckedUpdateWithoutClientProjectsInput>
    create: XOR<UserCreateWithoutClientProjectsInput, UserUncheckedCreateWithoutClientProjectsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutClientProjectsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutClientProjectsInput, UserUncheckedUpdateWithoutClientProjectsInput>
  }

  export type UserUpdateWithoutClientProjectsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    designation?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: UserUpdateOneWithoutCreatedUsersNestedInput
    createdUsers?: UserUpdateManyWithoutCreatedByNestedInput
    managedProjects?: ProjectUpdateManyWithoutManagerNestedInput
    projectMembers?: ProjectMemberUpdateManyWithoutUserNestedInput
    projectUpdates?: ProjectUpdateUpdateManyWithoutAuthorNestedInput
    media?: MediaUpdateManyWithoutCreatedByNestedInput
    paymentsCreated?: PaymentUpdateManyWithoutCreatedByNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    projectsCreated?: ProjectUpdateManyWithoutCreatedByNestedInput
    inspections?: InspectionUpdateManyWithoutEngineerNestedInput
    reviewedInspections?: InspectionUpdateManyWithoutReviewedByNestedInput
    queries?: QueryUpdateManyWithoutAuthorNestedInput
    queryResponses?: QueryResponseUpdateManyWithoutAuthorNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
    notificationPrefs?: NotificationPreferenceUpdateOneWithoutUserNestedInput
    materialsCreated?: MaterialUpdateManyWithoutCreatedByNestedInput
  }

  export type UserUncheckedUpdateWithoutClientProjectsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    designation?: NullableStringFieldUpdateOperationsInput | string | null
    createdUsers?: UserUncheckedUpdateManyWithoutCreatedByNestedInput
    managedProjects?: ProjectUncheckedUpdateManyWithoutManagerNestedInput
    projectMembers?: ProjectMemberUncheckedUpdateManyWithoutUserNestedInput
    projectUpdates?: ProjectUpdateUncheckedUpdateManyWithoutAuthorNestedInput
    media?: MediaUncheckedUpdateManyWithoutCreatedByNestedInput
    paymentsCreated?: PaymentUncheckedUpdateManyWithoutCreatedByNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    projectsCreated?: ProjectUncheckedUpdateManyWithoutCreatedByNestedInput
    inspections?: InspectionUncheckedUpdateManyWithoutEngineerNestedInput
    reviewedInspections?: InspectionUncheckedUpdateManyWithoutReviewedByNestedInput
    queries?: QueryUncheckedUpdateManyWithoutAuthorNestedInput
    queryResponses?: QueryResponseUncheckedUpdateManyWithoutAuthorNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    notificationPrefs?: NotificationPreferenceUncheckedUpdateOneWithoutUserNestedInput
    materialsCreated?: MaterialUncheckedUpdateManyWithoutCreatedByNestedInput
  }

  export type ProjectMemberUpsertWithWhereUniqueWithoutProjectInput = {
    where: ProjectMemberWhereUniqueInput
    update: XOR<ProjectMemberUpdateWithoutProjectInput, ProjectMemberUncheckedUpdateWithoutProjectInput>
    create: XOR<ProjectMemberCreateWithoutProjectInput, ProjectMemberUncheckedCreateWithoutProjectInput>
  }

  export type ProjectMemberUpdateWithWhereUniqueWithoutProjectInput = {
    where: ProjectMemberWhereUniqueInput
    data: XOR<ProjectMemberUpdateWithoutProjectInput, ProjectMemberUncheckedUpdateWithoutProjectInput>
  }

  export type ProjectMemberUpdateManyWithWhereWithoutProjectInput = {
    where: ProjectMemberScalarWhereInput
    data: XOR<ProjectMemberUpdateManyMutationInput, ProjectMemberUncheckedUpdateManyWithoutProjectInput>
  }

  export type ProjectUpdateUpsertWithWhereUniqueWithoutProjectInput = {
    where: ProjectUpdateWhereUniqueInput
    update: XOR<ProjectUpdateUpdateWithoutProjectInput, ProjectUpdateUncheckedUpdateWithoutProjectInput>
    create: XOR<ProjectUpdateCreateWithoutProjectInput, ProjectUpdateUncheckedCreateWithoutProjectInput>
  }

  export type ProjectUpdateUpdateWithWhereUniqueWithoutProjectInput = {
    where: ProjectUpdateWhereUniqueInput
    data: XOR<ProjectUpdateUpdateWithoutProjectInput, ProjectUpdateUncheckedUpdateWithoutProjectInput>
  }

  export type ProjectUpdateUpdateManyWithWhereWithoutProjectInput = {
    where: ProjectUpdateScalarWhereInput
    data: XOR<ProjectUpdateUpdateManyMutationInput, ProjectUpdateUncheckedUpdateManyWithoutProjectInput>
  }

  export type MediaUpsertWithWhereUniqueWithoutProjectInput = {
    where: MediaWhereUniqueInput
    update: XOR<MediaUpdateWithoutProjectInput, MediaUncheckedUpdateWithoutProjectInput>
    create: XOR<MediaCreateWithoutProjectInput, MediaUncheckedCreateWithoutProjectInput>
  }

  export type MediaUpdateWithWhereUniqueWithoutProjectInput = {
    where: MediaWhereUniqueInput
    data: XOR<MediaUpdateWithoutProjectInput, MediaUncheckedUpdateWithoutProjectInput>
  }

  export type MediaUpdateManyWithWhereWithoutProjectInput = {
    where: MediaScalarWhereInput
    data: XOR<MediaUpdateManyMutationInput, MediaUncheckedUpdateManyWithoutProjectInput>
  }

  export type PaymentUpsertWithWhereUniqueWithoutProjectInput = {
    where: PaymentWhereUniqueInput
    update: XOR<PaymentUpdateWithoutProjectInput, PaymentUncheckedUpdateWithoutProjectInput>
    create: XOR<PaymentCreateWithoutProjectInput, PaymentUncheckedCreateWithoutProjectInput>
  }

  export type PaymentUpdateWithWhereUniqueWithoutProjectInput = {
    where: PaymentWhereUniqueInput
    data: XOR<PaymentUpdateWithoutProjectInput, PaymentUncheckedUpdateWithoutProjectInput>
  }

  export type PaymentUpdateManyWithWhereWithoutProjectInput = {
    where: PaymentScalarWhereInput
    data: XOR<PaymentUpdateManyMutationInput, PaymentUncheckedUpdateManyWithoutProjectInput>
  }

  export type MilestoneUpsertWithWhereUniqueWithoutProjectInput = {
    where: MilestoneWhereUniqueInput
    update: XOR<MilestoneUpdateWithoutProjectInput, MilestoneUncheckedUpdateWithoutProjectInput>
    create: XOR<MilestoneCreateWithoutProjectInput, MilestoneUncheckedCreateWithoutProjectInput>
  }

  export type MilestoneUpdateWithWhereUniqueWithoutProjectInput = {
    where: MilestoneWhereUniqueInput
    data: XOR<MilestoneUpdateWithoutProjectInput, MilestoneUncheckedUpdateWithoutProjectInput>
  }

  export type MilestoneUpdateManyWithWhereWithoutProjectInput = {
    where: MilestoneScalarWhereInput
    data: XOR<MilestoneUpdateManyMutationInput, MilestoneUncheckedUpdateManyWithoutProjectInput>
  }

  export type MilestoneScalarWhereInput = {
    AND?: MilestoneScalarWhereInput | MilestoneScalarWhereInput[]
    OR?: MilestoneScalarWhereInput[]
    NOT?: MilestoneScalarWhereInput | MilestoneScalarWhereInput[]
    id?: StringFilter<"Milestone"> | string
    name?: StringFilter<"Milestone"> | string
    description?: StringNullableFilter<"Milestone"> | string | null
    order?: IntFilter<"Milestone"> | number
    isActive?: BoolFilter<"Milestone"> | boolean
    projectId?: StringFilter<"Milestone"> | string
    createdAt?: DateTimeFilter<"Milestone"> | Date | string
    updatedAt?: DateTimeFilter<"Milestone"> | Date | string
  }

  export type InspectionUpsertWithWhereUniqueWithoutProjectInput = {
    where: InspectionWhereUniqueInput
    update: XOR<InspectionUpdateWithoutProjectInput, InspectionUncheckedUpdateWithoutProjectInput>
    create: XOR<InspectionCreateWithoutProjectInput, InspectionUncheckedCreateWithoutProjectInput>
  }

  export type InspectionUpdateWithWhereUniqueWithoutProjectInput = {
    where: InspectionWhereUniqueInput
    data: XOR<InspectionUpdateWithoutProjectInput, InspectionUncheckedUpdateWithoutProjectInput>
  }

  export type InspectionUpdateManyWithWhereWithoutProjectInput = {
    where: InspectionScalarWhereInput
    data: XOR<InspectionUpdateManyMutationInput, InspectionUncheckedUpdateManyWithoutProjectInput>
  }

  export type QueryUpsertWithWhereUniqueWithoutProjectInput = {
    where: QueryWhereUniqueInput
    update: XOR<QueryUpdateWithoutProjectInput, QueryUncheckedUpdateWithoutProjectInput>
    create: XOR<QueryCreateWithoutProjectInput, QueryUncheckedCreateWithoutProjectInput>
  }

  export type QueryUpdateWithWhereUniqueWithoutProjectInput = {
    where: QueryWhereUniqueInput
    data: XOR<QueryUpdateWithoutProjectInput, QueryUncheckedUpdateWithoutProjectInput>
  }

  export type QueryUpdateManyWithWhereWithoutProjectInput = {
    where: QueryScalarWhereInput
    data: XOR<QueryUpdateManyMutationInput, QueryUncheckedUpdateManyWithoutProjectInput>
  }

  export type MaterialUpsertWithWhereUniqueWithoutProjectInput = {
    where: MaterialWhereUniqueInput
    update: XOR<MaterialUpdateWithoutProjectInput, MaterialUncheckedUpdateWithoutProjectInput>
    create: XOR<MaterialCreateWithoutProjectInput, MaterialUncheckedCreateWithoutProjectInput>
  }

  export type MaterialUpdateWithWhereUniqueWithoutProjectInput = {
    where: MaterialWhereUniqueInput
    data: XOR<MaterialUpdateWithoutProjectInput, MaterialUncheckedUpdateWithoutProjectInput>
  }

  export type MaterialUpdateManyWithWhereWithoutProjectInput = {
    where: MaterialScalarWhereInput
    data: XOR<MaterialUpdateManyMutationInput, MaterialUncheckedUpdateManyWithoutProjectInput>
  }

  export type AuditLogUpsertWithWhereUniqueWithoutProjectInput = {
    where: AuditLogWhereUniqueInput
    update: XOR<AuditLogUpdateWithoutProjectInput, AuditLogUncheckedUpdateWithoutProjectInput>
    create: XOR<AuditLogCreateWithoutProjectInput, AuditLogUncheckedCreateWithoutProjectInput>
  }

  export type AuditLogUpdateWithWhereUniqueWithoutProjectInput = {
    where: AuditLogWhereUniqueInput
    data: XOR<AuditLogUpdateWithoutProjectInput, AuditLogUncheckedUpdateWithoutProjectInput>
  }

  export type AuditLogUpdateManyWithWhereWithoutProjectInput = {
    where: AuditLogScalarWhereInput
    data: XOR<AuditLogUpdateManyMutationInput, AuditLogUncheckedUpdateManyWithoutProjectInput>
  }

  export type ProjectCreateWithoutMembersInput = {
    id?: string
    name: string
    description?: string | null
    status?: $Enums.ProjectStatus
    isArchived?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy: UserCreateNestedOneWithoutProjectsCreatedInput
    manager: UserCreateNestedOneWithoutManagedProjectsInput
    client: UserCreateNestedOneWithoutClientProjectsInput
    updates?: ProjectUpdateCreateNestedManyWithoutProjectInput
    media?: MediaCreateNestedManyWithoutProjectInput
    payments?: PaymentCreateNestedManyWithoutProjectInput
    milestones?: MilestoneCreateNestedManyWithoutProjectInput
    inspections?: InspectionCreateNestedManyWithoutProjectInput
    queries?: QueryCreateNestedManyWithoutProjectInput
    materials?: MaterialCreateNestedManyWithoutProjectInput
    auditLogs?: AuditLogCreateNestedManyWithoutProjectInput
  }

  export type ProjectUncheckedCreateWithoutMembersInput = {
    id?: string
    name: string
    description?: string | null
    status?: $Enums.ProjectStatus
    isArchived?: boolean
    createdById: string
    managerId: string
    clientId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    updates?: ProjectUpdateUncheckedCreateNestedManyWithoutProjectInput
    media?: MediaUncheckedCreateNestedManyWithoutProjectInput
    payments?: PaymentUncheckedCreateNestedManyWithoutProjectInput
    milestones?: MilestoneUncheckedCreateNestedManyWithoutProjectInput
    inspections?: InspectionUncheckedCreateNestedManyWithoutProjectInput
    queries?: QueryUncheckedCreateNestedManyWithoutProjectInput
    materials?: MaterialUncheckedCreateNestedManyWithoutProjectInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutProjectInput
  }

  export type ProjectCreateOrConnectWithoutMembersInput = {
    where: ProjectWhereUniqueInput
    create: XOR<ProjectCreateWithoutMembersInput, ProjectUncheckedCreateWithoutMembersInput>
  }

  export type UserCreateWithoutProjectMembersInput = {
    id?: string
    name: string
    email: string
    passwordHash: string
    role: $Enums.Role
    isActive?: boolean
    createdAt?: Date | string
    phone?: string | null
    designation?: string | null
    createdBy?: UserCreateNestedOneWithoutCreatedUsersInput
    createdUsers?: UserCreateNestedManyWithoutCreatedByInput
    managedProjects?: ProjectCreateNestedManyWithoutManagerInput
    clientProjects?: ProjectCreateNestedManyWithoutClientInput
    projectUpdates?: ProjectUpdateCreateNestedManyWithoutAuthorInput
    media?: MediaCreateNestedManyWithoutCreatedByInput
    paymentsCreated?: PaymentCreateNestedManyWithoutCreatedByInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    projectsCreated?: ProjectCreateNestedManyWithoutCreatedByInput
    inspections?: InspectionCreateNestedManyWithoutEngineerInput
    reviewedInspections?: InspectionCreateNestedManyWithoutReviewedByInput
    queries?: QueryCreateNestedManyWithoutAuthorInput
    queryResponses?: QueryResponseCreateNestedManyWithoutAuthorInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
    notificationPrefs?: NotificationPreferenceCreateNestedOneWithoutUserInput
    materialsCreated?: MaterialCreateNestedManyWithoutCreatedByInput
  }

  export type UserUncheckedCreateWithoutProjectMembersInput = {
    id?: string
    name: string
    email: string
    passwordHash: string
    role: $Enums.Role
    isActive?: boolean
    createdById?: string | null
    createdAt?: Date | string
    phone?: string | null
    designation?: string | null
    createdUsers?: UserUncheckedCreateNestedManyWithoutCreatedByInput
    managedProjects?: ProjectUncheckedCreateNestedManyWithoutManagerInput
    clientProjects?: ProjectUncheckedCreateNestedManyWithoutClientInput
    projectUpdates?: ProjectUpdateUncheckedCreateNestedManyWithoutAuthorInput
    media?: MediaUncheckedCreateNestedManyWithoutCreatedByInput
    paymentsCreated?: PaymentUncheckedCreateNestedManyWithoutCreatedByInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    projectsCreated?: ProjectUncheckedCreateNestedManyWithoutCreatedByInput
    inspections?: InspectionUncheckedCreateNestedManyWithoutEngineerInput
    reviewedInspections?: InspectionUncheckedCreateNestedManyWithoutReviewedByInput
    queries?: QueryUncheckedCreateNestedManyWithoutAuthorInput
    queryResponses?: QueryResponseUncheckedCreateNestedManyWithoutAuthorInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    notificationPrefs?: NotificationPreferenceUncheckedCreateNestedOneWithoutUserInput
    materialsCreated?: MaterialUncheckedCreateNestedManyWithoutCreatedByInput
  }

  export type UserCreateOrConnectWithoutProjectMembersInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutProjectMembersInput, UserUncheckedCreateWithoutProjectMembersInput>
  }

  export type ProjectUpsertWithoutMembersInput = {
    update: XOR<ProjectUpdateWithoutMembersInput, ProjectUncheckedUpdateWithoutMembersInput>
    create: XOR<ProjectCreateWithoutMembersInput, ProjectUncheckedCreateWithoutMembersInput>
    where?: ProjectWhereInput
  }

  export type ProjectUpdateToOneWithWhereWithoutMembersInput = {
    where?: ProjectWhereInput
    data: XOR<ProjectUpdateWithoutMembersInput, ProjectUncheckedUpdateWithoutMembersInput>
  }

  export type ProjectUpdateWithoutMembersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumProjectStatusFieldUpdateOperationsInput | $Enums.ProjectStatus
    isArchived?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: UserUpdateOneRequiredWithoutProjectsCreatedNestedInput
    manager?: UserUpdateOneRequiredWithoutManagedProjectsNestedInput
    client?: UserUpdateOneRequiredWithoutClientProjectsNestedInput
    updates?: ProjectUpdateUpdateManyWithoutProjectNestedInput
    media?: MediaUpdateManyWithoutProjectNestedInput
    payments?: PaymentUpdateManyWithoutProjectNestedInput
    milestones?: MilestoneUpdateManyWithoutProjectNestedInput
    inspections?: InspectionUpdateManyWithoutProjectNestedInput
    queries?: QueryUpdateManyWithoutProjectNestedInput
    materials?: MaterialUpdateManyWithoutProjectNestedInput
    auditLogs?: AuditLogUpdateManyWithoutProjectNestedInput
  }

  export type ProjectUncheckedUpdateWithoutMembersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumProjectStatusFieldUpdateOperationsInput | $Enums.ProjectStatus
    isArchived?: BoolFieldUpdateOperationsInput | boolean
    createdById?: StringFieldUpdateOperationsInput | string
    managerId?: StringFieldUpdateOperationsInput | string
    clientId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updates?: ProjectUpdateUncheckedUpdateManyWithoutProjectNestedInput
    media?: MediaUncheckedUpdateManyWithoutProjectNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutProjectNestedInput
    milestones?: MilestoneUncheckedUpdateManyWithoutProjectNestedInput
    inspections?: InspectionUncheckedUpdateManyWithoutProjectNestedInput
    queries?: QueryUncheckedUpdateManyWithoutProjectNestedInput
    materials?: MaterialUncheckedUpdateManyWithoutProjectNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutProjectNestedInput
  }

  export type UserUpsertWithoutProjectMembersInput = {
    update: XOR<UserUpdateWithoutProjectMembersInput, UserUncheckedUpdateWithoutProjectMembersInput>
    create: XOR<UserCreateWithoutProjectMembersInput, UserUncheckedCreateWithoutProjectMembersInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutProjectMembersInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutProjectMembersInput, UserUncheckedUpdateWithoutProjectMembersInput>
  }

  export type UserUpdateWithoutProjectMembersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    designation?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: UserUpdateOneWithoutCreatedUsersNestedInput
    createdUsers?: UserUpdateManyWithoutCreatedByNestedInput
    managedProjects?: ProjectUpdateManyWithoutManagerNestedInput
    clientProjects?: ProjectUpdateManyWithoutClientNestedInput
    projectUpdates?: ProjectUpdateUpdateManyWithoutAuthorNestedInput
    media?: MediaUpdateManyWithoutCreatedByNestedInput
    paymentsCreated?: PaymentUpdateManyWithoutCreatedByNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    projectsCreated?: ProjectUpdateManyWithoutCreatedByNestedInput
    inspections?: InspectionUpdateManyWithoutEngineerNestedInput
    reviewedInspections?: InspectionUpdateManyWithoutReviewedByNestedInput
    queries?: QueryUpdateManyWithoutAuthorNestedInput
    queryResponses?: QueryResponseUpdateManyWithoutAuthorNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
    notificationPrefs?: NotificationPreferenceUpdateOneWithoutUserNestedInput
    materialsCreated?: MaterialUpdateManyWithoutCreatedByNestedInput
  }

  export type UserUncheckedUpdateWithoutProjectMembersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    designation?: NullableStringFieldUpdateOperationsInput | string | null
    createdUsers?: UserUncheckedUpdateManyWithoutCreatedByNestedInput
    managedProjects?: ProjectUncheckedUpdateManyWithoutManagerNestedInput
    clientProjects?: ProjectUncheckedUpdateManyWithoutClientNestedInput
    projectUpdates?: ProjectUpdateUncheckedUpdateManyWithoutAuthorNestedInput
    media?: MediaUncheckedUpdateManyWithoutCreatedByNestedInput
    paymentsCreated?: PaymentUncheckedUpdateManyWithoutCreatedByNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    projectsCreated?: ProjectUncheckedUpdateManyWithoutCreatedByNestedInput
    inspections?: InspectionUncheckedUpdateManyWithoutEngineerNestedInput
    reviewedInspections?: InspectionUncheckedUpdateManyWithoutReviewedByNestedInput
    queries?: QueryUncheckedUpdateManyWithoutAuthorNestedInput
    queryResponses?: QueryResponseUncheckedUpdateManyWithoutAuthorNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    notificationPrefs?: NotificationPreferenceUncheckedUpdateOneWithoutUserNestedInput
    materialsCreated?: MaterialUncheckedUpdateManyWithoutCreatedByNestedInput
  }

  export type ProjectCreateWithoutUpdatesInput = {
    id?: string
    name: string
    description?: string | null
    status?: $Enums.ProjectStatus
    isArchived?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy: UserCreateNestedOneWithoutProjectsCreatedInput
    manager: UserCreateNestedOneWithoutManagedProjectsInput
    client: UserCreateNestedOneWithoutClientProjectsInput
    members?: ProjectMemberCreateNestedManyWithoutProjectInput
    media?: MediaCreateNestedManyWithoutProjectInput
    payments?: PaymentCreateNestedManyWithoutProjectInput
    milestones?: MilestoneCreateNestedManyWithoutProjectInput
    inspections?: InspectionCreateNestedManyWithoutProjectInput
    queries?: QueryCreateNestedManyWithoutProjectInput
    materials?: MaterialCreateNestedManyWithoutProjectInput
    auditLogs?: AuditLogCreateNestedManyWithoutProjectInput
  }

  export type ProjectUncheckedCreateWithoutUpdatesInput = {
    id?: string
    name: string
    description?: string | null
    status?: $Enums.ProjectStatus
    isArchived?: boolean
    createdById: string
    managerId: string
    clientId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    members?: ProjectMemberUncheckedCreateNestedManyWithoutProjectInput
    media?: MediaUncheckedCreateNestedManyWithoutProjectInput
    payments?: PaymentUncheckedCreateNestedManyWithoutProjectInput
    milestones?: MilestoneUncheckedCreateNestedManyWithoutProjectInput
    inspections?: InspectionUncheckedCreateNestedManyWithoutProjectInput
    queries?: QueryUncheckedCreateNestedManyWithoutProjectInput
    materials?: MaterialUncheckedCreateNestedManyWithoutProjectInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutProjectInput
  }

  export type ProjectCreateOrConnectWithoutUpdatesInput = {
    where: ProjectWhereUniqueInput
    create: XOR<ProjectCreateWithoutUpdatesInput, ProjectUncheckedCreateWithoutUpdatesInput>
  }

  export type UserCreateWithoutProjectUpdatesInput = {
    id?: string
    name: string
    email: string
    passwordHash: string
    role: $Enums.Role
    isActive?: boolean
    createdAt?: Date | string
    phone?: string | null
    designation?: string | null
    createdBy?: UserCreateNestedOneWithoutCreatedUsersInput
    createdUsers?: UserCreateNestedManyWithoutCreatedByInput
    managedProjects?: ProjectCreateNestedManyWithoutManagerInput
    clientProjects?: ProjectCreateNestedManyWithoutClientInput
    projectMembers?: ProjectMemberCreateNestedManyWithoutUserInput
    media?: MediaCreateNestedManyWithoutCreatedByInput
    paymentsCreated?: PaymentCreateNestedManyWithoutCreatedByInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    projectsCreated?: ProjectCreateNestedManyWithoutCreatedByInput
    inspections?: InspectionCreateNestedManyWithoutEngineerInput
    reviewedInspections?: InspectionCreateNestedManyWithoutReviewedByInput
    queries?: QueryCreateNestedManyWithoutAuthorInput
    queryResponses?: QueryResponseCreateNestedManyWithoutAuthorInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
    notificationPrefs?: NotificationPreferenceCreateNestedOneWithoutUserInput
    materialsCreated?: MaterialCreateNestedManyWithoutCreatedByInput
  }

  export type UserUncheckedCreateWithoutProjectUpdatesInput = {
    id?: string
    name: string
    email: string
    passwordHash: string
    role: $Enums.Role
    isActive?: boolean
    createdById?: string | null
    createdAt?: Date | string
    phone?: string | null
    designation?: string | null
    createdUsers?: UserUncheckedCreateNestedManyWithoutCreatedByInput
    managedProjects?: ProjectUncheckedCreateNestedManyWithoutManagerInput
    clientProjects?: ProjectUncheckedCreateNestedManyWithoutClientInput
    projectMembers?: ProjectMemberUncheckedCreateNestedManyWithoutUserInput
    media?: MediaUncheckedCreateNestedManyWithoutCreatedByInput
    paymentsCreated?: PaymentUncheckedCreateNestedManyWithoutCreatedByInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    projectsCreated?: ProjectUncheckedCreateNestedManyWithoutCreatedByInput
    inspections?: InspectionUncheckedCreateNestedManyWithoutEngineerInput
    reviewedInspections?: InspectionUncheckedCreateNestedManyWithoutReviewedByInput
    queries?: QueryUncheckedCreateNestedManyWithoutAuthorInput
    queryResponses?: QueryResponseUncheckedCreateNestedManyWithoutAuthorInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    notificationPrefs?: NotificationPreferenceUncheckedCreateNestedOneWithoutUserInput
    materialsCreated?: MaterialUncheckedCreateNestedManyWithoutCreatedByInput
  }

  export type UserCreateOrConnectWithoutProjectUpdatesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutProjectUpdatesInput, UserUncheckedCreateWithoutProjectUpdatesInput>
  }

  export type MediaCreateWithoutProjectUpdateInput = {
    id?: string
    type: $Enums.MediaType
    fileKey: string
    fileUrl: string
    mimeType: string
    fileSize: number
    approvedBy?: string | null
    approvedAt?: Date | string | null
    version?: number | null
    createdAt?: Date | string
    project: ProjectCreateNestedOneWithoutMediaInput
    payment?: PaymentCreateNestedOneWithoutMediaInput
    createdBy: UserCreateNestedOneWithoutMediaInput
    inspectionResponses?: InspectionResponseCreateNestedManyWithoutMediaInput
    query?: QueryCreateNestedOneWithoutAttachmentsInput
  }

  export type MediaUncheckedCreateWithoutProjectUpdateInput = {
    id?: string
    projectId: string
    paymentId?: string | null
    type: $Enums.MediaType
    fileKey: string
    fileUrl: string
    mimeType: string
    fileSize: number
    createdById: string
    approvedBy?: string | null
    approvedAt?: Date | string | null
    version?: number | null
    createdAt?: Date | string
    queryId?: string | null
    inspectionResponses?: InspectionResponseUncheckedCreateNestedManyWithoutMediaInput
  }

  export type MediaCreateOrConnectWithoutProjectUpdateInput = {
    where: MediaWhereUniqueInput
    create: XOR<MediaCreateWithoutProjectUpdateInput, MediaUncheckedCreateWithoutProjectUpdateInput>
  }

  export type MediaCreateManyProjectUpdateInputEnvelope = {
    data: MediaCreateManyProjectUpdateInput | MediaCreateManyProjectUpdateInput[]
    skipDuplicates?: boolean
  }

  export type ProjectUpsertWithoutUpdatesInput = {
    update: XOR<ProjectUpdateWithoutUpdatesInput, ProjectUncheckedUpdateWithoutUpdatesInput>
    create: XOR<ProjectCreateWithoutUpdatesInput, ProjectUncheckedCreateWithoutUpdatesInput>
    where?: ProjectWhereInput
  }

  export type ProjectUpdateToOneWithWhereWithoutUpdatesInput = {
    where?: ProjectWhereInput
    data: XOR<ProjectUpdateWithoutUpdatesInput, ProjectUncheckedUpdateWithoutUpdatesInput>
  }

  export type ProjectUpdateWithoutUpdatesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumProjectStatusFieldUpdateOperationsInput | $Enums.ProjectStatus
    isArchived?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: UserUpdateOneRequiredWithoutProjectsCreatedNestedInput
    manager?: UserUpdateOneRequiredWithoutManagedProjectsNestedInput
    client?: UserUpdateOneRequiredWithoutClientProjectsNestedInput
    members?: ProjectMemberUpdateManyWithoutProjectNestedInput
    media?: MediaUpdateManyWithoutProjectNestedInput
    payments?: PaymentUpdateManyWithoutProjectNestedInput
    milestones?: MilestoneUpdateManyWithoutProjectNestedInput
    inspections?: InspectionUpdateManyWithoutProjectNestedInput
    queries?: QueryUpdateManyWithoutProjectNestedInput
    materials?: MaterialUpdateManyWithoutProjectNestedInput
    auditLogs?: AuditLogUpdateManyWithoutProjectNestedInput
  }

  export type ProjectUncheckedUpdateWithoutUpdatesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumProjectStatusFieldUpdateOperationsInput | $Enums.ProjectStatus
    isArchived?: BoolFieldUpdateOperationsInput | boolean
    createdById?: StringFieldUpdateOperationsInput | string
    managerId?: StringFieldUpdateOperationsInput | string
    clientId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    members?: ProjectMemberUncheckedUpdateManyWithoutProjectNestedInput
    media?: MediaUncheckedUpdateManyWithoutProjectNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutProjectNestedInput
    milestones?: MilestoneUncheckedUpdateManyWithoutProjectNestedInput
    inspections?: InspectionUncheckedUpdateManyWithoutProjectNestedInput
    queries?: QueryUncheckedUpdateManyWithoutProjectNestedInput
    materials?: MaterialUncheckedUpdateManyWithoutProjectNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutProjectNestedInput
  }

  export type UserUpsertWithoutProjectUpdatesInput = {
    update: XOR<UserUpdateWithoutProjectUpdatesInput, UserUncheckedUpdateWithoutProjectUpdatesInput>
    create: XOR<UserCreateWithoutProjectUpdatesInput, UserUncheckedCreateWithoutProjectUpdatesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutProjectUpdatesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutProjectUpdatesInput, UserUncheckedUpdateWithoutProjectUpdatesInput>
  }

  export type UserUpdateWithoutProjectUpdatesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    designation?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: UserUpdateOneWithoutCreatedUsersNestedInput
    createdUsers?: UserUpdateManyWithoutCreatedByNestedInput
    managedProjects?: ProjectUpdateManyWithoutManagerNestedInput
    clientProjects?: ProjectUpdateManyWithoutClientNestedInput
    projectMembers?: ProjectMemberUpdateManyWithoutUserNestedInput
    media?: MediaUpdateManyWithoutCreatedByNestedInput
    paymentsCreated?: PaymentUpdateManyWithoutCreatedByNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    projectsCreated?: ProjectUpdateManyWithoutCreatedByNestedInput
    inspections?: InspectionUpdateManyWithoutEngineerNestedInput
    reviewedInspections?: InspectionUpdateManyWithoutReviewedByNestedInput
    queries?: QueryUpdateManyWithoutAuthorNestedInput
    queryResponses?: QueryResponseUpdateManyWithoutAuthorNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
    notificationPrefs?: NotificationPreferenceUpdateOneWithoutUserNestedInput
    materialsCreated?: MaterialUpdateManyWithoutCreatedByNestedInput
  }

  export type UserUncheckedUpdateWithoutProjectUpdatesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    designation?: NullableStringFieldUpdateOperationsInput | string | null
    createdUsers?: UserUncheckedUpdateManyWithoutCreatedByNestedInput
    managedProjects?: ProjectUncheckedUpdateManyWithoutManagerNestedInput
    clientProjects?: ProjectUncheckedUpdateManyWithoutClientNestedInput
    projectMembers?: ProjectMemberUncheckedUpdateManyWithoutUserNestedInput
    media?: MediaUncheckedUpdateManyWithoutCreatedByNestedInput
    paymentsCreated?: PaymentUncheckedUpdateManyWithoutCreatedByNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    projectsCreated?: ProjectUncheckedUpdateManyWithoutCreatedByNestedInput
    inspections?: InspectionUncheckedUpdateManyWithoutEngineerNestedInput
    reviewedInspections?: InspectionUncheckedUpdateManyWithoutReviewedByNestedInput
    queries?: QueryUncheckedUpdateManyWithoutAuthorNestedInput
    queryResponses?: QueryResponseUncheckedUpdateManyWithoutAuthorNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    notificationPrefs?: NotificationPreferenceUncheckedUpdateOneWithoutUserNestedInput
    materialsCreated?: MaterialUncheckedUpdateManyWithoutCreatedByNestedInput
  }

  export type MediaUpsertWithWhereUniqueWithoutProjectUpdateInput = {
    where: MediaWhereUniqueInput
    update: XOR<MediaUpdateWithoutProjectUpdateInput, MediaUncheckedUpdateWithoutProjectUpdateInput>
    create: XOR<MediaCreateWithoutProjectUpdateInput, MediaUncheckedCreateWithoutProjectUpdateInput>
  }

  export type MediaUpdateWithWhereUniqueWithoutProjectUpdateInput = {
    where: MediaWhereUniqueInput
    data: XOR<MediaUpdateWithoutProjectUpdateInput, MediaUncheckedUpdateWithoutProjectUpdateInput>
  }

  export type MediaUpdateManyWithWhereWithoutProjectUpdateInput = {
    where: MediaScalarWhereInput
    data: XOR<MediaUpdateManyMutationInput, MediaUncheckedUpdateManyWithoutProjectUpdateInput>
  }

  export type ProjectCreateWithoutMediaInput = {
    id?: string
    name: string
    description?: string | null
    status?: $Enums.ProjectStatus
    isArchived?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy: UserCreateNestedOneWithoutProjectsCreatedInput
    manager: UserCreateNestedOneWithoutManagedProjectsInput
    client: UserCreateNestedOneWithoutClientProjectsInput
    members?: ProjectMemberCreateNestedManyWithoutProjectInput
    updates?: ProjectUpdateCreateNestedManyWithoutProjectInput
    payments?: PaymentCreateNestedManyWithoutProjectInput
    milestones?: MilestoneCreateNestedManyWithoutProjectInput
    inspections?: InspectionCreateNestedManyWithoutProjectInput
    queries?: QueryCreateNestedManyWithoutProjectInput
    materials?: MaterialCreateNestedManyWithoutProjectInput
    auditLogs?: AuditLogCreateNestedManyWithoutProjectInput
  }

  export type ProjectUncheckedCreateWithoutMediaInput = {
    id?: string
    name: string
    description?: string | null
    status?: $Enums.ProjectStatus
    isArchived?: boolean
    createdById: string
    managerId: string
    clientId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    members?: ProjectMemberUncheckedCreateNestedManyWithoutProjectInput
    updates?: ProjectUpdateUncheckedCreateNestedManyWithoutProjectInput
    payments?: PaymentUncheckedCreateNestedManyWithoutProjectInput
    milestones?: MilestoneUncheckedCreateNestedManyWithoutProjectInput
    inspections?: InspectionUncheckedCreateNestedManyWithoutProjectInput
    queries?: QueryUncheckedCreateNestedManyWithoutProjectInput
    materials?: MaterialUncheckedCreateNestedManyWithoutProjectInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutProjectInput
  }

  export type ProjectCreateOrConnectWithoutMediaInput = {
    where: ProjectWhereUniqueInput
    create: XOR<ProjectCreateWithoutMediaInput, ProjectUncheckedCreateWithoutMediaInput>
  }

  export type ProjectUpdateCreateWithoutMediaInput = {
    id?: string
    notes: string
    statusSnapshot?: string | null
    createdAt?: Date | string
    project: ProjectCreateNestedOneWithoutUpdatesInput
    author: UserCreateNestedOneWithoutProjectUpdatesInput
  }

  export type ProjectUpdateUncheckedCreateWithoutMediaInput = {
    id?: string
    projectId: string
    authorId: string
    notes: string
    statusSnapshot?: string | null
    createdAt?: Date | string
  }

  export type ProjectUpdateCreateOrConnectWithoutMediaInput = {
    where: ProjectUpdateWhereUniqueInput
    create: XOR<ProjectUpdateCreateWithoutMediaInput, ProjectUpdateUncheckedCreateWithoutMediaInput>
  }

  export type PaymentCreateWithoutMediaInput = {
    id?: string
    amount: Decimal | DecimalJsLike | number | string
    currency?: string
    status?: $Enums.PaymentStatus
    category?: $Enums.PaymentCategory | null
    invoiceNumber?: string | null
    paidAt?: Date | string | null
    dueDate?: Date | string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    project: ProjectCreateNestedOneWithoutPaymentsInput
    createdBy: UserCreateNestedOneWithoutPaymentsCreatedInput
  }

  export type PaymentUncheckedCreateWithoutMediaInput = {
    id?: string
    projectId: string
    createdById: string
    amount: Decimal | DecimalJsLike | number | string
    currency?: string
    status?: $Enums.PaymentStatus
    category?: $Enums.PaymentCategory | null
    invoiceNumber?: string | null
    paidAt?: Date | string | null
    dueDate?: Date | string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PaymentCreateOrConnectWithoutMediaInput = {
    where: PaymentWhereUniqueInput
    create: XOR<PaymentCreateWithoutMediaInput, PaymentUncheckedCreateWithoutMediaInput>
  }

  export type UserCreateWithoutMediaInput = {
    id?: string
    name: string
    email: string
    passwordHash: string
    role: $Enums.Role
    isActive?: boolean
    createdAt?: Date | string
    phone?: string | null
    designation?: string | null
    createdBy?: UserCreateNestedOneWithoutCreatedUsersInput
    createdUsers?: UserCreateNestedManyWithoutCreatedByInput
    managedProjects?: ProjectCreateNestedManyWithoutManagerInput
    clientProjects?: ProjectCreateNestedManyWithoutClientInput
    projectMembers?: ProjectMemberCreateNestedManyWithoutUserInput
    projectUpdates?: ProjectUpdateCreateNestedManyWithoutAuthorInput
    paymentsCreated?: PaymentCreateNestedManyWithoutCreatedByInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    projectsCreated?: ProjectCreateNestedManyWithoutCreatedByInput
    inspections?: InspectionCreateNestedManyWithoutEngineerInput
    reviewedInspections?: InspectionCreateNestedManyWithoutReviewedByInput
    queries?: QueryCreateNestedManyWithoutAuthorInput
    queryResponses?: QueryResponseCreateNestedManyWithoutAuthorInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
    notificationPrefs?: NotificationPreferenceCreateNestedOneWithoutUserInput
    materialsCreated?: MaterialCreateNestedManyWithoutCreatedByInput
  }

  export type UserUncheckedCreateWithoutMediaInput = {
    id?: string
    name: string
    email: string
    passwordHash: string
    role: $Enums.Role
    isActive?: boolean
    createdById?: string | null
    createdAt?: Date | string
    phone?: string | null
    designation?: string | null
    createdUsers?: UserUncheckedCreateNestedManyWithoutCreatedByInput
    managedProjects?: ProjectUncheckedCreateNestedManyWithoutManagerInput
    clientProjects?: ProjectUncheckedCreateNestedManyWithoutClientInput
    projectMembers?: ProjectMemberUncheckedCreateNestedManyWithoutUserInput
    projectUpdates?: ProjectUpdateUncheckedCreateNestedManyWithoutAuthorInput
    paymentsCreated?: PaymentUncheckedCreateNestedManyWithoutCreatedByInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    projectsCreated?: ProjectUncheckedCreateNestedManyWithoutCreatedByInput
    inspections?: InspectionUncheckedCreateNestedManyWithoutEngineerInput
    reviewedInspections?: InspectionUncheckedCreateNestedManyWithoutReviewedByInput
    queries?: QueryUncheckedCreateNestedManyWithoutAuthorInput
    queryResponses?: QueryResponseUncheckedCreateNestedManyWithoutAuthorInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    notificationPrefs?: NotificationPreferenceUncheckedCreateNestedOneWithoutUserInput
    materialsCreated?: MaterialUncheckedCreateNestedManyWithoutCreatedByInput
  }

  export type UserCreateOrConnectWithoutMediaInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutMediaInput, UserUncheckedCreateWithoutMediaInput>
  }

  export type InspectionResponseCreateWithoutMediaInput = {
    id?: string
    result: $Enums.ChecklistResult
    remark?: string | null
    inspection: InspectionCreateNestedOneWithoutResponsesInput
    checklistItem: ChecklistItemCreateNestedOneWithoutResponsesInput
  }

  export type InspectionResponseUncheckedCreateWithoutMediaInput = {
    id?: string
    result: $Enums.ChecklistResult
    remark?: string | null
    inspectionId: string
    checklistItemId: string
  }

  export type InspectionResponseCreateOrConnectWithoutMediaInput = {
    where: InspectionResponseWhereUniqueInput
    create: XOR<InspectionResponseCreateWithoutMediaInput, InspectionResponseUncheckedCreateWithoutMediaInput>
  }

  export type InspectionResponseCreateManyMediaInputEnvelope = {
    data: InspectionResponseCreateManyMediaInput | InspectionResponseCreateManyMediaInput[]
    skipDuplicates?: boolean
  }

  export type QueryCreateWithoutAttachmentsInput = {
    id?: string
    title: string
    description: string
    status?: $Enums.QueryStatus
    priority?: $Enums.QueryPriority
    createdAt?: Date | string
    updatedAt?: Date | string
    project: ProjectCreateNestedOneWithoutQueriesInput
    author: UserCreateNestedOneWithoutQueriesInput
    responses?: QueryResponseCreateNestedManyWithoutQueryInput
  }

  export type QueryUncheckedCreateWithoutAttachmentsInput = {
    id?: string
    projectId: string
    authorId: string
    title: string
    description: string
    status?: $Enums.QueryStatus
    priority?: $Enums.QueryPriority
    createdAt?: Date | string
    updatedAt?: Date | string
    responses?: QueryResponseUncheckedCreateNestedManyWithoutQueryInput
  }

  export type QueryCreateOrConnectWithoutAttachmentsInput = {
    where: QueryWhereUniqueInput
    create: XOR<QueryCreateWithoutAttachmentsInput, QueryUncheckedCreateWithoutAttachmentsInput>
  }

  export type ProjectUpsertWithoutMediaInput = {
    update: XOR<ProjectUpdateWithoutMediaInput, ProjectUncheckedUpdateWithoutMediaInput>
    create: XOR<ProjectCreateWithoutMediaInput, ProjectUncheckedCreateWithoutMediaInput>
    where?: ProjectWhereInput
  }

  export type ProjectUpdateToOneWithWhereWithoutMediaInput = {
    where?: ProjectWhereInput
    data: XOR<ProjectUpdateWithoutMediaInput, ProjectUncheckedUpdateWithoutMediaInput>
  }

  export type ProjectUpdateWithoutMediaInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumProjectStatusFieldUpdateOperationsInput | $Enums.ProjectStatus
    isArchived?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: UserUpdateOneRequiredWithoutProjectsCreatedNestedInput
    manager?: UserUpdateOneRequiredWithoutManagedProjectsNestedInput
    client?: UserUpdateOneRequiredWithoutClientProjectsNestedInput
    members?: ProjectMemberUpdateManyWithoutProjectNestedInput
    updates?: ProjectUpdateUpdateManyWithoutProjectNestedInput
    payments?: PaymentUpdateManyWithoutProjectNestedInput
    milestones?: MilestoneUpdateManyWithoutProjectNestedInput
    inspections?: InspectionUpdateManyWithoutProjectNestedInput
    queries?: QueryUpdateManyWithoutProjectNestedInput
    materials?: MaterialUpdateManyWithoutProjectNestedInput
    auditLogs?: AuditLogUpdateManyWithoutProjectNestedInput
  }

  export type ProjectUncheckedUpdateWithoutMediaInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumProjectStatusFieldUpdateOperationsInput | $Enums.ProjectStatus
    isArchived?: BoolFieldUpdateOperationsInput | boolean
    createdById?: StringFieldUpdateOperationsInput | string
    managerId?: StringFieldUpdateOperationsInput | string
    clientId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    members?: ProjectMemberUncheckedUpdateManyWithoutProjectNestedInput
    updates?: ProjectUpdateUncheckedUpdateManyWithoutProjectNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutProjectNestedInput
    milestones?: MilestoneUncheckedUpdateManyWithoutProjectNestedInput
    inspections?: InspectionUncheckedUpdateManyWithoutProjectNestedInput
    queries?: QueryUncheckedUpdateManyWithoutProjectNestedInput
    materials?: MaterialUncheckedUpdateManyWithoutProjectNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutProjectNestedInput
  }

  export type ProjectUpdateUpsertWithoutMediaInput = {
    update: XOR<ProjectUpdateUpdateWithoutMediaInput, ProjectUpdateUncheckedUpdateWithoutMediaInput>
    create: XOR<ProjectUpdateCreateWithoutMediaInput, ProjectUpdateUncheckedCreateWithoutMediaInput>
    where?: ProjectUpdateWhereInput
  }

  export type ProjectUpdateUpdateToOneWithWhereWithoutMediaInput = {
    where?: ProjectUpdateWhereInput
    data: XOR<ProjectUpdateUpdateWithoutMediaInput, ProjectUpdateUncheckedUpdateWithoutMediaInput>
  }

  export type ProjectUpdateUpdateWithoutMediaInput = {
    id?: StringFieldUpdateOperationsInput | string
    notes?: StringFieldUpdateOperationsInput | string
    statusSnapshot?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    project?: ProjectUpdateOneRequiredWithoutUpdatesNestedInput
    author?: UserUpdateOneRequiredWithoutProjectUpdatesNestedInput
  }

  export type ProjectUpdateUncheckedUpdateWithoutMediaInput = {
    id?: StringFieldUpdateOperationsInput | string
    projectId?: StringFieldUpdateOperationsInput | string
    authorId?: StringFieldUpdateOperationsInput | string
    notes?: StringFieldUpdateOperationsInput | string
    statusSnapshot?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentUpsertWithoutMediaInput = {
    update: XOR<PaymentUpdateWithoutMediaInput, PaymentUncheckedUpdateWithoutMediaInput>
    create: XOR<PaymentCreateWithoutMediaInput, PaymentUncheckedCreateWithoutMediaInput>
    where?: PaymentWhereInput
  }

  export type PaymentUpdateToOneWithWhereWithoutMediaInput = {
    where?: PaymentWhereInput
    data: XOR<PaymentUpdateWithoutMediaInput, PaymentUncheckedUpdateWithoutMediaInput>
  }

  export type PaymentUpdateWithoutMediaInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    status?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    category?: NullableEnumPaymentCategoryFieldUpdateOperationsInput | $Enums.PaymentCategory | null
    invoiceNumber?: NullableStringFieldUpdateOperationsInput | string | null
    paidAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    project?: ProjectUpdateOneRequiredWithoutPaymentsNestedInput
    createdBy?: UserUpdateOneRequiredWithoutPaymentsCreatedNestedInput
  }

  export type PaymentUncheckedUpdateWithoutMediaInput = {
    id?: StringFieldUpdateOperationsInput | string
    projectId?: StringFieldUpdateOperationsInput | string
    createdById?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    status?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    category?: NullableEnumPaymentCategoryFieldUpdateOperationsInput | $Enums.PaymentCategory | null
    invoiceNumber?: NullableStringFieldUpdateOperationsInput | string | null
    paidAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUpsertWithoutMediaInput = {
    update: XOR<UserUpdateWithoutMediaInput, UserUncheckedUpdateWithoutMediaInput>
    create: XOR<UserCreateWithoutMediaInput, UserUncheckedCreateWithoutMediaInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutMediaInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutMediaInput, UserUncheckedUpdateWithoutMediaInput>
  }

  export type UserUpdateWithoutMediaInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    designation?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: UserUpdateOneWithoutCreatedUsersNestedInput
    createdUsers?: UserUpdateManyWithoutCreatedByNestedInput
    managedProjects?: ProjectUpdateManyWithoutManagerNestedInput
    clientProjects?: ProjectUpdateManyWithoutClientNestedInput
    projectMembers?: ProjectMemberUpdateManyWithoutUserNestedInput
    projectUpdates?: ProjectUpdateUpdateManyWithoutAuthorNestedInput
    paymentsCreated?: PaymentUpdateManyWithoutCreatedByNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    projectsCreated?: ProjectUpdateManyWithoutCreatedByNestedInput
    inspections?: InspectionUpdateManyWithoutEngineerNestedInput
    reviewedInspections?: InspectionUpdateManyWithoutReviewedByNestedInput
    queries?: QueryUpdateManyWithoutAuthorNestedInput
    queryResponses?: QueryResponseUpdateManyWithoutAuthorNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
    notificationPrefs?: NotificationPreferenceUpdateOneWithoutUserNestedInput
    materialsCreated?: MaterialUpdateManyWithoutCreatedByNestedInput
  }

  export type UserUncheckedUpdateWithoutMediaInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    designation?: NullableStringFieldUpdateOperationsInput | string | null
    createdUsers?: UserUncheckedUpdateManyWithoutCreatedByNestedInput
    managedProjects?: ProjectUncheckedUpdateManyWithoutManagerNestedInput
    clientProjects?: ProjectUncheckedUpdateManyWithoutClientNestedInput
    projectMembers?: ProjectMemberUncheckedUpdateManyWithoutUserNestedInput
    projectUpdates?: ProjectUpdateUncheckedUpdateManyWithoutAuthorNestedInput
    paymentsCreated?: PaymentUncheckedUpdateManyWithoutCreatedByNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    projectsCreated?: ProjectUncheckedUpdateManyWithoutCreatedByNestedInput
    inspections?: InspectionUncheckedUpdateManyWithoutEngineerNestedInput
    reviewedInspections?: InspectionUncheckedUpdateManyWithoutReviewedByNestedInput
    queries?: QueryUncheckedUpdateManyWithoutAuthorNestedInput
    queryResponses?: QueryResponseUncheckedUpdateManyWithoutAuthorNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    notificationPrefs?: NotificationPreferenceUncheckedUpdateOneWithoutUserNestedInput
    materialsCreated?: MaterialUncheckedUpdateManyWithoutCreatedByNestedInput
  }

  export type InspectionResponseUpsertWithWhereUniqueWithoutMediaInput = {
    where: InspectionResponseWhereUniqueInput
    update: XOR<InspectionResponseUpdateWithoutMediaInput, InspectionResponseUncheckedUpdateWithoutMediaInput>
    create: XOR<InspectionResponseCreateWithoutMediaInput, InspectionResponseUncheckedCreateWithoutMediaInput>
  }

  export type InspectionResponseUpdateWithWhereUniqueWithoutMediaInput = {
    where: InspectionResponseWhereUniqueInput
    data: XOR<InspectionResponseUpdateWithoutMediaInput, InspectionResponseUncheckedUpdateWithoutMediaInput>
  }

  export type InspectionResponseUpdateManyWithWhereWithoutMediaInput = {
    where: InspectionResponseScalarWhereInput
    data: XOR<InspectionResponseUpdateManyMutationInput, InspectionResponseUncheckedUpdateManyWithoutMediaInput>
  }

  export type InspectionResponseScalarWhereInput = {
    AND?: InspectionResponseScalarWhereInput | InspectionResponseScalarWhereInput[]
    OR?: InspectionResponseScalarWhereInput[]
    NOT?: InspectionResponseScalarWhereInput | InspectionResponseScalarWhereInput[]
    id?: StringFilter<"InspectionResponse"> | string
    result?: EnumChecklistResultFilter<"InspectionResponse"> | $Enums.ChecklistResult
    remark?: StringNullableFilter<"InspectionResponse"> | string | null
    inspectionId?: StringFilter<"InspectionResponse"> | string
    checklistItemId?: StringFilter<"InspectionResponse"> | string
    mediaId?: StringNullableFilter<"InspectionResponse"> | string | null
  }

  export type QueryUpsertWithoutAttachmentsInput = {
    update: XOR<QueryUpdateWithoutAttachmentsInput, QueryUncheckedUpdateWithoutAttachmentsInput>
    create: XOR<QueryCreateWithoutAttachmentsInput, QueryUncheckedCreateWithoutAttachmentsInput>
    where?: QueryWhereInput
  }

  export type QueryUpdateToOneWithWhereWithoutAttachmentsInput = {
    where?: QueryWhereInput
    data: XOR<QueryUpdateWithoutAttachmentsInput, QueryUncheckedUpdateWithoutAttachmentsInput>
  }

  export type QueryUpdateWithoutAttachmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    status?: EnumQueryStatusFieldUpdateOperationsInput | $Enums.QueryStatus
    priority?: EnumQueryPriorityFieldUpdateOperationsInput | $Enums.QueryPriority
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    project?: ProjectUpdateOneRequiredWithoutQueriesNestedInput
    author?: UserUpdateOneRequiredWithoutQueriesNestedInput
    responses?: QueryResponseUpdateManyWithoutQueryNestedInput
  }

  export type QueryUncheckedUpdateWithoutAttachmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    projectId?: StringFieldUpdateOperationsInput | string
    authorId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    status?: EnumQueryStatusFieldUpdateOperationsInput | $Enums.QueryStatus
    priority?: EnumQueryPriorityFieldUpdateOperationsInput | $Enums.QueryPriority
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    responses?: QueryResponseUncheckedUpdateManyWithoutQueryNestedInput
  }

  export type ProjectCreateWithoutPaymentsInput = {
    id?: string
    name: string
    description?: string | null
    status?: $Enums.ProjectStatus
    isArchived?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy: UserCreateNestedOneWithoutProjectsCreatedInput
    manager: UserCreateNestedOneWithoutManagedProjectsInput
    client: UserCreateNestedOneWithoutClientProjectsInput
    members?: ProjectMemberCreateNestedManyWithoutProjectInput
    updates?: ProjectUpdateCreateNestedManyWithoutProjectInput
    media?: MediaCreateNestedManyWithoutProjectInput
    milestones?: MilestoneCreateNestedManyWithoutProjectInput
    inspections?: InspectionCreateNestedManyWithoutProjectInput
    queries?: QueryCreateNestedManyWithoutProjectInput
    materials?: MaterialCreateNestedManyWithoutProjectInput
    auditLogs?: AuditLogCreateNestedManyWithoutProjectInput
  }

  export type ProjectUncheckedCreateWithoutPaymentsInput = {
    id?: string
    name: string
    description?: string | null
    status?: $Enums.ProjectStatus
    isArchived?: boolean
    createdById: string
    managerId: string
    clientId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    members?: ProjectMemberUncheckedCreateNestedManyWithoutProjectInput
    updates?: ProjectUpdateUncheckedCreateNestedManyWithoutProjectInput
    media?: MediaUncheckedCreateNestedManyWithoutProjectInput
    milestones?: MilestoneUncheckedCreateNestedManyWithoutProjectInput
    inspections?: InspectionUncheckedCreateNestedManyWithoutProjectInput
    queries?: QueryUncheckedCreateNestedManyWithoutProjectInput
    materials?: MaterialUncheckedCreateNestedManyWithoutProjectInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutProjectInput
  }

  export type ProjectCreateOrConnectWithoutPaymentsInput = {
    where: ProjectWhereUniqueInput
    create: XOR<ProjectCreateWithoutPaymentsInput, ProjectUncheckedCreateWithoutPaymentsInput>
  }

  export type UserCreateWithoutPaymentsCreatedInput = {
    id?: string
    name: string
    email: string
    passwordHash: string
    role: $Enums.Role
    isActive?: boolean
    createdAt?: Date | string
    phone?: string | null
    designation?: string | null
    createdBy?: UserCreateNestedOneWithoutCreatedUsersInput
    createdUsers?: UserCreateNestedManyWithoutCreatedByInput
    managedProjects?: ProjectCreateNestedManyWithoutManagerInput
    clientProjects?: ProjectCreateNestedManyWithoutClientInput
    projectMembers?: ProjectMemberCreateNestedManyWithoutUserInput
    projectUpdates?: ProjectUpdateCreateNestedManyWithoutAuthorInput
    media?: MediaCreateNestedManyWithoutCreatedByInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    projectsCreated?: ProjectCreateNestedManyWithoutCreatedByInput
    inspections?: InspectionCreateNestedManyWithoutEngineerInput
    reviewedInspections?: InspectionCreateNestedManyWithoutReviewedByInput
    queries?: QueryCreateNestedManyWithoutAuthorInput
    queryResponses?: QueryResponseCreateNestedManyWithoutAuthorInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
    notificationPrefs?: NotificationPreferenceCreateNestedOneWithoutUserInput
    materialsCreated?: MaterialCreateNestedManyWithoutCreatedByInput
  }

  export type UserUncheckedCreateWithoutPaymentsCreatedInput = {
    id?: string
    name: string
    email: string
    passwordHash: string
    role: $Enums.Role
    isActive?: boolean
    createdById?: string | null
    createdAt?: Date | string
    phone?: string | null
    designation?: string | null
    createdUsers?: UserUncheckedCreateNestedManyWithoutCreatedByInput
    managedProjects?: ProjectUncheckedCreateNestedManyWithoutManagerInput
    clientProjects?: ProjectUncheckedCreateNestedManyWithoutClientInput
    projectMembers?: ProjectMemberUncheckedCreateNestedManyWithoutUserInput
    projectUpdates?: ProjectUpdateUncheckedCreateNestedManyWithoutAuthorInput
    media?: MediaUncheckedCreateNestedManyWithoutCreatedByInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    projectsCreated?: ProjectUncheckedCreateNestedManyWithoutCreatedByInput
    inspections?: InspectionUncheckedCreateNestedManyWithoutEngineerInput
    reviewedInspections?: InspectionUncheckedCreateNestedManyWithoutReviewedByInput
    queries?: QueryUncheckedCreateNestedManyWithoutAuthorInput
    queryResponses?: QueryResponseUncheckedCreateNestedManyWithoutAuthorInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    notificationPrefs?: NotificationPreferenceUncheckedCreateNestedOneWithoutUserInput
    materialsCreated?: MaterialUncheckedCreateNestedManyWithoutCreatedByInput
  }

  export type UserCreateOrConnectWithoutPaymentsCreatedInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutPaymentsCreatedInput, UserUncheckedCreateWithoutPaymentsCreatedInput>
  }

  export type MediaCreateWithoutPaymentInput = {
    id?: string
    type: $Enums.MediaType
    fileKey: string
    fileUrl: string
    mimeType: string
    fileSize: number
    approvedBy?: string | null
    approvedAt?: Date | string | null
    version?: number | null
    createdAt?: Date | string
    project: ProjectCreateNestedOneWithoutMediaInput
    projectUpdate?: ProjectUpdateCreateNestedOneWithoutMediaInput
    createdBy: UserCreateNestedOneWithoutMediaInput
    inspectionResponses?: InspectionResponseCreateNestedManyWithoutMediaInput
    query?: QueryCreateNestedOneWithoutAttachmentsInput
  }

  export type MediaUncheckedCreateWithoutPaymentInput = {
    id?: string
    projectId: string
    projectUpdateId?: string | null
    type: $Enums.MediaType
    fileKey: string
    fileUrl: string
    mimeType: string
    fileSize: number
    createdById: string
    approvedBy?: string | null
    approvedAt?: Date | string | null
    version?: number | null
    createdAt?: Date | string
    queryId?: string | null
    inspectionResponses?: InspectionResponseUncheckedCreateNestedManyWithoutMediaInput
  }

  export type MediaCreateOrConnectWithoutPaymentInput = {
    where: MediaWhereUniqueInput
    create: XOR<MediaCreateWithoutPaymentInput, MediaUncheckedCreateWithoutPaymentInput>
  }

  export type MediaCreateManyPaymentInputEnvelope = {
    data: MediaCreateManyPaymentInput | MediaCreateManyPaymentInput[]
    skipDuplicates?: boolean
  }

  export type ProjectUpsertWithoutPaymentsInput = {
    update: XOR<ProjectUpdateWithoutPaymentsInput, ProjectUncheckedUpdateWithoutPaymentsInput>
    create: XOR<ProjectCreateWithoutPaymentsInput, ProjectUncheckedCreateWithoutPaymentsInput>
    where?: ProjectWhereInput
  }

  export type ProjectUpdateToOneWithWhereWithoutPaymentsInput = {
    where?: ProjectWhereInput
    data: XOR<ProjectUpdateWithoutPaymentsInput, ProjectUncheckedUpdateWithoutPaymentsInput>
  }

  export type ProjectUpdateWithoutPaymentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumProjectStatusFieldUpdateOperationsInput | $Enums.ProjectStatus
    isArchived?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: UserUpdateOneRequiredWithoutProjectsCreatedNestedInput
    manager?: UserUpdateOneRequiredWithoutManagedProjectsNestedInput
    client?: UserUpdateOneRequiredWithoutClientProjectsNestedInput
    members?: ProjectMemberUpdateManyWithoutProjectNestedInput
    updates?: ProjectUpdateUpdateManyWithoutProjectNestedInput
    media?: MediaUpdateManyWithoutProjectNestedInput
    milestones?: MilestoneUpdateManyWithoutProjectNestedInput
    inspections?: InspectionUpdateManyWithoutProjectNestedInput
    queries?: QueryUpdateManyWithoutProjectNestedInput
    materials?: MaterialUpdateManyWithoutProjectNestedInput
    auditLogs?: AuditLogUpdateManyWithoutProjectNestedInput
  }

  export type ProjectUncheckedUpdateWithoutPaymentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumProjectStatusFieldUpdateOperationsInput | $Enums.ProjectStatus
    isArchived?: BoolFieldUpdateOperationsInput | boolean
    createdById?: StringFieldUpdateOperationsInput | string
    managerId?: StringFieldUpdateOperationsInput | string
    clientId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    members?: ProjectMemberUncheckedUpdateManyWithoutProjectNestedInput
    updates?: ProjectUpdateUncheckedUpdateManyWithoutProjectNestedInput
    media?: MediaUncheckedUpdateManyWithoutProjectNestedInput
    milestones?: MilestoneUncheckedUpdateManyWithoutProjectNestedInput
    inspections?: InspectionUncheckedUpdateManyWithoutProjectNestedInput
    queries?: QueryUncheckedUpdateManyWithoutProjectNestedInput
    materials?: MaterialUncheckedUpdateManyWithoutProjectNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutProjectNestedInput
  }

  export type UserUpsertWithoutPaymentsCreatedInput = {
    update: XOR<UserUpdateWithoutPaymentsCreatedInput, UserUncheckedUpdateWithoutPaymentsCreatedInput>
    create: XOR<UserCreateWithoutPaymentsCreatedInput, UserUncheckedCreateWithoutPaymentsCreatedInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutPaymentsCreatedInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutPaymentsCreatedInput, UserUncheckedUpdateWithoutPaymentsCreatedInput>
  }

  export type UserUpdateWithoutPaymentsCreatedInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    designation?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: UserUpdateOneWithoutCreatedUsersNestedInput
    createdUsers?: UserUpdateManyWithoutCreatedByNestedInput
    managedProjects?: ProjectUpdateManyWithoutManagerNestedInput
    clientProjects?: ProjectUpdateManyWithoutClientNestedInput
    projectMembers?: ProjectMemberUpdateManyWithoutUserNestedInput
    projectUpdates?: ProjectUpdateUpdateManyWithoutAuthorNestedInput
    media?: MediaUpdateManyWithoutCreatedByNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    projectsCreated?: ProjectUpdateManyWithoutCreatedByNestedInput
    inspections?: InspectionUpdateManyWithoutEngineerNestedInput
    reviewedInspections?: InspectionUpdateManyWithoutReviewedByNestedInput
    queries?: QueryUpdateManyWithoutAuthorNestedInput
    queryResponses?: QueryResponseUpdateManyWithoutAuthorNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
    notificationPrefs?: NotificationPreferenceUpdateOneWithoutUserNestedInput
    materialsCreated?: MaterialUpdateManyWithoutCreatedByNestedInput
  }

  export type UserUncheckedUpdateWithoutPaymentsCreatedInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    designation?: NullableStringFieldUpdateOperationsInput | string | null
    createdUsers?: UserUncheckedUpdateManyWithoutCreatedByNestedInput
    managedProjects?: ProjectUncheckedUpdateManyWithoutManagerNestedInput
    clientProjects?: ProjectUncheckedUpdateManyWithoutClientNestedInput
    projectMembers?: ProjectMemberUncheckedUpdateManyWithoutUserNestedInput
    projectUpdates?: ProjectUpdateUncheckedUpdateManyWithoutAuthorNestedInput
    media?: MediaUncheckedUpdateManyWithoutCreatedByNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    projectsCreated?: ProjectUncheckedUpdateManyWithoutCreatedByNestedInput
    inspections?: InspectionUncheckedUpdateManyWithoutEngineerNestedInput
    reviewedInspections?: InspectionUncheckedUpdateManyWithoutReviewedByNestedInput
    queries?: QueryUncheckedUpdateManyWithoutAuthorNestedInput
    queryResponses?: QueryResponseUncheckedUpdateManyWithoutAuthorNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    notificationPrefs?: NotificationPreferenceUncheckedUpdateOneWithoutUserNestedInput
    materialsCreated?: MaterialUncheckedUpdateManyWithoutCreatedByNestedInput
  }

  export type MediaUpsertWithWhereUniqueWithoutPaymentInput = {
    where: MediaWhereUniqueInput
    update: XOR<MediaUpdateWithoutPaymentInput, MediaUncheckedUpdateWithoutPaymentInput>
    create: XOR<MediaCreateWithoutPaymentInput, MediaUncheckedCreateWithoutPaymentInput>
  }

  export type MediaUpdateWithWhereUniqueWithoutPaymentInput = {
    where: MediaWhereUniqueInput
    data: XOR<MediaUpdateWithoutPaymentInput, MediaUncheckedUpdateWithoutPaymentInput>
  }

  export type MediaUpdateManyWithWhereWithoutPaymentInput = {
    where: MediaScalarWhereInput
    data: XOR<MediaUpdateManyMutationInput, MediaUncheckedUpdateManyWithoutPaymentInput>
  }

  export type UserCreateWithoutNotificationsInput = {
    id?: string
    name: string
    email: string
    passwordHash: string
    role: $Enums.Role
    isActive?: boolean
    createdAt?: Date | string
    phone?: string | null
    designation?: string | null
    createdBy?: UserCreateNestedOneWithoutCreatedUsersInput
    createdUsers?: UserCreateNestedManyWithoutCreatedByInput
    managedProjects?: ProjectCreateNestedManyWithoutManagerInput
    clientProjects?: ProjectCreateNestedManyWithoutClientInput
    projectMembers?: ProjectMemberCreateNestedManyWithoutUserInput
    projectUpdates?: ProjectUpdateCreateNestedManyWithoutAuthorInput
    media?: MediaCreateNestedManyWithoutCreatedByInput
    paymentsCreated?: PaymentCreateNestedManyWithoutCreatedByInput
    projectsCreated?: ProjectCreateNestedManyWithoutCreatedByInput
    inspections?: InspectionCreateNestedManyWithoutEngineerInput
    reviewedInspections?: InspectionCreateNestedManyWithoutReviewedByInput
    queries?: QueryCreateNestedManyWithoutAuthorInput
    queryResponses?: QueryResponseCreateNestedManyWithoutAuthorInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
    notificationPrefs?: NotificationPreferenceCreateNestedOneWithoutUserInput
    materialsCreated?: MaterialCreateNestedManyWithoutCreatedByInput
  }

  export type UserUncheckedCreateWithoutNotificationsInput = {
    id?: string
    name: string
    email: string
    passwordHash: string
    role: $Enums.Role
    isActive?: boolean
    createdById?: string | null
    createdAt?: Date | string
    phone?: string | null
    designation?: string | null
    createdUsers?: UserUncheckedCreateNestedManyWithoutCreatedByInput
    managedProjects?: ProjectUncheckedCreateNestedManyWithoutManagerInput
    clientProjects?: ProjectUncheckedCreateNestedManyWithoutClientInput
    projectMembers?: ProjectMemberUncheckedCreateNestedManyWithoutUserInput
    projectUpdates?: ProjectUpdateUncheckedCreateNestedManyWithoutAuthorInput
    media?: MediaUncheckedCreateNestedManyWithoutCreatedByInput
    paymentsCreated?: PaymentUncheckedCreateNestedManyWithoutCreatedByInput
    projectsCreated?: ProjectUncheckedCreateNestedManyWithoutCreatedByInput
    inspections?: InspectionUncheckedCreateNestedManyWithoutEngineerInput
    reviewedInspections?: InspectionUncheckedCreateNestedManyWithoutReviewedByInput
    queries?: QueryUncheckedCreateNestedManyWithoutAuthorInput
    queryResponses?: QueryResponseUncheckedCreateNestedManyWithoutAuthorInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    notificationPrefs?: NotificationPreferenceUncheckedCreateNestedOneWithoutUserInput
    materialsCreated?: MaterialUncheckedCreateNestedManyWithoutCreatedByInput
  }

  export type UserCreateOrConnectWithoutNotificationsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutNotificationsInput, UserUncheckedCreateWithoutNotificationsInput>
  }

  export type UserUpsertWithoutNotificationsInput = {
    update: XOR<UserUpdateWithoutNotificationsInput, UserUncheckedUpdateWithoutNotificationsInput>
    create: XOR<UserCreateWithoutNotificationsInput, UserUncheckedCreateWithoutNotificationsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutNotificationsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutNotificationsInput, UserUncheckedUpdateWithoutNotificationsInput>
  }

  export type UserUpdateWithoutNotificationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    designation?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: UserUpdateOneWithoutCreatedUsersNestedInput
    createdUsers?: UserUpdateManyWithoutCreatedByNestedInput
    managedProjects?: ProjectUpdateManyWithoutManagerNestedInput
    clientProjects?: ProjectUpdateManyWithoutClientNestedInput
    projectMembers?: ProjectMemberUpdateManyWithoutUserNestedInput
    projectUpdates?: ProjectUpdateUpdateManyWithoutAuthorNestedInput
    media?: MediaUpdateManyWithoutCreatedByNestedInput
    paymentsCreated?: PaymentUpdateManyWithoutCreatedByNestedInput
    projectsCreated?: ProjectUpdateManyWithoutCreatedByNestedInput
    inspections?: InspectionUpdateManyWithoutEngineerNestedInput
    reviewedInspections?: InspectionUpdateManyWithoutReviewedByNestedInput
    queries?: QueryUpdateManyWithoutAuthorNestedInput
    queryResponses?: QueryResponseUpdateManyWithoutAuthorNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
    notificationPrefs?: NotificationPreferenceUpdateOneWithoutUserNestedInput
    materialsCreated?: MaterialUpdateManyWithoutCreatedByNestedInput
  }

  export type UserUncheckedUpdateWithoutNotificationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    designation?: NullableStringFieldUpdateOperationsInput | string | null
    createdUsers?: UserUncheckedUpdateManyWithoutCreatedByNestedInput
    managedProjects?: ProjectUncheckedUpdateManyWithoutManagerNestedInput
    clientProjects?: ProjectUncheckedUpdateManyWithoutClientNestedInput
    projectMembers?: ProjectMemberUncheckedUpdateManyWithoutUserNestedInput
    projectUpdates?: ProjectUpdateUncheckedUpdateManyWithoutAuthorNestedInput
    media?: MediaUncheckedUpdateManyWithoutCreatedByNestedInput
    paymentsCreated?: PaymentUncheckedUpdateManyWithoutCreatedByNestedInput
    projectsCreated?: ProjectUncheckedUpdateManyWithoutCreatedByNestedInput
    inspections?: InspectionUncheckedUpdateManyWithoutEngineerNestedInput
    reviewedInspections?: InspectionUncheckedUpdateManyWithoutReviewedByNestedInput
    queries?: QueryUncheckedUpdateManyWithoutAuthorNestedInput
    queryResponses?: QueryResponseUncheckedUpdateManyWithoutAuthorNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    notificationPrefs?: NotificationPreferenceUncheckedUpdateOneWithoutUserNestedInput
    materialsCreated?: MaterialUncheckedUpdateManyWithoutCreatedByNestedInput
  }

  export type UserCreateWithoutNotificationPrefsInput = {
    id?: string
    name: string
    email: string
    passwordHash: string
    role: $Enums.Role
    isActive?: boolean
    createdAt?: Date | string
    phone?: string | null
    designation?: string | null
    createdBy?: UserCreateNestedOneWithoutCreatedUsersInput
    createdUsers?: UserCreateNestedManyWithoutCreatedByInput
    managedProjects?: ProjectCreateNestedManyWithoutManagerInput
    clientProjects?: ProjectCreateNestedManyWithoutClientInput
    projectMembers?: ProjectMemberCreateNestedManyWithoutUserInput
    projectUpdates?: ProjectUpdateCreateNestedManyWithoutAuthorInput
    media?: MediaCreateNestedManyWithoutCreatedByInput
    paymentsCreated?: PaymentCreateNestedManyWithoutCreatedByInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    projectsCreated?: ProjectCreateNestedManyWithoutCreatedByInput
    inspections?: InspectionCreateNestedManyWithoutEngineerInput
    reviewedInspections?: InspectionCreateNestedManyWithoutReviewedByInput
    queries?: QueryCreateNestedManyWithoutAuthorInput
    queryResponses?: QueryResponseCreateNestedManyWithoutAuthorInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
    materialsCreated?: MaterialCreateNestedManyWithoutCreatedByInput
  }

  export type UserUncheckedCreateWithoutNotificationPrefsInput = {
    id?: string
    name: string
    email: string
    passwordHash: string
    role: $Enums.Role
    isActive?: boolean
    createdById?: string | null
    createdAt?: Date | string
    phone?: string | null
    designation?: string | null
    createdUsers?: UserUncheckedCreateNestedManyWithoutCreatedByInput
    managedProjects?: ProjectUncheckedCreateNestedManyWithoutManagerInput
    clientProjects?: ProjectUncheckedCreateNestedManyWithoutClientInput
    projectMembers?: ProjectMemberUncheckedCreateNestedManyWithoutUserInput
    projectUpdates?: ProjectUpdateUncheckedCreateNestedManyWithoutAuthorInput
    media?: MediaUncheckedCreateNestedManyWithoutCreatedByInput
    paymentsCreated?: PaymentUncheckedCreateNestedManyWithoutCreatedByInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    projectsCreated?: ProjectUncheckedCreateNestedManyWithoutCreatedByInput
    inspections?: InspectionUncheckedCreateNestedManyWithoutEngineerInput
    reviewedInspections?: InspectionUncheckedCreateNestedManyWithoutReviewedByInput
    queries?: QueryUncheckedCreateNestedManyWithoutAuthorInput
    queryResponses?: QueryResponseUncheckedCreateNestedManyWithoutAuthorInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    materialsCreated?: MaterialUncheckedCreateNestedManyWithoutCreatedByInput
  }

  export type UserCreateOrConnectWithoutNotificationPrefsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutNotificationPrefsInput, UserUncheckedCreateWithoutNotificationPrefsInput>
  }

  export type UserUpsertWithoutNotificationPrefsInput = {
    update: XOR<UserUpdateWithoutNotificationPrefsInput, UserUncheckedUpdateWithoutNotificationPrefsInput>
    create: XOR<UserCreateWithoutNotificationPrefsInput, UserUncheckedCreateWithoutNotificationPrefsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutNotificationPrefsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutNotificationPrefsInput, UserUncheckedUpdateWithoutNotificationPrefsInput>
  }

  export type UserUpdateWithoutNotificationPrefsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    designation?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: UserUpdateOneWithoutCreatedUsersNestedInput
    createdUsers?: UserUpdateManyWithoutCreatedByNestedInput
    managedProjects?: ProjectUpdateManyWithoutManagerNestedInput
    clientProjects?: ProjectUpdateManyWithoutClientNestedInput
    projectMembers?: ProjectMemberUpdateManyWithoutUserNestedInput
    projectUpdates?: ProjectUpdateUpdateManyWithoutAuthorNestedInput
    media?: MediaUpdateManyWithoutCreatedByNestedInput
    paymentsCreated?: PaymentUpdateManyWithoutCreatedByNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    projectsCreated?: ProjectUpdateManyWithoutCreatedByNestedInput
    inspections?: InspectionUpdateManyWithoutEngineerNestedInput
    reviewedInspections?: InspectionUpdateManyWithoutReviewedByNestedInput
    queries?: QueryUpdateManyWithoutAuthorNestedInput
    queryResponses?: QueryResponseUpdateManyWithoutAuthorNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
    materialsCreated?: MaterialUpdateManyWithoutCreatedByNestedInput
  }

  export type UserUncheckedUpdateWithoutNotificationPrefsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    designation?: NullableStringFieldUpdateOperationsInput | string | null
    createdUsers?: UserUncheckedUpdateManyWithoutCreatedByNestedInput
    managedProjects?: ProjectUncheckedUpdateManyWithoutManagerNestedInput
    clientProjects?: ProjectUncheckedUpdateManyWithoutClientNestedInput
    projectMembers?: ProjectMemberUncheckedUpdateManyWithoutUserNestedInput
    projectUpdates?: ProjectUpdateUncheckedUpdateManyWithoutAuthorNestedInput
    media?: MediaUncheckedUpdateManyWithoutCreatedByNestedInput
    paymentsCreated?: PaymentUncheckedUpdateManyWithoutCreatedByNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    projectsCreated?: ProjectUncheckedUpdateManyWithoutCreatedByNestedInput
    inspections?: InspectionUncheckedUpdateManyWithoutEngineerNestedInput
    reviewedInspections?: InspectionUncheckedUpdateManyWithoutReviewedByNestedInput
    queries?: QueryUncheckedUpdateManyWithoutAuthorNestedInput
    queryResponses?: QueryResponseUncheckedUpdateManyWithoutAuthorNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    materialsCreated?: MaterialUncheckedUpdateManyWithoutCreatedByNestedInput
  }

  export type ProjectCreateWithoutMilestonesInput = {
    id?: string
    name: string
    description?: string | null
    status?: $Enums.ProjectStatus
    isArchived?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy: UserCreateNestedOneWithoutProjectsCreatedInput
    manager: UserCreateNestedOneWithoutManagedProjectsInput
    client: UserCreateNestedOneWithoutClientProjectsInput
    members?: ProjectMemberCreateNestedManyWithoutProjectInput
    updates?: ProjectUpdateCreateNestedManyWithoutProjectInput
    media?: MediaCreateNestedManyWithoutProjectInput
    payments?: PaymentCreateNestedManyWithoutProjectInput
    inspections?: InspectionCreateNestedManyWithoutProjectInput
    queries?: QueryCreateNestedManyWithoutProjectInput
    materials?: MaterialCreateNestedManyWithoutProjectInput
    auditLogs?: AuditLogCreateNestedManyWithoutProjectInput
  }

  export type ProjectUncheckedCreateWithoutMilestonesInput = {
    id?: string
    name: string
    description?: string | null
    status?: $Enums.ProjectStatus
    isArchived?: boolean
    createdById: string
    managerId: string
    clientId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    members?: ProjectMemberUncheckedCreateNestedManyWithoutProjectInput
    updates?: ProjectUpdateUncheckedCreateNestedManyWithoutProjectInput
    media?: MediaUncheckedCreateNestedManyWithoutProjectInput
    payments?: PaymentUncheckedCreateNestedManyWithoutProjectInput
    inspections?: InspectionUncheckedCreateNestedManyWithoutProjectInput
    queries?: QueryUncheckedCreateNestedManyWithoutProjectInput
    materials?: MaterialUncheckedCreateNestedManyWithoutProjectInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutProjectInput
  }

  export type ProjectCreateOrConnectWithoutMilestonesInput = {
    where: ProjectWhereUniqueInput
    create: XOR<ProjectCreateWithoutMilestonesInput, ProjectUncheckedCreateWithoutMilestonesInput>
  }

  export type ChecklistItemCreateWithoutMilestoneInput = {
    id?: string
    title: string
    description?: string | null
    order: number
    isRequired?: boolean
    isPhotoRequired?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    responses?: InspectionResponseCreateNestedManyWithoutChecklistItemInput
  }

  export type ChecklistItemUncheckedCreateWithoutMilestoneInput = {
    id?: string
    title: string
    description?: string | null
    order: number
    isRequired?: boolean
    isPhotoRequired?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    responses?: InspectionResponseUncheckedCreateNestedManyWithoutChecklistItemInput
  }

  export type ChecklistItemCreateOrConnectWithoutMilestoneInput = {
    where: ChecklistItemWhereUniqueInput
    create: XOR<ChecklistItemCreateWithoutMilestoneInput, ChecklistItemUncheckedCreateWithoutMilestoneInput>
  }

  export type ChecklistItemCreateManyMilestoneInputEnvelope = {
    data: ChecklistItemCreateManyMilestoneInput | ChecklistItemCreateManyMilestoneInput[]
    skipDuplicates?: boolean
  }

  export type InspectionCreateWithoutMilestoneInput = {
    id?: string
    status?: $Enums.InspectionStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    project: ProjectCreateNestedOneWithoutInspectionsInput
    engineer: UserCreateNestedOneWithoutInspectionsInput
    responses?: InspectionResponseCreateNestedManyWithoutInspectionInput
    reviewedBy?: UserCreateNestedOneWithoutReviewedInspectionsInput
  }

  export type InspectionUncheckedCreateWithoutMilestoneInput = {
    id?: string
    status?: $Enums.InspectionStatus
    projectId: string
    engineerId: string
    reviewedById?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    responses?: InspectionResponseUncheckedCreateNestedManyWithoutInspectionInput
  }

  export type InspectionCreateOrConnectWithoutMilestoneInput = {
    where: InspectionWhereUniqueInput
    create: XOR<InspectionCreateWithoutMilestoneInput, InspectionUncheckedCreateWithoutMilestoneInput>
  }

  export type InspectionCreateManyMilestoneInputEnvelope = {
    data: InspectionCreateManyMilestoneInput | InspectionCreateManyMilestoneInput[]
    skipDuplicates?: boolean
  }

  export type ProjectUpsertWithoutMilestonesInput = {
    update: XOR<ProjectUpdateWithoutMilestonesInput, ProjectUncheckedUpdateWithoutMilestonesInput>
    create: XOR<ProjectCreateWithoutMilestonesInput, ProjectUncheckedCreateWithoutMilestonesInput>
    where?: ProjectWhereInput
  }

  export type ProjectUpdateToOneWithWhereWithoutMilestonesInput = {
    where?: ProjectWhereInput
    data: XOR<ProjectUpdateWithoutMilestonesInput, ProjectUncheckedUpdateWithoutMilestonesInput>
  }

  export type ProjectUpdateWithoutMilestonesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumProjectStatusFieldUpdateOperationsInput | $Enums.ProjectStatus
    isArchived?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: UserUpdateOneRequiredWithoutProjectsCreatedNestedInput
    manager?: UserUpdateOneRequiredWithoutManagedProjectsNestedInput
    client?: UserUpdateOneRequiredWithoutClientProjectsNestedInput
    members?: ProjectMemberUpdateManyWithoutProjectNestedInput
    updates?: ProjectUpdateUpdateManyWithoutProjectNestedInput
    media?: MediaUpdateManyWithoutProjectNestedInput
    payments?: PaymentUpdateManyWithoutProjectNestedInput
    inspections?: InspectionUpdateManyWithoutProjectNestedInput
    queries?: QueryUpdateManyWithoutProjectNestedInput
    materials?: MaterialUpdateManyWithoutProjectNestedInput
    auditLogs?: AuditLogUpdateManyWithoutProjectNestedInput
  }

  export type ProjectUncheckedUpdateWithoutMilestonesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumProjectStatusFieldUpdateOperationsInput | $Enums.ProjectStatus
    isArchived?: BoolFieldUpdateOperationsInput | boolean
    createdById?: StringFieldUpdateOperationsInput | string
    managerId?: StringFieldUpdateOperationsInput | string
    clientId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    members?: ProjectMemberUncheckedUpdateManyWithoutProjectNestedInput
    updates?: ProjectUpdateUncheckedUpdateManyWithoutProjectNestedInput
    media?: MediaUncheckedUpdateManyWithoutProjectNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutProjectNestedInput
    inspections?: InspectionUncheckedUpdateManyWithoutProjectNestedInput
    queries?: QueryUncheckedUpdateManyWithoutProjectNestedInput
    materials?: MaterialUncheckedUpdateManyWithoutProjectNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutProjectNestedInput
  }

  export type ChecklistItemUpsertWithWhereUniqueWithoutMilestoneInput = {
    where: ChecklistItemWhereUniqueInput
    update: XOR<ChecklistItemUpdateWithoutMilestoneInput, ChecklistItemUncheckedUpdateWithoutMilestoneInput>
    create: XOR<ChecklistItemCreateWithoutMilestoneInput, ChecklistItemUncheckedCreateWithoutMilestoneInput>
  }

  export type ChecklistItemUpdateWithWhereUniqueWithoutMilestoneInput = {
    where: ChecklistItemWhereUniqueInput
    data: XOR<ChecklistItemUpdateWithoutMilestoneInput, ChecklistItemUncheckedUpdateWithoutMilestoneInput>
  }

  export type ChecklistItemUpdateManyWithWhereWithoutMilestoneInput = {
    where: ChecklistItemScalarWhereInput
    data: XOR<ChecklistItemUpdateManyMutationInput, ChecklistItemUncheckedUpdateManyWithoutMilestoneInput>
  }

  export type ChecklistItemScalarWhereInput = {
    AND?: ChecklistItemScalarWhereInput | ChecklistItemScalarWhereInput[]
    OR?: ChecklistItemScalarWhereInput[]
    NOT?: ChecklistItemScalarWhereInput | ChecklistItemScalarWhereInput[]
    id?: StringFilter<"ChecklistItem"> | string
    title?: StringFilter<"ChecklistItem"> | string
    description?: StringNullableFilter<"ChecklistItem"> | string | null
    order?: IntFilter<"ChecklistItem"> | number
    isRequired?: BoolFilter<"ChecklistItem"> | boolean
    isPhotoRequired?: BoolFilter<"ChecklistItem"> | boolean
    milestoneId?: StringFilter<"ChecklistItem"> | string
    createdAt?: DateTimeFilter<"ChecklistItem"> | Date | string
    updatedAt?: DateTimeFilter<"ChecklistItem"> | Date | string
  }

  export type InspectionUpsertWithWhereUniqueWithoutMilestoneInput = {
    where: InspectionWhereUniqueInput
    update: XOR<InspectionUpdateWithoutMilestoneInput, InspectionUncheckedUpdateWithoutMilestoneInput>
    create: XOR<InspectionCreateWithoutMilestoneInput, InspectionUncheckedCreateWithoutMilestoneInput>
  }

  export type InspectionUpdateWithWhereUniqueWithoutMilestoneInput = {
    where: InspectionWhereUniqueInput
    data: XOR<InspectionUpdateWithoutMilestoneInput, InspectionUncheckedUpdateWithoutMilestoneInput>
  }

  export type InspectionUpdateManyWithWhereWithoutMilestoneInput = {
    where: InspectionScalarWhereInput
    data: XOR<InspectionUpdateManyMutationInput, InspectionUncheckedUpdateManyWithoutMilestoneInput>
  }

  export type MilestoneCreateWithoutChecklistItemsInput = {
    id?: string
    name: string
    description?: string | null
    order: number
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    project: ProjectCreateNestedOneWithoutMilestonesInput
    inspections?: InspectionCreateNestedManyWithoutMilestoneInput
  }

  export type MilestoneUncheckedCreateWithoutChecklistItemsInput = {
    id?: string
    name: string
    description?: string | null
    order: number
    isActive?: boolean
    projectId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    inspections?: InspectionUncheckedCreateNestedManyWithoutMilestoneInput
  }

  export type MilestoneCreateOrConnectWithoutChecklistItemsInput = {
    where: MilestoneWhereUniqueInput
    create: XOR<MilestoneCreateWithoutChecklistItemsInput, MilestoneUncheckedCreateWithoutChecklistItemsInput>
  }

  export type InspectionResponseCreateWithoutChecklistItemInput = {
    id?: string
    result: $Enums.ChecklistResult
    remark?: string | null
    inspection: InspectionCreateNestedOneWithoutResponsesInput
    media?: MediaCreateNestedOneWithoutInspectionResponsesInput
  }

  export type InspectionResponseUncheckedCreateWithoutChecklistItemInput = {
    id?: string
    result: $Enums.ChecklistResult
    remark?: string | null
    inspectionId: string
    mediaId?: string | null
  }

  export type InspectionResponseCreateOrConnectWithoutChecklistItemInput = {
    where: InspectionResponseWhereUniqueInput
    create: XOR<InspectionResponseCreateWithoutChecklistItemInput, InspectionResponseUncheckedCreateWithoutChecklistItemInput>
  }

  export type InspectionResponseCreateManyChecklistItemInputEnvelope = {
    data: InspectionResponseCreateManyChecklistItemInput | InspectionResponseCreateManyChecklistItemInput[]
    skipDuplicates?: boolean
  }

  export type MilestoneUpsertWithoutChecklistItemsInput = {
    update: XOR<MilestoneUpdateWithoutChecklistItemsInput, MilestoneUncheckedUpdateWithoutChecklistItemsInput>
    create: XOR<MilestoneCreateWithoutChecklistItemsInput, MilestoneUncheckedCreateWithoutChecklistItemsInput>
    where?: MilestoneWhereInput
  }

  export type MilestoneUpdateToOneWithWhereWithoutChecklistItemsInput = {
    where?: MilestoneWhereInput
    data: XOR<MilestoneUpdateWithoutChecklistItemsInput, MilestoneUncheckedUpdateWithoutChecklistItemsInput>
  }

  export type MilestoneUpdateWithoutChecklistItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    order?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    project?: ProjectUpdateOneRequiredWithoutMilestonesNestedInput
    inspections?: InspectionUpdateManyWithoutMilestoneNestedInput
  }

  export type MilestoneUncheckedUpdateWithoutChecklistItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    order?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    projectId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    inspections?: InspectionUncheckedUpdateManyWithoutMilestoneNestedInput
  }

  export type InspectionResponseUpsertWithWhereUniqueWithoutChecklistItemInput = {
    where: InspectionResponseWhereUniqueInput
    update: XOR<InspectionResponseUpdateWithoutChecklistItemInput, InspectionResponseUncheckedUpdateWithoutChecklistItemInput>
    create: XOR<InspectionResponseCreateWithoutChecklistItemInput, InspectionResponseUncheckedCreateWithoutChecklistItemInput>
  }

  export type InspectionResponseUpdateWithWhereUniqueWithoutChecklistItemInput = {
    where: InspectionResponseWhereUniqueInput
    data: XOR<InspectionResponseUpdateWithoutChecklistItemInput, InspectionResponseUncheckedUpdateWithoutChecklistItemInput>
  }

  export type InspectionResponseUpdateManyWithWhereWithoutChecklistItemInput = {
    where: InspectionResponseScalarWhereInput
    data: XOR<InspectionResponseUpdateManyMutationInput, InspectionResponseUncheckedUpdateManyWithoutChecklistItemInput>
  }

  export type ProjectCreateWithoutInspectionsInput = {
    id?: string
    name: string
    description?: string | null
    status?: $Enums.ProjectStatus
    isArchived?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy: UserCreateNestedOneWithoutProjectsCreatedInput
    manager: UserCreateNestedOneWithoutManagedProjectsInput
    client: UserCreateNestedOneWithoutClientProjectsInput
    members?: ProjectMemberCreateNestedManyWithoutProjectInput
    updates?: ProjectUpdateCreateNestedManyWithoutProjectInput
    media?: MediaCreateNestedManyWithoutProjectInput
    payments?: PaymentCreateNestedManyWithoutProjectInput
    milestones?: MilestoneCreateNestedManyWithoutProjectInput
    queries?: QueryCreateNestedManyWithoutProjectInput
    materials?: MaterialCreateNestedManyWithoutProjectInput
    auditLogs?: AuditLogCreateNestedManyWithoutProjectInput
  }

  export type ProjectUncheckedCreateWithoutInspectionsInput = {
    id?: string
    name: string
    description?: string | null
    status?: $Enums.ProjectStatus
    isArchived?: boolean
    createdById: string
    managerId: string
    clientId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    members?: ProjectMemberUncheckedCreateNestedManyWithoutProjectInput
    updates?: ProjectUpdateUncheckedCreateNestedManyWithoutProjectInput
    media?: MediaUncheckedCreateNestedManyWithoutProjectInput
    payments?: PaymentUncheckedCreateNestedManyWithoutProjectInput
    milestones?: MilestoneUncheckedCreateNestedManyWithoutProjectInput
    queries?: QueryUncheckedCreateNestedManyWithoutProjectInput
    materials?: MaterialUncheckedCreateNestedManyWithoutProjectInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutProjectInput
  }

  export type ProjectCreateOrConnectWithoutInspectionsInput = {
    where: ProjectWhereUniqueInput
    create: XOR<ProjectCreateWithoutInspectionsInput, ProjectUncheckedCreateWithoutInspectionsInput>
  }

  export type MilestoneCreateWithoutInspectionsInput = {
    id?: string
    name: string
    description?: string | null
    order: number
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    project: ProjectCreateNestedOneWithoutMilestonesInput
    checklistItems?: ChecklistItemCreateNestedManyWithoutMilestoneInput
  }

  export type MilestoneUncheckedCreateWithoutInspectionsInput = {
    id?: string
    name: string
    description?: string | null
    order: number
    isActive?: boolean
    projectId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    checklistItems?: ChecklistItemUncheckedCreateNestedManyWithoutMilestoneInput
  }

  export type MilestoneCreateOrConnectWithoutInspectionsInput = {
    where: MilestoneWhereUniqueInput
    create: XOR<MilestoneCreateWithoutInspectionsInput, MilestoneUncheckedCreateWithoutInspectionsInput>
  }

  export type UserCreateWithoutInspectionsInput = {
    id?: string
    name: string
    email: string
    passwordHash: string
    role: $Enums.Role
    isActive?: boolean
    createdAt?: Date | string
    phone?: string | null
    designation?: string | null
    createdBy?: UserCreateNestedOneWithoutCreatedUsersInput
    createdUsers?: UserCreateNestedManyWithoutCreatedByInput
    managedProjects?: ProjectCreateNestedManyWithoutManagerInput
    clientProjects?: ProjectCreateNestedManyWithoutClientInput
    projectMembers?: ProjectMemberCreateNestedManyWithoutUserInput
    projectUpdates?: ProjectUpdateCreateNestedManyWithoutAuthorInput
    media?: MediaCreateNestedManyWithoutCreatedByInput
    paymentsCreated?: PaymentCreateNestedManyWithoutCreatedByInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    projectsCreated?: ProjectCreateNestedManyWithoutCreatedByInput
    reviewedInspections?: InspectionCreateNestedManyWithoutReviewedByInput
    queries?: QueryCreateNestedManyWithoutAuthorInput
    queryResponses?: QueryResponseCreateNestedManyWithoutAuthorInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
    notificationPrefs?: NotificationPreferenceCreateNestedOneWithoutUserInput
    materialsCreated?: MaterialCreateNestedManyWithoutCreatedByInput
  }

  export type UserUncheckedCreateWithoutInspectionsInput = {
    id?: string
    name: string
    email: string
    passwordHash: string
    role: $Enums.Role
    isActive?: boolean
    createdById?: string | null
    createdAt?: Date | string
    phone?: string | null
    designation?: string | null
    createdUsers?: UserUncheckedCreateNestedManyWithoutCreatedByInput
    managedProjects?: ProjectUncheckedCreateNestedManyWithoutManagerInput
    clientProjects?: ProjectUncheckedCreateNestedManyWithoutClientInput
    projectMembers?: ProjectMemberUncheckedCreateNestedManyWithoutUserInput
    projectUpdates?: ProjectUpdateUncheckedCreateNestedManyWithoutAuthorInput
    media?: MediaUncheckedCreateNestedManyWithoutCreatedByInput
    paymentsCreated?: PaymentUncheckedCreateNestedManyWithoutCreatedByInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    projectsCreated?: ProjectUncheckedCreateNestedManyWithoutCreatedByInput
    reviewedInspections?: InspectionUncheckedCreateNestedManyWithoutReviewedByInput
    queries?: QueryUncheckedCreateNestedManyWithoutAuthorInput
    queryResponses?: QueryResponseUncheckedCreateNestedManyWithoutAuthorInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    notificationPrefs?: NotificationPreferenceUncheckedCreateNestedOneWithoutUserInput
    materialsCreated?: MaterialUncheckedCreateNestedManyWithoutCreatedByInput
  }

  export type UserCreateOrConnectWithoutInspectionsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutInspectionsInput, UserUncheckedCreateWithoutInspectionsInput>
  }

  export type InspectionResponseCreateWithoutInspectionInput = {
    id?: string
    result: $Enums.ChecklistResult
    remark?: string | null
    checklistItem: ChecklistItemCreateNestedOneWithoutResponsesInput
    media?: MediaCreateNestedOneWithoutInspectionResponsesInput
  }

  export type InspectionResponseUncheckedCreateWithoutInspectionInput = {
    id?: string
    result: $Enums.ChecklistResult
    remark?: string | null
    checklistItemId: string
    mediaId?: string | null
  }

  export type InspectionResponseCreateOrConnectWithoutInspectionInput = {
    where: InspectionResponseWhereUniqueInput
    create: XOR<InspectionResponseCreateWithoutInspectionInput, InspectionResponseUncheckedCreateWithoutInspectionInput>
  }

  export type InspectionResponseCreateManyInspectionInputEnvelope = {
    data: InspectionResponseCreateManyInspectionInput | InspectionResponseCreateManyInspectionInput[]
    skipDuplicates?: boolean
  }

  export type UserCreateWithoutReviewedInspectionsInput = {
    id?: string
    name: string
    email: string
    passwordHash: string
    role: $Enums.Role
    isActive?: boolean
    createdAt?: Date | string
    phone?: string | null
    designation?: string | null
    createdBy?: UserCreateNestedOneWithoutCreatedUsersInput
    createdUsers?: UserCreateNestedManyWithoutCreatedByInput
    managedProjects?: ProjectCreateNestedManyWithoutManagerInput
    clientProjects?: ProjectCreateNestedManyWithoutClientInput
    projectMembers?: ProjectMemberCreateNestedManyWithoutUserInput
    projectUpdates?: ProjectUpdateCreateNestedManyWithoutAuthorInput
    media?: MediaCreateNestedManyWithoutCreatedByInput
    paymentsCreated?: PaymentCreateNestedManyWithoutCreatedByInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    projectsCreated?: ProjectCreateNestedManyWithoutCreatedByInput
    inspections?: InspectionCreateNestedManyWithoutEngineerInput
    queries?: QueryCreateNestedManyWithoutAuthorInput
    queryResponses?: QueryResponseCreateNestedManyWithoutAuthorInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
    notificationPrefs?: NotificationPreferenceCreateNestedOneWithoutUserInput
    materialsCreated?: MaterialCreateNestedManyWithoutCreatedByInput
  }

  export type UserUncheckedCreateWithoutReviewedInspectionsInput = {
    id?: string
    name: string
    email: string
    passwordHash: string
    role: $Enums.Role
    isActive?: boolean
    createdById?: string | null
    createdAt?: Date | string
    phone?: string | null
    designation?: string | null
    createdUsers?: UserUncheckedCreateNestedManyWithoutCreatedByInput
    managedProjects?: ProjectUncheckedCreateNestedManyWithoutManagerInput
    clientProjects?: ProjectUncheckedCreateNestedManyWithoutClientInput
    projectMembers?: ProjectMemberUncheckedCreateNestedManyWithoutUserInput
    projectUpdates?: ProjectUpdateUncheckedCreateNestedManyWithoutAuthorInput
    media?: MediaUncheckedCreateNestedManyWithoutCreatedByInput
    paymentsCreated?: PaymentUncheckedCreateNestedManyWithoutCreatedByInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    projectsCreated?: ProjectUncheckedCreateNestedManyWithoutCreatedByInput
    inspections?: InspectionUncheckedCreateNestedManyWithoutEngineerInput
    queries?: QueryUncheckedCreateNestedManyWithoutAuthorInput
    queryResponses?: QueryResponseUncheckedCreateNestedManyWithoutAuthorInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    notificationPrefs?: NotificationPreferenceUncheckedCreateNestedOneWithoutUserInput
    materialsCreated?: MaterialUncheckedCreateNestedManyWithoutCreatedByInput
  }

  export type UserCreateOrConnectWithoutReviewedInspectionsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutReviewedInspectionsInput, UserUncheckedCreateWithoutReviewedInspectionsInput>
  }

  export type ProjectUpsertWithoutInspectionsInput = {
    update: XOR<ProjectUpdateWithoutInspectionsInput, ProjectUncheckedUpdateWithoutInspectionsInput>
    create: XOR<ProjectCreateWithoutInspectionsInput, ProjectUncheckedCreateWithoutInspectionsInput>
    where?: ProjectWhereInput
  }

  export type ProjectUpdateToOneWithWhereWithoutInspectionsInput = {
    where?: ProjectWhereInput
    data: XOR<ProjectUpdateWithoutInspectionsInput, ProjectUncheckedUpdateWithoutInspectionsInput>
  }

  export type ProjectUpdateWithoutInspectionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumProjectStatusFieldUpdateOperationsInput | $Enums.ProjectStatus
    isArchived?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: UserUpdateOneRequiredWithoutProjectsCreatedNestedInput
    manager?: UserUpdateOneRequiredWithoutManagedProjectsNestedInput
    client?: UserUpdateOneRequiredWithoutClientProjectsNestedInput
    members?: ProjectMemberUpdateManyWithoutProjectNestedInput
    updates?: ProjectUpdateUpdateManyWithoutProjectNestedInput
    media?: MediaUpdateManyWithoutProjectNestedInput
    payments?: PaymentUpdateManyWithoutProjectNestedInput
    milestones?: MilestoneUpdateManyWithoutProjectNestedInput
    queries?: QueryUpdateManyWithoutProjectNestedInput
    materials?: MaterialUpdateManyWithoutProjectNestedInput
    auditLogs?: AuditLogUpdateManyWithoutProjectNestedInput
  }

  export type ProjectUncheckedUpdateWithoutInspectionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumProjectStatusFieldUpdateOperationsInput | $Enums.ProjectStatus
    isArchived?: BoolFieldUpdateOperationsInput | boolean
    createdById?: StringFieldUpdateOperationsInput | string
    managerId?: StringFieldUpdateOperationsInput | string
    clientId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    members?: ProjectMemberUncheckedUpdateManyWithoutProjectNestedInput
    updates?: ProjectUpdateUncheckedUpdateManyWithoutProjectNestedInput
    media?: MediaUncheckedUpdateManyWithoutProjectNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutProjectNestedInput
    milestones?: MilestoneUncheckedUpdateManyWithoutProjectNestedInput
    queries?: QueryUncheckedUpdateManyWithoutProjectNestedInput
    materials?: MaterialUncheckedUpdateManyWithoutProjectNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutProjectNestedInput
  }

  export type MilestoneUpsertWithoutInspectionsInput = {
    update: XOR<MilestoneUpdateWithoutInspectionsInput, MilestoneUncheckedUpdateWithoutInspectionsInput>
    create: XOR<MilestoneCreateWithoutInspectionsInput, MilestoneUncheckedCreateWithoutInspectionsInput>
    where?: MilestoneWhereInput
  }

  export type MilestoneUpdateToOneWithWhereWithoutInspectionsInput = {
    where?: MilestoneWhereInput
    data: XOR<MilestoneUpdateWithoutInspectionsInput, MilestoneUncheckedUpdateWithoutInspectionsInput>
  }

  export type MilestoneUpdateWithoutInspectionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    order?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    project?: ProjectUpdateOneRequiredWithoutMilestonesNestedInput
    checklistItems?: ChecklistItemUpdateManyWithoutMilestoneNestedInput
  }

  export type MilestoneUncheckedUpdateWithoutInspectionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    order?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    projectId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    checklistItems?: ChecklistItemUncheckedUpdateManyWithoutMilestoneNestedInput
  }

  export type UserUpsertWithoutInspectionsInput = {
    update: XOR<UserUpdateWithoutInspectionsInput, UserUncheckedUpdateWithoutInspectionsInput>
    create: XOR<UserCreateWithoutInspectionsInput, UserUncheckedCreateWithoutInspectionsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutInspectionsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutInspectionsInput, UserUncheckedUpdateWithoutInspectionsInput>
  }

  export type UserUpdateWithoutInspectionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    designation?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: UserUpdateOneWithoutCreatedUsersNestedInput
    createdUsers?: UserUpdateManyWithoutCreatedByNestedInput
    managedProjects?: ProjectUpdateManyWithoutManagerNestedInput
    clientProjects?: ProjectUpdateManyWithoutClientNestedInput
    projectMembers?: ProjectMemberUpdateManyWithoutUserNestedInput
    projectUpdates?: ProjectUpdateUpdateManyWithoutAuthorNestedInput
    media?: MediaUpdateManyWithoutCreatedByNestedInput
    paymentsCreated?: PaymentUpdateManyWithoutCreatedByNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    projectsCreated?: ProjectUpdateManyWithoutCreatedByNestedInput
    reviewedInspections?: InspectionUpdateManyWithoutReviewedByNestedInput
    queries?: QueryUpdateManyWithoutAuthorNestedInput
    queryResponses?: QueryResponseUpdateManyWithoutAuthorNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
    notificationPrefs?: NotificationPreferenceUpdateOneWithoutUserNestedInput
    materialsCreated?: MaterialUpdateManyWithoutCreatedByNestedInput
  }

  export type UserUncheckedUpdateWithoutInspectionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    designation?: NullableStringFieldUpdateOperationsInput | string | null
    createdUsers?: UserUncheckedUpdateManyWithoutCreatedByNestedInput
    managedProjects?: ProjectUncheckedUpdateManyWithoutManagerNestedInput
    clientProjects?: ProjectUncheckedUpdateManyWithoutClientNestedInput
    projectMembers?: ProjectMemberUncheckedUpdateManyWithoutUserNestedInput
    projectUpdates?: ProjectUpdateUncheckedUpdateManyWithoutAuthorNestedInput
    media?: MediaUncheckedUpdateManyWithoutCreatedByNestedInput
    paymentsCreated?: PaymentUncheckedUpdateManyWithoutCreatedByNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    projectsCreated?: ProjectUncheckedUpdateManyWithoutCreatedByNestedInput
    reviewedInspections?: InspectionUncheckedUpdateManyWithoutReviewedByNestedInput
    queries?: QueryUncheckedUpdateManyWithoutAuthorNestedInput
    queryResponses?: QueryResponseUncheckedUpdateManyWithoutAuthorNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    notificationPrefs?: NotificationPreferenceUncheckedUpdateOneWithoutUserNestedInput
    materialsCreated?: MaterialUncheckedUpdateManyWithoutCreatedByNestedInput
  }

  export type InspectionResponseUpsertWithWhereUniqueWithoutInspectionInput = {
    where: InspectionResponseWhereUniqueInput
    update: XOR<InspectionResponseUpdateWithoutInspectionInput, InspectionResponseUncheckedUpdateWithoutInspectionInput>
    create: XOR<InspectionResponseCreateWithoutInspectionInput, InspectionResponseUncheckedCreateWithoutInspectionInput>
  }

  export type InspectionResponseUpdateWithWhereUniqueWithoutInspectionInput = {
    where: InspectionResponseWhereUniqueInput
    data: XOR<InspectionResponseUpdateWithoutInspectionInput, InspectionResponseUncheckedUpdateWithoutInspectionInput>
  }

  export type InspectionResponseUpdateManyWithWhereWithoutInspectionInput = {
    where: InspectionResponseScalarWhereInput
    data: XOR<InspectionResponseUpdateManyMutationInput, InspectionResponseUncheckedUpdateManyWithoutInspectionInput>
  }

  export type UserUpsertWithoutReviewedInspectionsInput = {
    update: XOR<UserUpdateWithoutReviewedInspectionsInput, UserUncheckedUpdateWithoutReviewedInspectionsInput>
    create: XOR<UserCreateWithoutReviewedInspectionsInput, UserUncheckedCreateWithoutReviewedInspectionsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutReviewedInspectionsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutReviewedInspectionsInput, UserUncheckedUpdateWithoutReviewedInspectionsInput>
  }

  export type UserUpdateWithoutReviewedInspectionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    designation?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: UserUpdateOneWithoutCreatedUsersNestedInput
    createdUsers?: UserUpdateManyWithoutCreatedByNestedInput
    managedProjects?: ProjectUpdateManyWithoutManagerNestedInput
    clientProjects?: ProjectUpdateManyWithoutClientNestedInput
    projectMembers?: ProjectMemberUpdateManyWithoutUserNestedInput
    projectUpdates?: ProjectUpdateUpdateManyWithoutAuthorNestedInput
    media?: MediaUpdateManyWithoutCreatedByNestedInput
    paymentsCreated?: PaymentUpdateManyWithoutCreatedByNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    projectsCreated?: ProjectUpdateManyWithoutCreatedByNestedInput
    inspections?: InspectionUpdateManyWithoutEngineerNestedInput
    queries?: QueryUpdateManyWithoutAuthorNestedInput
    queryResponses?: QueryResponseUpdateManyWithoutAuthorNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
    notificationPrefs?: NotificationPreferenceUpdateOneWithoutUserNestedInput
    materialsCreated?: MaterialUpdateManyWithoutCreatedByNestedInput
  }

  export type UserUncheckedUpdateWithoutReviewedInspectionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    designation?: NullableStringFieldUpdateOperationsInput | string | null
    createdUsers?: UserUncheckedUpdateManyWithoutCreatedByNestedInput
    managedProjects?: ProjectUncheckedUpdateManyWithoutManagerNestedInput
    clientProjects?: ProjectUncheckedUpdateManyWithoutClientNestedInput
    projectMembers?: ProjectMemberUncheckedUpdateManyWithoutUserNestedInput
    projectUpdates?: ProjectUpdateUncheckedUpdateManyWithoutAuthorNestedInput
    media?: MediaUncheckedUpdateManyWithoutCreatedByNestedInput
    paymentsCreated?: PaymentUncheckedUpdateManyWithoutCreatedByNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    projectsCreated?: ProjectUncheckedUpdateManyWithoutCreatedByNestedInput
    inspections?: InspectionUncheckedUpdateManyWithoutEngineerNestedInput
    queries?: QueryUncheckedUpdateManyWithoutAuthorNestedInput
    queryResponses?: QueryResponseUncheckedUpdateManyWithoutAuthorNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    notificationPrefs?: NotificationPreferenceUncheckedUpdateOneWithoutUserNestedInput
    materialsCreated?: MaterialUncheckedUpdateManyWithoutCreatedByNestedInput
  }

  export type InspectionCreateWithoutResponsesInput = {
    id?: string
    status?: $Enums.InspectionStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    project: ProjectCreateNestedOneWithoutInspectionsInput
    milestone: MilestoneCreateNestedOneWithoutInspectionsInput
    engineer: UserCreateNestedOneWithoutInspectionsInput
    reviewedBy?: UserCreateNestedOneWithoutReviewedInspectionsInput
  }

  export type InspectionUncheckedCreateWithoutResponsesInput = {
    id?: string
    status?: $Enums.InspectionStatus
    projectId: string
    milestoneId: string
    engineerId: string
    reviewedById?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type InspectionCreateOrConnectWithoutResponsesInput = {
    where: InspectionWhereUniqueInput
    create: XOR<InspectionCreateWithoutResponsesInput, InspectionUncheckedCreateWithoutResponsesInput>
  }

  export type ChecklistItemCreateWithoutResponsesInput = {
    id?: string
    title: string
    description?: string | null
    order: number
    isRequired?: boolean
    isPhotoRequired?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    milestone: MilestoneCreateNestedOneWithoutChecklistItemsInput
  }

  export type ChecklistItemUncheckedCreateWithoutResponsesInput = {
    id?: string
    title: string
    description?: string | null
    order: number
    isRequired?: boolean
    isPhotoRequired?: boolean
    milestoneId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ChecklistItemCreateOrConnectWithoutResponsesInput = {
    where: ChecklistItemWhereUniqueInput
    create: XOR<ChecklistItemCreateWithoutResponsesInput, ChecklistItemUncheckedCreateWithoutResponsesInput>
  }

  export type MediaCreateWithoutInspectionResponsesInput = {
    id?: string
    type: $Enums.MediaType
    fileKey: string
    fileUrl: string
    mimeType: string
    fileSize: number
    approvedBy?: string | null
    approvedAt?: Date | string | null
    version?: number | null
    createdAt?: Date | string
    project: ProjectCreateNestedOneWithoutMediaInput
    projectUpdate?: ProjectUpdateCreateNestedOneWithoutMediaInput
    payment?: PaymentCreateNestedOneWithoutMediaInput
    createdBy: UserCreateNestedOneWithoutMediaInput
    query?: QueryCreateNestedOneWithoutAttachmentsInput
  }

  export type MediaUncheckedCreateWithoutInspectionResponsesInput = {
    id?: string
    projectId: string
    projectUpdateId?: string | null
    paymentId?: string | null
    type: $Enums.MediaType
    fileKey: string
    fileUrl: string
    mimeType: string
    fileSize: number
    createdById: string
    approvedBy?: string | null
    approvedAt?: Date | string | null
    version?: number | null
    createdAt?: Date | string
    queryId?: string | null
  }

  export type MediaCreateOrConnectWithoutInspectionResponsesInput = {
    where: MediaWhereUniqueInput
    create: XOR<MediaCreateWithoutInspectionResponsesInput, MediaUncheckedCreateWithoutInspectionResponsesInput>
  }

  export type InspectionUpsertWithoutResponsesInput = {
    update: XOR<InspectionUpdateWithoutResponsesInput, InspectionUncheckedUpdateWithoutResponsesInput>
    create: XOR<InspectionCreateWithoutResponsesInput, InspectionUncheckedCreateWithoutResponsesInput>
    where?: InspectionWhereInput
  }

  export type InspectionUpdateToOneWithWhereWithoutResponsesInput = {
    where?: InspectionWhereInput
    data: XOR<InspectionUpdateWithoutResponsesInput, InspectionUncheckedUpdateWithoutResponsesInput>
  }

  export type InspectionUpdateWithoutResponsesInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumInspectionStatusFieldUpdateOperationsInput | $Enums.InspectionStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    project?: ProjectUpdateOneRequiredWithoutInspectionsNestedInput
    milestone?: MilestoneUpdateOneRequiredWithoutInspectionsNestedInput
    engineer?: UserUpdateOneRequiredWithoutInspectionsNestedInput
    reviewedBy?: UserUpdateOneWithoutReviewedInspectionsNestedInput
  }

  export type InspectionUncheckedUpdateWithoutResponsesInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumInspectionStatusFieldUpdateOperationsInput | $Enums.InspectionStatus
    projectId?: StringFieldUpdateOperationsInput | string
    milestoneId?: StringFieldUpdateOperationsInput | string
    engineerId?: StringFieldUpdateOperationsInput | string
    reviewedById?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ChecklistItemUpsertWithoutResponsesInput = {
    update: XOR<ChecklistItemUpdateWithoutResponsesInput, ChecklistItemUncheckedUpdateWithoutResponsesInput>
    create: XOR<ChecklistItemCreateWithoutResponsesInput, ChecklistItemUncheckedCreateWithoutResponsesInput>
    where?: ChecklistItemWhereInput
  }

  export type ChecklistItemUpdateToOneWithWhereWithoutResponsesInput = {
    where?: ChecklistItemWhereInput
    data: XOR<ChecklistItemUpdateWithoutResponsesInput, ChecklistItemUncheckedUpdateWithoutResponsesInput>
  }

  export type ChecklistItemUpdateWithoutResponsesInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    order?: IntFieldUpdateOperationsInput | number
    isRequired?: BoolFieldUpdateOperationsInput | boolean
    isPhotoRequired?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    milestone?: MilestoneUpdateOneRequiredWithoutChecklistItemsNestedInput
  }

  export type ChecklistItemUncheckedUpdateWithoutResponsesInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    order?: IntFieldUpdateOperationsInput | number
    isRequired?: BoolFieldUpdateOperationsInput | boolean
    isPhotoRequired?: BoolFieldUpdateOperationsInput | boolean
    milestoneId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MediaUpsertWithoutInspectionResponsesInput = {
    update: XOR<MediaUpdateWithoutInspectionResponsesInput, MediaUncheckedUpdateWithoutInspectionResponsesInput>
    create: XOR<MediaCreateWithoutInspectionResponsesInput, MediaUncheckedCreateWithoutInspectionResponsesInput>
    where?: MediaWhereInput
  }

  export type MediaUpdateToOneWithWhereWithoutInspectionResponsesInput = {
    where?: MediaWhereInput
    data: XOR<MediaUpdateWithoutInspectionResponsesInput, MediaUncheckedUpdateWithoutInspectionResponsesInput>
  }

  export type MediaUpdateWithoutInspectionResponsesInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumMediaTypeFieldUpdateOperationsInput | $Enums.MediaType
    fileKey?: StringFieldUpdateOperationsInput | string
    fileUrl?: StringFieldUpdateOperationsInput | string
    mimeType?: StringFieldUpdateOperationsInput | string
    fileSize?: IntFieldUpdateOperationsInput | number
    approvedBy?: NullableStringFieldUpdateOperationsInput | string | null
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    version?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    project?: ProjectUpdateOneRequiredWithoutMediaNestedInput
    projectUpdate?: ProjectUpdateUpdateOneWithoutMediaNestedInput
    payment?: PaymentUpdateOneWithoutMediaNestedInput
    createdBy?: UserUpdateOneRequiredWithoutMediaNestedInput
    query?: QueryUpdateOneWithoutAttachmentsNestedInput
  }

  export type MediaUncheckedUpdateWithoutInspectionResponsesInput = {
    id?: StringFieldUpdateOperationsInput | string
    projectId?: StringFieldUpdateOperationsInput | string
    projectUpdateId?: NullableStringFieldUpdateOperationsInput | string | null
    paymentId?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumMediaTypeFieldUpdateOperationsInput | $Enums.MediaType
    fileKey?: StringFieldUpdateOperationsInput | string
    fileUrl?: StringFieldUpdateOperationsInput | string
    mimeType?: StringFieldUpdateOperationsInput | string
    fileSize?: IntFieldUpdateOperationsInput | number
    createdById?: StringFieldUpdateOperationsInput | string
    approvedBy?: NullableStringFieldUpdateOperationsInput | string | null
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    version?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    queryId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ProjectCreateWithoutQueriesInput = {
    id?: string
    name: string
    description?: string | null
    status?: $Enums.ProjectStatus
    isArchived?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy: UserCreateNestedOneWithoutProjectsCreatedInput
    manager: UserCreateNestedOneWithoutManagedProjectsInput
    client: UserCreateNestedOneWithoutClientProjectsInput
    members?: ProjectMemberCreateNestedManyWithoutProjectInput
    updates?: ProjectUpdateCreateNestedManyWithoutProjectInput
    media?: MediaCreateNestedManyWithoutProjectInput
    payments?: PaymentCreateNestedManyWithoutProjectInput
    milestones?: MilestoneCreateNestedManyWithoutProjectInput
    inspections?: InspectionCreateNestedManyWithoutProjectInput
    materials?: MaterialCreateNestedManyWithoutProjectInput
    auditLogs?: AuditLogCreateNestedManyWithoutProjectInput
  }

  export type ProjectUncheckedCreateWithoutQueriesInput = {
    id?: string
    name: string
    description?: string | null
    status?: $Enums.ProjectStatus
    isArchived?: boolean
    createdById: string
    managerId: string
    clientId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    members?: ProjectMemberUncheckedCreateNestedManyWithoutProjectInput
    updates?: ProjectUpdateUncheckedCreateNestedManyWithoutProjectInput
    media?: MediaUncheckedCreateNestedManyWithoutProjectInput
    payments?: PaymentUncheckedCreateNestedManyWithoutProjectInput
    milestones?: MilestoneUncheckedCreateNestedManyWithoutProjectInput
    inspections?: InspectionUncheckedCreateNestedManyWithoutProjectInput
    materials?: MaterialUncheckedCreateNestedManyWithoutProjectInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutProjectInput
  }

  export type ProjectCreateOrConnectWithoutQueriesInput = {
    where: ProjectWhereUniqueInput
    create: XOR<ProjectCreateWithoutQueriesInput, ProjectUncheckedCreateWithoutQueriesInput>
  }

  export type UserCreateWithoutQueriesInput = {
    id?: string
    name: string
    email: string
    passwordHash: string
    role: $Enums.Role
    isActive?: boolean
    createdAt?: Date | string
    phone?: string | null
    designation?: string | null
    createdBy?: UserCreateNestedOneWithoutCreatedUsersInput
    createdUsers?: UserCreateNestedManyWithoutCreatedByInput
    managedProjects?: ProjectCreateNestedManyWithoutManagerInput
    clientProjects?: ProjectCreateNestedManyWithoutClientInput
    projectMembers?: ProjectMemberCreateNestedManyWithoutUserInput
    projectUpdates?: ProjectUpdateCreateNestedManyWithoutAuthorInput
    media?: MediaCreateNestedManyWithoutCreatedByInput
    paymentsCreated?: PaymentCreateNestedManyWithoutCreatedByInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    projectsCreated?: ProjectCreateNestedManyWithoutCreatedByInput
    inspections?: InspectionCreateNestedManyWithoutEngineerInput
    reviewedInspections?: InspectionCreateNestedManyWithoutReviewedByInput
    queryResponses?: QueryResponseCreateNestedManyWithoutAuthorInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
    notificationPrefs?: NotificationPreferenceCreateNestedOneWithoutUserInput
    materialsCreated?: MaterialCreateNestedManyWithoutCreatedByInput
  }

  export type UserUncheckedCreateWithoutQueriesInput = {
    id?: string
    name: string
    email: string
    passwordHash: string
    role: $Enums.Role
    isActive?: boolean
    createdById?: string | null
    createdAt?: Date | string
    phone?: string | null
    designation?: string | null
    createdUsers?: UserUncheckedCreateNestedManyWithoutCreatedByInput
    managedProjects?: ProjectUncheckedCreateNestedManyWithoutManagerInput
    clientProjects?: ProjectUncheckedCreateNestedManyWithoutClientInput
    projectMembers?: ProjectMemberUncheckedCreateNestedManyWithoutUserInput
    projectUpdates?: ProjectUpdateUncheckedCreateNestedManyWithoutAuthorInput
    media?: MediaUncheckedCreateNestedManyWithoutCreatedByInput
    paymentsCreated?: PaymentUncheckedCreateNestedManyWithoutCreatedByInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    projectsCreated?: ProjectUncheckedCreateNestedManyWithoutCreatedByInput
    inspections?: InspectionUncheckedCreateNestedManyWithoutEngineerInput
    reviewedInspections?: InspectionUncheckedCreateNestedManyWithoutReviewedByInput
    queryResponses?: QueryResponseUncheckedCreateNestedManyWithoutAuthorInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    notificationPrefs?: NotificationPreferenceUncheckedCreateNestedOneWithoutUserInput
    materialsCreated?: MaterialUncheckedCreateNestedManyWithoutCreatedByInput
  }

  export type UserCreateOrConnectWithoutQueriesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutQueriesInput, UserUncheckedCreateWithoutQueriesInput>
  }

  export type MediaCreateWithoutQueryInput = {
    id?: string
    type: $Enums.MediaType
    fileKey: string
    fileUrl: string
    mimeType: string
    fileSize: number
    approvedBy?: string | null
    approvedAt?: Date | string | null
    version?: number | null
    createdAt?: Date | string
    project: ProjectCreateNestedOneWithoutMediaInput
    projectUpdate?: ProjectUpdateCreateNestedOneWithoutMediaInput
    payment?: PaymentCreateNestedOneWithoutMediaInput
    createdBy: UserCreateNestedOneWithoutMediaInput
    inspectionResponses?: InspectionResponseCreateNestedManyWithoutMediaInput
  }

  export type MediaUncheckedCreateWithoutQueryInput = {
    id?: string
    projectId: string
    projectUpdateId?: string | null
    paymentId?: string | null
    type: $Enums.MediaType
    fileKey: string
    fileUrl: string
    mimeType: string
    fileSize: number
    createdById: string
    approvedBy?: string | null
    approvedAt?: Date | string | null
    version?: number | null
    createdAt?: Date | string
    inspectionResponses?: InspectionResponseUncheckedCreateNestedManyWithoutMediaInput
  }

  export type MediaCreateOrConnectWithoutQueryInput = {
    where: MediaWhereUniqueInput
    create: XOR<MediaCreateWithoutQueryInput, MediaUncheckedCreateWithoutQueryInput>
  }

  export type MediaCreateManyQueryInputEnvelope = {
    data: MediaCreateManyQueryInput | MediaCreateManyQueryInput[]
    skipDuplicates?: boolean
  }

  export type QueryResponseCreateWithoutQueryInput = {
    id?: string
    message: string
    createdAt?: Date | string
    author: UserCreateNestedOneWithoutQueryResponsesInput
  }

  export type QueryResponseUncheckedCreateWithoutQueryInput = {
    id?: string
    authorId: string
    message: string
    createdAt?: Date | string
  }

  export type QueryResponseCreateOrConnectWithoutQueryInput = {
    where: QueryResponseWhereUniqueInput
    create: XOR<QueryResponseCreateWithoutQueryInput, QueryResponseUncheckedCreateWithoutQueryInput>
  }

  export type QueryResponseCreateManyQueryInputEnvelope = {
    data: QueryResponseCreateManyQueryInput | QueryResponseCreateManyQueryInput[]
    skipDuplicates?: boolean
  }

  export type ProjectUpsertWithoutQueriesInput = {
    update: XOR<ProjectUpdateWithoutQueriesInput, ProjectUncheckedUpdateWithoutQueriesInput>
    create: XOR<ProjectCreateWithoutQueriesInput, ProjectUncheckedCreateWithoutQueriesInput>
    where?: ProjectWhereInput
  }

  export type ProjectUpdateToOneWithWhereWithoutQueriesInput = {
    where?: ProjectWhereInput
    data: XOR<ProjectUpdateWithoutQueriesInput, ProjectUncheckedUpdateWithoutQueriesInput>
  }

  export type ProjectUpdateWithoutQueriesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumProjectStatusFieldUpdateOperationsInput | $Enums.ProjectStatus
    isArchived?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: UserUpdateOneRequiredWithoutProjectsCreatedNestedInput
    manager?: UserUpdateOneRequiredWithoutManagedProjectsNestedInput
    client?: UserUpdateOneRequiredWithoutClientProjectsNestedInput
    members?: ProjectMemberUpdateManyWithoutProjectNestedInput
    updates?: ProjectUpdateUpdateManyWithoutProjectNestedInput
    media?: MediaUpdateManyWithoutProjectNestedInput
    payments?: PaymentUpdateManyWithoutProjectNestedInput
    milestones?: MilestoneUpdateManyWithoutProjectNestedInput
    inspections?: InspectionUpdateManyWithoutProjectNestedInput
    materials?: MaterialUpdateManyWithoutProjectNestedInput
    auditLogs?: AuditLogUpdateManyWithoutProjectNestedInput
  }

  export type ProjectUncheckedUpdateWithoutQueriesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumProjectStatusFieldUpdateOperationsInput | $Enums.ProjectStatus
    isArchived?: BoolFieldUpdateOperationsInput | boolean
    createdById?: StringFieldUpdateOperationsInput | string
    managerId?: StringFieldUpdateOperationsInput | string
    clientId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    members?: ProjectMemberUncheckedUpdateManyWithoutProjectNestedInput
    updates?: ProjectUpdateUncheckedUpdateManyWithoutProjectNestedInput
    media?: MediaUncheckedUpdateManyWithoutProjectNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutProjectNestedInput
    milestones?: MilestoneUncheckedUpdateManyWithoutProjectNestedInput
    inspections?: InspectionUncheckedUpdateManyWithoutProjectNestedInput
    materials?: MaterialUncheckedUpdateManyWithoutProjectNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutProjectNestedInput
  }

  export type UserUpsertWithoutQueriesInput = {
    update: XOR<UserUpdateWithoutQueriesInput, UserUncheckedUpdateWithoutQueriesInput>
    create: XOR<UserCreateWithoutQueriesInput, UserUncheckedCreateWithoutQueriesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutQueriesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutQueriesInput, UserUncheckedUpdateWithoutQueriesInput>
  }

  export type UserUpdateWithoutQueriesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    designation?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: UserUpdateOneWithoutCreatedUsersNestedInput
    createdUsers?: UserUpdateManyWithoutCreatedByNestedInput
    managedProjects?: ProjectUpdateManyWithoutManagerNestedInput
    clientProjects?: ProjectUpdateManyWithoutClientNestedInput
    projectMembers?: ProjectMemberUpdateManyWithoutUserNestedInput
    projectUpdates?: ProjectUpdateUpdateManyWithoutAuthorNestedInput
    media?: MediaUpdateManyWithoutCreatedByNestedInput
    paymentsCreated?: PaymentUpdateManyWithoutCreatedByNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    projectsCreated?: ProjectUpdateManyWithoutCreatedByNestedInput
    inspections?: InspectionUpdateManyWithoutEngineerNestedInput
    reviewedInspections?: InspectionUpdateManyWithoutReviewedByNestedInput
    queryResponses?: QueryResponseUpdateManyWithoutAuthorNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
    notificationPrefs?: NotificationPreferenceUpdateOneWithoutUserNestedInput
    materialsCreated?: MaterialUpdateManyWithoutCreatedByNestedInput
  }

  export type UserUncheckedUpdateWithoutQueriesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    designation?: NullableStringFieldUpdateOperationsInput | string | null
    createdUsers?: UserUncheckedUpdateManyWithoutCreatedByNestedInput
    managedProjects?: ProjectUncheckedUpdateManyWithoutManagerNestedInput
    clientProjects?: ProjectUncheckedUpdateManyWithoutClientNestedInput
    projectMembers?: ProjectMemberUncheckedUpdateManyWithoutUserNestedInput
    projectUpdates?: ProjectUpdateUncheckedUpdateManyWithoutAuthorNestedInput
    media?: MediaUncheckedUpdateManyWithoutCreatedByNestedInput
    paymentsCreated?: PaymentUncheckedUpdateManyWithoutCreatedByNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    projectsCreated?: ProjectUncheckedUpdateManyWithoutCreatedByNestedInput
    inspections?: InspectionUncheckedUpdateManyWithoutEngineerNestedInput
    reviewedInspections?: InspectionUncheckedUpdateManyWithoutReviewedByNestedInput
    queryResponses?: QueryResponseUncheckedUpdateManyWithoutAuthorNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    notificationPrefs?: NotificationPreferenceUncheckedUpdateOneWithoutUserNestedInput
    materialsCreated?: MaterialUncheckedUpdateManyWithoutCreatedByNestedInput
  }

  export type MediaUpsertWithWhereUniqueWithoutQueryInput = {
    where: MediaWhereUniqueInput
    update: XOR<MediaUpdateWithoutQueryInput, MediaUncheckedUpdateWithoutQueryInput>
    create: XOR<MediaCreateWithoutQueryInput, MediaUncheckedCreateWithoutQueryInput>
  }

  export type MediaUpdateWithWhereUniqueWithoutQueryInput = {
    where: MediaWhereUniqueInput
    data: XOR<MediaUpdateWithoutQueryInput, MediaUncheckedUpdateWithoutQueryInput>
  }

  export type MediaUpdateManyWithWhereWithoutQueryInput = {
    where: MediaScalarWhereInput
    data: XOR<MediaUpdateManyMutationInput, MediaUncheckedUpdateManyWithoutQueryInput>
  }

  export type QueryResponseUpsertWithWhereUniqueWithoutQueryInput = {
    where: QueryResponseWhereUniqueInput
    update: XOR<QueryResponseUpdateWithoutQueryInput, QueryResponseUncheckedUpdateWithoutQueryInput>
    create: XOR<QueryResponseCreateWithoutQueryInput, QueryResponseUncheckedCreateWithoutQueryInput>
  }

  export type QueryResponseUpdateWithWhereUniqueWithoutQueryInput = {
    where: QueryResponseWhereUniqueInput
    data: XOR<QueryResponseUpdateWithoutQueryInput, QueryResponseUncheckedUpdateWithoutQueryInput>
  }

  export type QueryResponseUpdateManyWithWhereWithoutQueryInput = {
    where: QueryResponseScalarWhereInput
    data: XOR<QueryResponseUpdateManyMutationInput, QueryResponseUncheckedUpdateManyWithoutQueryInput>
  }

  export type QueryCreateWithoutResponsesInput = {
    id?: string
    title: string
    description: string
    status?: $Enums.QueryStatus
    priority?: $Enums.QueryPriority
    createdAt?: Date | string
    updatedAt?: Date | string
    project: ProjectCreateNestedOneWithoutQueriesInput
    author: UserCreateNestedOneWithoutQueriesInput
    attachments?: MediaCreateNestedManyWithoutQueryInput
  }

  export type QueryUncheckedCreateWithoutResponsesInput = {
    id?: string
    projectId: string
    authorId: string
    title: string
    description: string
    status?: $Enums.QueryStatus
    priority?: $Enums.QueryPriority
    createdAt?: Date | string
    updatedAt?: Date | string
    attachments?: MediaUncheckedCreateNestedManyWithoutQueryInput
  }

  export type QueryCreateOrConnectWithoutResponsesInput = {
    where: QueryWhereUniqueInput
    create: XOR<QueryCreateWithoutResponsesInput, QueryUncheckedCreateWithoutResponsesInput>
  }

  export type UserCreateWithoutQueryResponsesInput = {
    id?: string
    name: string
    email: string
    passwordHash: string
    role: $Enums.Role
    isActive?: boolean
    createdAt?: Date | string
    phone?: string | null
    designation?: string | null
    createdBy?: UserCreateNestedOneWithoutCreatedUsersInput
    createdUsers?: UserCreateNestedManyWithoutCreatedByInput
    managedProjects?: ProjectCreateNestedManyWithoutManagerInput
    clientProjects?: ProjectCreateNestedManyWithoutClientInput
    projectMembers?: ProjectMemberCreateNestedManyWithoutUserInput
    projectUpdates?: ProjectUpdateCreateNestedManyWithoutAuthorInput
    media?: MediaCreateNestedManyWithoutCreatedByInput
    paymentsCreated?: PaymentCreateNestedManyWithoutCreatedByInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    projectsCreated?: ProjectCreateNestedManyWithoutCreatedByInput
    inspections?: InspectionCreateNestedManyWithoutEngineerInput
    reviewedInspections?: InspectionCreateNestedManyWithoutReviewedByInput
    queries?: QueryCreateNestedManyWithoutAuthorInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
    notificationPrefs?: NotificationPreferenceCreateNestedOneWithoutUserInput
    materialsCreated?: MaterialCreateNestedManyWithoutCreatedByInput
  }

  export type UserUncheckedCreateWithoutQueryResponsesInput = {
    id?: string
    name: string
    email: string
    passwordHash: string
    role: $Enums.Role
    isActive?: boolean
    createdById?: string | null
    createdAt?: Date | string
    phone?: string | null
    designation?: string | null
    createdUsers?: UserUncheckedCreateNestedManyWithoutCreatedByInput
    managedProjects?: ProjectUncheckedCreateNestedManyWithoutManagerInput
    clientProjects?: ProjectUncheckedCreateNestedManyWithoutClientInput
    projectMembers?: ProjectMemberUncheckedCreateNestedManyWithoutUserInput
    projectUpdates?: ProjectUpdateUncheckedCreateNestedManyWithoutAuthorInput
    media?: MediaUncheckedCreateNestedManyWithoutCreatedByInput
    paymentsCreated?: PaymentUncheckedCreateNestedManyWithoutCreatedByInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    projectsCreated?: ProjectUncheckedCreateNestedManyWithoutCreatedByInput
    inspections?: InspectionUncheckedCreateNestedManyWithoutEngineerInput
    reviewedInspections?: InspectionUncheckedCreateNestedManyWithoutReviewedByInput
    queries?: QueryUncheckedCreateNestedManyWithoutAuthorInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    notificationPrefs?: NotificationPreferenceUncheckedCreateNestedOneWithoutUserInput
    materialsCreated?: MaterialUncheckedCreateNestedManyWithoutCreatedByInput
  }

  export type UserCreateOrConnectWithoutQueryResponsesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutQueryResponsesInput, UserUncheckedCreateWithoutQueryResponsesInput>
  }

  export type QueryUpsertWithoutResponsesInput = {
    update: XOR<QueryUpdateWithoutResponsesInput, QueryUncheckedUpdateWithoutResponsesInput>
    create: XOR<QueryCreateWithoutResponsesInput, QueryUncheckedCreateWithoutResponsesInput>
    where?: QueryWhereInput
  }

  export type QueryUpdateToOneWithWhereWithoutResponsesInput = {
    where?: QueryWhereInput
    data: XOR<QueryUpdateWithoutResponsesInput, QueryUncheckedUpdateWithoutResponsesInput>
  }

  export type QueryUpdateWithoutResponsesInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    status?: EnumQueryStatusFieldUpdateOperationsInput | $Enums.QueryStatus
    priority?: EnumQueryPriorityFieldUpdateOperationsInput | $Enums.QueryPriority
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    project?: ProjectUpdateOneRequiredWithoutQueriesNestedInput
    author?: UserUpdateOneRequiredWithoutQueriesNestedInput
    attachments?: MediaUpdateManyWithoutQueryNestedInput
  }

  export type QueryUncheckedUpdateWithoutResponsesInput = {
    id?: StringFieldUpdateOperationsInput | string
    projectId?: StringFieldUpdateOperationsInput | string
    authorId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    status?: EnumQueryStatusFieldUpdateOperationsInput | $Enums.QueryStatus
    priority?: EnumQueryPriorityFieldUpdateOperationsInput | $Enums.QueryPriority
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    attachments?: MediaUncheckedUpdateManyWithoutQueryNestedInput
  }

  export type UserUpsertWithoutQueryResponsesInput = {
    update: XOR<UserUpdateWithoutQueryResponsesInput, UserUncheckedUpdateWithoutQueryResponsesInput>
    create: XOR<UserCreateWithoutQueryResponsesInput, UserUncheckedCreateWithoutQueryResponsesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutQueryResponsesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutQueryResponsesInput, UserUncheckedUpdateWithoutQueryResponsesInput>
  }

  export type UserUpdateWithoutQueryResponsesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    designation?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: UserUpdateOneWithoutCreatedUsersNestedInput
    createdUsers?: UserUpdateManyWithoutCreatedByNestedInput
    managedProjects?: ProjectUpdateManyWithoutManagerNestedInput
    clientProjects?: ProjectUpdateManyWithoutClientNestedInput
    projectMembers?: ProjectMemberUpdateManyWithoutUserNestedInput
    projectUpdates?: ProjectUpdateUpdateManyWithoutAuthorNestedInput
    media?: MediaUpdateManyWithoutCreatedByNestedInput
    paymentsCreated?: PaymentUpdateManyWithoutCreatedByNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    projectsCreated?: ProjectUpdateManyWithoutCreatedByNestedInput
    inspections?: InspectionUpdateManyWithoutEngineerNestedInput
    reviewedInspections?: InspectionUpdateManyWithoutReviewedByNestedInput
    queries?: QueryUpdateManyWithoutAuthorNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
    notificationPrefs?: NotificationPreferenceUpdateOneWithoutUserNestedInput
    materialsCreated?: MaterialUpdateManyWithoutCreatedByNestedInput
  }

  export type UserUncheckedUpdateWithoutQueryResponsesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    designation?: NullableStringFieldUpdateOperationsInput | string | null
    createdUsers?: UserUncheckedUpdateManyWithoutCreatedByNestedInput
    managedProjects?: ProjectUncheckedUpdateManyWithoutManagerNestedInput
    clientProjects?: ProjectUncheckedUpdateManyWithoutClientNestedInput
    projectMembers?: ProjectMemberUncheckedUpdateManyWithoutUserNestedInput
    projectUpdates?: ProjectUpdateUncheckedUpdateManyWithoutAuthorNestedInput
    media?: MediaUncheckedUpdateManyWithoutCreatedByNestedInput
    paymentsCreated?: PaymentUncheckedUpdateManyWithoutCreatedByNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    projectsCreated?: ProjectUncheckedUpdateManyWithoutCreatedByNestedInput
    inspections?: InspectionUncheckedUpdateManyWithoutEngineerNestedInput
    reviewedInspections?: InspectionUncheckedUpdateManyWithoutReviewedByNestedInput
    queries?: QueryUncheckedUpdateManyWithoutAuthorNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    notificationPrefs?: NotificationPreferenceUncheckedUpdateOneWithoutUserNestedInput
    materialsCreated?: MaterialUncheckedUpdateManyWithoutCreatedByNestedInput
  }

  export type UserCreateWithoutAuditLogsInput = {
    id?: string
    name: string
    email: string
    passwordHash: string
    role: $Enums.Role
    isActive?: boolean
    createdAt?: Date | string
    phone?: string | null
    designation?: string | null
    createdBy?: UserCreateNestedOneWithoutCreatedUsersInput
    createdUsers?: UserCreateNestedManyWithoutCreatedByInput
    managedProjects?: ProjectCreateNestedManyWithoutManagerInput
    clientProjects?: ProjectCreateNestedManyWithoutClientInput
    projectMembers?: ProjectMemberCreateNestedManyWithoutUserInput
    projectUpdates?: ProjectUpdateCreateNestedManyWithoutAuthorInput
    media?: MediaCreateNestedManyWithoutCreatedByInput
    paymentsCreated?: PaymentCreateNestedManyWithoutCreatedByInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    projectsCreated?: ProjectCreateNestedManyWithoutCreatedByInput
    inspections?: InspectionCreateNestedManyWithoutEngineerInput
    reviewedInspections?: InspectionCreateNestedManyWithoutReviewedByInput
    queries?: QueryCreateNestedManyWithoutAuthorInput
    queryResponses?: QueryResponseCreateNestedManyWithoutAuthorInput
    notificationPrefs?: NotificationPreferenceCreateNestedOneWithoutUserInput
    materialsCreated?: MaterialCreateNestedManyWithoutCreatedByInput
  }

  export type UserUncheckedCreateWithoutAuditLogsInput = {
    id?: string
    name: string
    email: string
    passwordHash: string
    role: $Enums.Role
    isActive?: boolean
    createdById?: string | null
    createdAt?: Date | string
    phone?: string | null
    designation?: string | null
    createdUsers?: UserUncheckedCreateNestedManyWithoutCreatedByInput
    managedProjects?: ProjectUncheckedCreateNestedManyWithoutManagerInput
    clientProjects?: ProjectUncheckedCreateNestedManyWithoutClientInput
    projectMembers?: ProjectMemberUncheckedCreateNestedManyWithoutUserInput
    projectUpdates?: ProjectUpdateUncheckedCreateNestedManyWithoutAuthorInput
    media?: MediaUncheckedCreateNestedManyWithoutCreatedByInput
    paymentsCreated?: PaymentUncheckedCreateNestedManyWithoutCreatedByInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    projectsCreated?: ProjectUncheckedCreateNestedManyWithoutCreatedByInput
    inspections?: InspectionUncheckedCreateNestedManyWithoutEngineerInput
    reviewedInspections?: InspectionUncheckedCreateNestedManyWithoutReviewedByInput
    queries?: QueryUncheckedCreateNestedManyWithoutAuthorInput
    queryResponses?: QueryResponseUncheckedCreateNestedManyWithoutAuthorInput
    notificationPrefs?: NotificationPreferenceUncheckedCreateNestedOneWithoutUserInput
    materialsCreated?: MaterialUncheckedCreateNestedManyWithoutCreatedByInput
  }

  export type UserCreateOrConnectWithoutAuditLogsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutAuditLogsInput, UserUncheckedCreateWithoutAuditLogsInput>
  }

  export type ProjectCreateWithoutAuditLogsInput = {
    id?: string
    name: string
    description?: string | null
    status?: $Enums.ProjectStatus
    isArchived?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy: UserCreateNestedOneWithoutProjectsCreatedInput
    manager: UserCreateNestedOneWithoutManagedProjectsInput
    client: UserCreateNestedOneWithoutClientProjectsInput
    members?: ProjectMemberCreateNestedManyWithoutProjectInput
    updates?: ProjectUpdateCreateNestedManyWithoutProjectInput
    media?: MediaCreateNestedManyWithoutProjectInput
    payments?: PaymentCreateNestedManyWithoutProjectInput
    milestones?: MilestoneCreateNestedManyWithoutProjectInput
    inspections?: InspectionCreateNestedManyWithoutProjectInput
    queries?: QueryCreateNestedManyWithoutProjectInput
    materials?: MaterialCreateNestedManyWithoutProjectInput
  }

  export type ProjectUncheckedCreateWithoutAuditLogsInput = {
    id?: string
    name: string
    description?: string | null
    status?: $Enums.ProjectStatus
    isArchived?: boolean
    createdById: string
    managerId: string
    clientId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    members?: ProjectMemberUncheckedCreateNestedManyWithoutProjectInput
    updates?: ProjectUpdateUncheckedCreateNestedManyWithoutProjectInput
    media?: MediaUncheckedCreateNestedManyWithoutProjectInput
    payments?: PaymentUncheckedCreateNestedManyWithoutProjectInput
    milestones?: MilestoneUncheckedCreateNestedManyWithoutProjectInput
    inspections?: InspectionUncheckedCreateNestedManyWithoutProjectInput
    queries?: QueryUncheckedCreateNestedManyWithoutProjectInput
    materials?: MaterialUncheckedCreateNestedManyWithoutProjectInput
  }

  export type ProjectCreateOrConnectWithoutAuditLogsInput = {
    where: ProjectWhereUniqueInput
    create: XOR<ProjectCreateWithoutAuditLogsInput, ProjectUncheckedCreateWithoutAuditLogsInput>
  }

  export type UserUpsertWithoutAuditLogsInput = {
    update: XOR<UserUpdateWithoutAuditLogsInput, UserUncheckedUpdateWithoutAuditLogsInput>
    create: XOR<UserCreateWithoutAuditLogsInput, UserUncheckedCreateWithoutAuditLogsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutAuditLogsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutAuditLogsInput, UserUncheckedUpdateWithoutAuditLogsInput>
  }

  export type UserUpdateWithoutAuditLogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    designation?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: UserUpdateOneWithoutCreatedUsersNestedInput
    createdUsers?: UserUpdateManyWithoutCreatedByNestedInput
    managedProjects?: ProjectUpdateManyWithoutManagerNestedInput
    clientProjects?: ProjectUpdateManyWithoutClientNestedInput
    projectMembers?: ProjectMemberUpdateManyWithoutUserNestedInput
    projectUpdates?: ProjectUpdateUpdateManyWithoutAuthorNestedInput
    media?: MediaUpdateManyWithoutCreatedByNestedInput
    paymentsCreated?: PaymentUpdateManyWithoutCreatedByNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    projectsCreated?: ProjectUpdateManyWithoutCreatedByNestedInput
    inspections?: InspectionUpdateManyWithoutEngineerNestedInput
    reviewedInspections?: InspectionUpdateManyWithoutReviewedByNestedInput
    queries?: QueryUpdateManyWithoutAuthorNestedInput
    queryResponses?: QueryResponseUpdateManyWithoutAuthorNestedInput
    notificationPrefs?: NotificationPreferenceUpdateOneWithoutUserNestedInput
    materialsCreated?: MaterialUpdateManyWithoutCreatedByNestedInput
  }

  export type UserUncheckedUpdateWithoutAuditLogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    designation?: NullableStringFieldUpdateOperationsInput | string | null
    createdUsers?: UserUncheckedUpdateManyWithoutCreatedByNestedInput
    managedProjects?: ProjectUncheckedUpdateManyWithoutManagerNestedInput
    clientProjects?: ProjectUncheckedUpdateManyWithoutClientNestedInput
    projectMembers?: ProjectMemberUncheckedUpdateManyWithoutUserNestedInput
    projectUpdates?: ProjectUpdateUncheckedUpdateManyWithoutAuthorNestedInput
    media?: MediaUncheckedUpdateManyWithoutCreatedByNestedInput
    paymentsCreated?: PaymentUncheckedUpdateManyWithoutCreatedByNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    projectsCreated?: ProjectUncheckedUpdateManyWithoutCreatedByNestedInput
    inspections?: InspectionUncheckedUpdateManyWithoutEngineerNestedInput
    reviewedInspections?: InspectionUncheckedUpdateManyWithoutReviewedByNestedInput
    queries?: QueryUncheckedUpdateManyWithoutAuthorNestedInput
    queryResponses?: QueryResponseUncheckedUpdateManyWithoutAuthorNestedInput
    notificationPrefs?: NotificationPreferenceUncheckedUpdateOneWithoutUserNestedInput
    materialsCreated?: MaterialUncheckedUpdateManyWithoutCreatedByNestedInput
  }

  export type ProjectUpsertWithoutAuditLogsInput = {
    update: XOR<ProjectUpdateWithoutAuditLogsInput, ProjectUncheckedUpdateWithoutAuditLogsInput>
    create: XOR<ProjectCreateWithoutAuditLogsInput, ProjectUncheckedCreateWithoutAuditLogsInput>
    where?: ProjectWhereInput
  }

  export type ProjectUpdateToOneWithWhereWithoutAuditLogsInput = {
    where?: ProjectWhereInput
    data: XOR<ProjectUpdateWithoutAuditLogsInput, ProjectUncheckedUpdateWithoutAuditLogsInput>
  }

  export type ProjectUpdateWithoutAuditLogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumProjectStatusFieldUpdateOperationsInput | $Enums.ProjectStatus
    isArchived?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: UserUpdateOneRequiredWithoutProjectsCreatedNestedInput
    manager?: UserUpdateOneRequiredWithoutManagedProjectsNestedInput
    client?: UserUpdateOneRequiredWithoutClientProjectsNestedInput
    members?: ProjectMemberUpdateManyWithoutProjectNestedInput
    updates?: ProjectUpdateUpdateManyWithoutProjectNestedInput
    media?: MediaUpdateManyWithoutProjectNestedInput
    payments?: PaymentUpdateManyWithoutProjectNestedInput
    milestones?: MilestoneUpdateManyWithoutProjectNestedInput
    inspections?: InspectionUpdateManyWithoutProjectNestedInput
    queries?: QueryUpdateManyWithoutProjectNestedInput
    materials?: MaterialUpdateManyWithoutProjectNestedInput
  }

  export type ProjectUncheckedUpdateWithoutAuditLogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumProjectStatusFieldUpdateOperationsInput | $Enums.ProjectStatus
    isArchived?: BoolFieldUpdateOperationsInput | boolean
    createdById?: StringFieldUpdateOperationsInput | string
    managerId?: StringFieldUpdateOperationsInput | string
    clientId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    members?: ProjectMemberUncheckedUpdateManyWithoutProjectNestedInput
    updates?: ProjectUpdateUncheckedUpdateManyWithoutProjectNestedInput
    media?: MediaUncheckedUpdateManyWithoutProjectNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutProjectNestedInput
    milestones?: MilestoneUncheckedUpdateManyWithoutProjectNestedInput
    inspections?: InspectionUncheckedUpdateManyWithoutProjectNestedInput
    queries?: QueryUncheckedUpdateManyWithoutProjectNestedInput
    materials?: MaterialUncheckedUpdateManyWithoutProjectNestedInput
  }

  export type ProjectCreateWithoutMaterialsInput = {
    id?: string
    name: string
    description?: string | null
    status?: $Enums.ProjectStatus
    isArchived?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy: UserCreateNestedOneWithoutProjectsCreatedInput
    manager: UserCreateNestedOneWithoutManagedProjectsInput
    client: UserCreateNestedOneWithoutClientProjectsInput
    members?: ProjectMemberCreateNestedManyWithoutProjectInput
    updates?: ProjectUpdateCreateNestedManyWithoutProjectInput
    media?: MediaCreateNestedManyWithoutProjectInput
    payments?: PaymentCreateNestedManyWithoutProjectInput
    milestones?: MilestoneCreateNestedManyWithoutProjectInput
    inspections?: InspectionCreateNestedManyWithoutProjectInput
    queries?: QueryCreateNestedManyWithoutProjectInput
    auditLogs?: AuditLogCreateNestedManyWithoutProjectInput
  }

  export type ProjectUncheckedCreateWithoutMaterialsInput = {
    id?: string
    name: string
    description?: string | null
    status?: $Enums.ProjectStatus
    isArchived?: boolean
    createdById: string
    managerId: string
    clientId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    members?: ProjectMemberUncheckedCreateNestedManyWithoutProjectInput
    updates?: ProjectUpdateUncheckedCreateNestedManyWithoutProjectInput
    media?: MediaUncheckedCreateNestedManyWithoutProjectInput
    payments?: PaymentUncheckedCreateNestedManyWithoutProjectInput
    milestones?: MilestoneUncheckedCreateNestedManyWithoutProjectInput
    inspections?: InspectionUncheckedCreateNestedManyWithoutProjectInput
    queries?: QueryUncheckedCreateNestedManyWithoutProjectInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutProjectInput
  }

  export type ProjectCreateOrConnectWithoutMaterialsInput = {
    where: ProjectWhereUniqueInput
    create: XOR<ProjectCreateWithoutMaterialsInput, ProjectUncheckedCreateWithoutMaterialsInput>
  }

  export type UserCreateWithoutMaterialsCreatedInput = {
    id?: string
    name: string
    email: string
    passwordHash: string
    role: $Enums.Role
    isActive?: boolean
    createdAt?: Date | string
    phone?: string | null
    designation?: string | null
    createdBy?: UserCreateNestedOneWithoutCreatedUsersInput
    createdUsers?: UserCreateNestedManyWithoutCreatedByInput
    managedProjects?: ProjectCreateNestedManyWithoutManagerInput
    clientProjects?: ProjectCreateNestedManyWithoutClientInput
    projectMembers?: ProjectMemberCreateNestedManyWithoutUserInput
    projectUpdates?: ProjectUpdateCreateNestedManyWithoutAuthorInput
    media?: MediaCreateNestedManyWithoutCreatedByInput
    paymentsCreated?: PaymentCreateNestedManyWithoutCreatedByInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    projectsCreated?: ProjectCreateNestedManyWithoutCreatedByInput
    inspections?: InspectionCreateNestedManyWithoutEngineerInput
    reviewedInspections?: InspectionCreateNestedManyWithoutReviewedByInput
    queries?: QueryCreateNestedManyWithoutAuthorInput
    queryResponses?: QueryResponseCreateNestedManyWithoutAuthorInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
    notificationPrefs?: NotificationPreferenceCreateNestedOneWithoutUserInput
  }

  export type UserUncheckedCreateWithoutMaterialsCreatedInput = {
    id?: string
    name: string
    email: string
    passwordHash: string
    role: $Enums.Role
    isActive?: boolean
    createdById?: string | null
    createdAt?: Date | string
    phone?: string | null
    designation?: string | null
    createdUsers?: UserUncheckedCreateNestedManyWithoutCreatedByInput
    managedProjects?: ProjectUncheckedCreateNestedManyWithoutManagerInput
    clientProjects?: ProjectUncheckedCreateNestedManyWithoutClientInput
    projectMembers?: ProjectMemberUncheckedCreateNestedManyWithoutUserInput
    projectUpdates?: ProjectUpdateUncheckedCreateNestedManyWithoutAuthorInput
    media?: MediaUncheckedCreateNestedManyWithoutCreatedByInput
    paymentsCreated?: PaymentUncheckedCreateNestedManyWithoutCreatedByInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    projectsCreated?: ProjectUncheckedCreateNestedManyWithoutCreatedByInput
    inspections?: InspectionUncheckedCreateNestedManyWithoutEngineerInput
    reviewedInspections?: InspectionUncheckedCreateNestedManyWithoutReviewedByInput
    queries?: QueryUncheckedCreateNestedManyWithoutAuthorInput
    queryResponses?: QueryResponseUncheckedCreateNestedManyWithoutAuthorInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    notificationPrefs?: NotificationPreferenceUncheckedCreateNestedOneWithoutUserInput
  }

  export type UserCreateOrConnectWithoutMaterialsCreatedInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutMaterialsCreatedInput, UserUncheckedCreateWithoutMaterialsCreatedInput>
  }

  export type ProjectUpsertWithoutMaterialsInput = {
    update: XOR<ProjectUpdateWithoutMaterialsInput, ProjectUncheckedUpdateWithoutMaterialsInput>
    create: XOR<ProjectCreateWithoutMaterialsInput, ProjectUncheckedCreateWithoutMaterialsInput>
    where?: ProjectWhereInput
  }

  export type ProjectUpdateToOneWithWhereWithoutMaterialsInput = {
    where?: ProjectWhereInput
    data: XOR<ProjectUpdateWithoutMaterialsInput, ProjectUncheckedUpdateWithoutMaterialsInput>
  }

  export type ProjectUpdateWithoutMaterialsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumProjectStatusFieldUpdateOperationsInput | $Enums.ProjectStatus
    isArchived?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: UserUpdateOneRequiredWithoutProjectsCreatedNestedInput
    manager?: UserUpdateOneRequiredWithoutManagedProjectsNestedInput
    client?: UserUpdateOneRequiredWithoutClientProjectsNestedInput
    members?: ProjectMemberUpdateManyWithoutProjectNestedInput
    updates?: ProjectUpdateUpdateManyWithoutProjectNestedInput
    media?: MediaUpdateManyWithoutProjectNestedInput
    payments?: PaymentUpdateManyWithoutProjectNestedInput
    milestones?: MilestoneUpdateManyWithoutProjectNestedInput
    inspections?: InspectionUpdateManyWithoutProjectNestedInput
    queries?: QueryUpdateManyWithoutProjectNestedInput
    auditLogs?: AuditLogUpdateManyWithoutProjectNestedInput
  }

  export type ProjectUncheckedUpdateWithoutMaterialsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumProjectStatusFieldUpdateOperationsInput | $Enums.ProjectStatus
    isArchived?: BoolFieldUpdateOperationsInput | boolean
    createdById?: StringFieldUpdateOperationsInput | string
    managerId?: StringFieldUpdateOperationsInput | string
    clientId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    members?: ProjectMemberUncheckedUpdateManyWithoutProjectNestedInput
    updates?: ProjectUpdateUncheckedUpdateManyWithoutProjectNestedInput
    media?: MediaUncheckedUpdateManyWithoutProjectNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutProjectNestedInput
    milestones?: MilestoneUncheckedUpdateManyWithoutProjectNestedInput
    inspections?: InspectionUncheckedUpdateManyWithoutProjectNestedInput
    queries?: QueryUncheckedUpdateManyWithoutProjectNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutProjectNestedInput
  }

  export type UserUpsertWithoutMaterialsCreatedInput = {
    update: XOR<UserUpdateWithoutMaterialsCreatedInput, UserUncheckedUpdateWithoutMaterialsCreatedInput>
    create: XOR<UserCreateWithoutMaterialsCreatedInput, UserUncheckedCreateWithoutMaterialsCreatedInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutMaterialsCreatedInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutMaterialsCreatedInput, UserUncheckedUpdateWithoutMaterialsCreatedInput>
  }

  export type UserUpdateWithoutMaterialsCreatedInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    designation?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: UserUpdateOneWithoutCreatedUsersNestedInput
    createdUsers?: UserUpdateManyWithoutCreatedByNestedInput
    managedProjects?: ProjectUpdateManyWithoutManagerNestedInput
    clientProjects?: ProjectUpdateManyWithoutClientNestedInput
    projectMembers?: ProjectMemberUpdateManyWithoutUserNestedInput
    projectUpdates?: ProjectUpdateUpdateManyWithoutAuthorNestedInput
    media?: MediaUpdateManyWithoutCreatedByNestedInput
    paymentsCreated?: PaymentUpdateManyWithoutCreatedByNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    projectsCreated?: ProjectUpdateManyWithoutCreatedByNestedInput
    inspections?: InspectionUpdateManyWithoutEngineerNestedInput
    reviewedInspections?: InspectionUpdateManyWithoutReviewedByNestedInput
    queries?: QueryUpdateManyWithoutAuthorNestedInput
    queryResponses?: QueryResponseUpdateManyWithoutAuthorNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
    notificationPrefs?: NotificationPreferenceUpdateOneWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutMaterialsCreatedInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    designation?: NullableStringFieldUpdateOperationsInput | string | null
    createdUsers?: UserUncheckedUpdateManyWithoutCreatedByNestedInput
    managedProjects?: ProjectUncheckedUpdateManyWithoutManagerNestedInput
    clientProjects?: ProjectUncheckedUpdateManyWithoutClientNestedInput
    projectMembers?: ProjectMemberUncheckedUpdateManyWithoutUserNestedInput
    projectUpdates?: ProjectUpdateUncheckedUpdateManyWithoutAuthorNestedInput
    media?: MediaUncheckedUpdateManyWithoutCreatedByNestedInput
    paymentsCreated?: PaymentUncheckedUpdateManyWithoutCreatedByNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    projectsCreated?: ProjectUncheckedUpdateManyWithoutCreatedByNestedInput
    inspections?: InspectionUncheckedUpdateManyWithoutEngineerNestedInput
    reviewedInspections?: InspectionUncheckedUpdateManyWithoutReviewedByNestedInput
    queries?: QueryUncheckedUpdateManyWithoutAuthorNestedInput
    queryResponses?: QueryResponseUncheckedUpdateManyWithoutAuthorNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    notificationPrefs?: NotificationPreferenceUncheckedUpdateOneWithoutUserNestedInput
  }

  export type UserCreateManyCreatedByInput = {
    id?: string
    name: string
    email: string
    passwordHash: string
    role: $Enums.Role
    isActive?: boolean
    createdAt?: Date | string
    phone?: string | null
    designation?: string | null
  }

  export type ProjectCreateManyManagerInput = {
    id?: string
    name: string
    description?: string | null
    status?: $Enums.ProjectStatus
    isArchived?: boolean
    createdById: string
    clientId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProjectCreateManyClientInput = {
    id?: string
    name: string
    description?: string | null
    status?: $Enums.ProjectStatus
    isArchived?: boolean
    createdById: string
    managerId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProjectMemberCreateManyUserInput = {
    id?: string
    projectId: string
    role: $Enums.ProjectMemberRole
    createdAt?: Date | string
  }

  export type ProjectUpdateCreateManyAuthorInput = {
    id?: string
    projectId: string
    notes: string
    statusSnapshot?: string | null
    createdAt?: Date | string
  }

  export type MediaCreateManyCreatedByInput = {
    id?: string
    projectId: string
    projectUpdateId?: string | null
    paymentId?: string | null
    type: $Enums.MediaType
    fileKey: string
    fileUrl: string
    mimeType: string
    fileSize: number
    approvedBy?: string | null
    approvedAt?: Date | string | null
    version?: number | null
    createdAt?: Date | string
    queryId?: string | null
  }

  export type PaymentCreateManyCreatedByInput = {
    id?: string
    projectId: string
    amount: Decimal | DecimalJsLike | number | string
    currency?: string
    status?: $Enums.PaymentStatus
    category?: $Enums.PaymentCategory | null
    invoiceNumber?: string | null
    paidAt?: Date | string | null
    dueDate?: Date | string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type NotificationCreateManyUserInput = {
    id?: string
    title: string
    message: string
    type: string
    priority?: $Enums.NotificationPriority
    actionUrl?: string | null
    isRead?: boolean
    createdAt?: Date | string
  }

  export type ProjectCreateManyCreatedByInput = {
    id?: string
    name: string
    description?: string | null
    status?: $Enums.ProjectStatus
    isArchived?: boolean
    managerId: string
    clientId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type InspectionCreateManyEngineerInput = {
    id?: string
    status?: $Enums.InspectionStatus
    projectId: string
    milestoneId: string
    reviewedById?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type InspectionCreateManyReviewedByInput = {
    id?: string
    status?: $Enums.InspectionStatus
    projectId: string
    milestoneId: string
    engineerId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type QueryCreateManyAuthorInput = {
    id?: string
    projectId: string
    title: string
    description: string
    status?: $Enums.QueryStatus
    priority?: $Enums.QueryPriority
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type QueryResponseCreateManyAuthorInput = {
    id?: string
    queryId: string
    message: string
    createdAt?: Date | string
  }

  export type AuditLogCreateManyUserInput = {
    id?: string
    action: string
    entity: string
    entityId: string
    projectId?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type MaterialCreateManyCreatedByInput = {
    id?: string
    projectId: string
    name: string
    quantity: number
    unit: string
    unitCost: number
    totalCost: number
    supplier?: string | null
    status?: $Enums.MaterialStatus
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserUpdateWithoutCreatedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    designation?: NullableStringFieldUpdateOperationsInput | string | null
    createdUsers?: UserUpdateManyWithoutCreatedByNestedInput
    managedProjects?: ProjectUpdateManyWithoutManagerNestedInput
    clientProjects?: ProjectUpdateManyWithoutClientNestedInput
    projectMembers?: ProjectMemberUpdateManyWithoutUserNestedInput
    projectUpdates?: ProjectUpdateUpdateManyWithoutAuthorNestedInput
    media?: MediaUpdateManyWithoutCreatedByNestedInput
    paymentsCreated?: PaymentUpdateManyWithoutCreatedByNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    projectsCreated?: ProjectUpdateManyWithoutCreatedByNestedInput
    inspections?: InspectionUpdateManyWithoutEngineerNestedInput
    reviewedInspections?: InspectionUpdateManyWithoutReviewedByNestedInput
    queries?: QueryUpdateManyWithoutAuthorNestedInput
    queryResponses?: QueryResponseUpdateManyWithoutAuthorNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
    notificationPrefs?: NotificationPreferenceUpdateOneWithoutUserNestedInput
    materialsCreated?: MaterialUpdateManyWithoutCreatedByNestedInput
  }

  export type UserUncheckedUpdateWithoutCreatedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    designation?: NullableStringFieldUpdateOperationsInput | string | null
    createdUsers?: UserUncheckedUpdateManyWithoutCreatedByNestedInput
    managedProjects?: ProjectUncheckedUpdateManyWithoutManagerNestedInput
    clientProjects?: ProjectUncheckedUpdateManyWithoutClientNestedInput
    projectMembers?: ProjectMemberUncheckedUpdateManyWithoutUserNestedInput
    projectUpdates?: ProjectUpdateUncheckedUpdateManyWithoutAuthorNestedInput
    media?: MediaUncheckedUpdateManyWithoutCreatedByNestedInput
    paymentsCreated?: PaymentUncheckedUpdateManyWithoutCreatedByNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    projectsCreated?: ProjectUncheckedUpdateManyWithoutCreatedByNestedInput
    inspections?: InspectionUncheckedUpdateManyWithoutEngineerNestedInput
    reviewedInspections?: InspectionUncheckedUpdateManyWithoutReviewedByNestedInput
    queries?: QueryUncheckedUpdateManyWithoutAuthorNestedInput
    queryResponses?: QueryResponseUncheckedUpdateManyWithoutAuthorNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    notificationPrefs?: NotificationPreferenceUncheckedUpdateOneWithoutUserNestedInput
    materialsCreated?: MaterialUncheckedUpdateManyWithoutCreatedByNestedInput
  }

  export type UserUncheckedUpdateManyWithoutCreatedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    designation?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ProjectUpdateWithoutManagerInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumProjectStatusFieldUpdateOperationsInput | $Enums.ProjectStatus
    isArchived?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: UserUpdateOneRequiredWithoutProjectsCreatedNestedInput
    client?: UserUpdateOneRequiredWithoutClientProjectsNestedInput
    members?: ProjectMemberUpdateManyWithoutProjectNestedInput
    updates?: ProjectUpdateUpdateManyWithoutProjectNestedInput
    media?: MediaUpdateManyWithoutProjectNestedInput
    payments?: PaymentUpdateManyWithoutProjectNestedInput
    milestones?: MilestoneUpdateManyWithoutProjectNestedInput
    inspections?: InspectionUpdateManyWithoutProjectNestedInput
    queries?: QueryUpdateManyWithoutProjectNestedInput
    materials?: MaterialUpdateManyWithoutProjectNestedInput
    auditLogs?: AuditLogUpdateManyWithoutProjectNestedInput
  }

  export type ProjectUncheckedUpdateWithoutManagerInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumProjectStatusFieldUpdateOperationsInput | $Enums.ProjectStatus
    isArchived?: BoolFieldUpdateOperationsInput | boolean
    createdById?: StringFieldUpdateOperationsInput | string
    clientId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    members?: ProjectMemberUncheckedUpdateManyWithoutProjectNestedInput
    updates?: ProjectUpdateUncheckedUpdateManyWithoutProjectNestedInput
    media?: MediaUncheckedUpdateManyWithoutProjectNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutProjectNestedInput
    milestones?: MilestoneUncheckedUpdateManyWithoutProjectNestedInput
    inspections?: InspectionUncheckedUpdateManyWithoutProjectNestedInput
    queries?: QueryUncheckedUpdateManyWithoutProjectNestedInput
    materials?: MaterialUncheckedUpdateManyWithoutProjectNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutProjectNestedInput
  }

  export type ProjectUncheckedUpdateManyWithoutManagerInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumProjectStatusFieldUpdateOperationsInput | $Enums.ProjectStatus
    isArchived?: BoolFieldUpdateOperationsInput | boolean
    createdById?: StringFieldUpdateOperationsInput | string
    clientId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProjectUpdateWithoutClientInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumProjectStatusFieldUpdateOperationsInput | $Enums.ProjectStatus
    isArchived?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: UserUpdateOneRequiredWithoutProjectsCreatedNestedInput
    manager?: UserUpdateOneRequiredWithoutManagedProjectsNestedInput
    members?: ProjectMemberUpdateManyWithoutProjectNestedInput
    updates?: ProjectUpdateUpdateManyWithoutProjectNestedInput
    media?: MediaUpdateManyWithoutProjectNestedInput
    payments?: PaymentUpdateManyWithoutProjectNestedInput
    milestones?: MilestoneUpdateManyWithoutProjectNestedInput
    inspections?: InspectionUpdateManyWithoutProjectNestedInput
    queries?: QueryUpdateManyWithoutProjectNestedInput
    materials?: MaterialUpdateManyWithoutProjectNestedInput
    auditLogs?: AuditLogUpdateManyWithoutProjectNestedInput
  }

  export type ProjectUncheckedUpdateWithoutClientInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumProjectStatusFieldUpdateOperationsInput | $Enums.ProjectStatus
    isArchived?: BoolFieldUpdateOperationsInput | boolean
    createdById?: StringFieldUpdateOperationsInput | string
    managerId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    members?: ProjectMemberUncheckedUpdateManyWithoutProjectNestedInput
    updates?: ProjectUpdateUncheckedUpdateManyWithoutProjectNestedInput
    media?: MediaUncheckedUpdateManyWithoutProjectNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutProjectNestedInput
    milestones?: MilestoneUncheckedUpdateManyWithoutProjectNestedInput
    inspections?: InspectionUncheckedUpdateManyWithoutProjectNestedInput
    queries?: QueryUncheckedUpdateManyWithoutProjectNestedInput
    materials?: MaterialUncheckedUpdateManyWithoutProjectNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutProjectNestedInput
  }

  export type ProjectUncheckedUpdateManyWithoutClientInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumProjectStatusFieldUpdateOperationsInput | $Enums.ProjectStatus
    isArchived?: BoolFieldUpdateOperationsInput | boolean
    createdById?: StringFieldUpdateOperationsInput | string
    managerId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProjectMemberUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: EnumProjectMemberRoleFieldUpdateOperationsInput | $Enums.ProjectMemberRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    project?: ProjectUpdateOneRequiredWithoutMembersNestedInput
  }

  export type ProjectMemberUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    projectId?: StringFieldUpdateOperationsInput | string
    role?: EnumProjectMemberRoleFieldUpdateOperationsInput | $Enums.ProjectMemberRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProjectMemberUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    projectId?: StringFieldUpdateOperationsInput | string
    role?: EnumProjectMemberRoleFieldUpdateOperationsInput | $Enums.ProjectMemberRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProjectUpdateUpdateWithoutAuthorInput = {
    id?: StringFieldUpdateOperationsInput | string
    notes?: StringFieldUpdateOperationsInput | string
    statusSnapshot?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    project?: ProjectUpdateOneRequiredWithoutUpdatesNestedInput
    media?: MediaUpdateManyWithoutProjectUpdateNestedInput
  }

  export type ProjectUpdateUncheckedUpdateWithoutAuthorInput = {
    id?: StringFieldUpdateOperationsInput | string
    projectId?: StringFieldUpdateOperationsInput | string
    notes?: StringFieldUpdateOperationsInput | string
    statusSnapshot?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    media?: MediaUncheckedUpdateManyWithoutProjectUpdateNestedInput
  }

  export type ProjectUpdateUncheckedUpdateManyWithoutAuthorInput = {
    id?: StringFieldUpdateOperationsInput | string
    projectId?: StringFieldUpdateOperationsInput | string
    notes?: StringFieldUpdateOperationsInput | string
    statusSnapshot?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MediaUpdateWithoutCreatedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumMediaTypeFieldUpdateOperationsInput | $Enums.MediaType
    fileKey?: StringFieldUpdateOperationsInput | string
    fileUrl?: StringFieldUpdateOperationsInput | string
    mimeType?: StringFieldUpdateOperationsInput | string
    fileSize?: IntFieldUpdateOperationsInput | number
    approvedBy?: NullableStringFieldUpdateOperationsInput | string | null
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    version?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    project?: ProjectUpdateOneRequiredWithoutMediaNestedInput
    projectUpdate?: ProjectUpdateUpdateOneWithoutMediaNestedInput
    payment?: PaymentUpdateOneWithoutMediaNestedInput
    inspectionResponses?: InspectionResponseUpdateManyWithoutMediaNestedInput
    query?: QueryUpdateOneWithoutAttachmentsNestedInput
  }

  export type MediaUncheckedUpdateWithoutCreatedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    projectId?: StringFieldUpdateOperationsInput | string
    projectUpdateId?: NullableStringFieldUpdateOperationsInput | string | null
    paymentId?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumMediaTypeFieldUpdateOperationsInput | $Enums.MediaType
    fileKey?: StringFieldUpdateOperationsInput | string
    fileUrl?: StringFieldUpdateOperationsInput | string
    mimeType?: StringFieldUpdateOperationsInput | string
    fileSize?: IntFieldUpdateOperationsInput | number
    approvedBy?: NullableStringFieldUpdateOperationsInput | string | null
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    version?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    queryId?: NullableStringFieldUpdateOperationsInput | string | null
    inspectionResponses?: InspectionResponseUncheckedUpdateManyWithoutMediaNestedInput
  }

  export type MediaUncheckedUpdateManyWithoutCreatedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    projectId?: StringFieldUpdateOperationsInput | string
    projectUpdateId?: NullableStringFieldUpdateOperationsInput | string | null
    paymentId?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumMediaTypeFieldUpdateOperationsInput | $Enums.MediaType
    fileKey?: StringFieldUpdateOperationsInput | string
    fileUrl?: StringFieldUpdateOperationsInput | string
    mimeType?: StringFieldUpdateOperationsInput | string
    fileSize?: IntFieldUpdateOperationsInput | number
    approvedBy?: NullableStringFieldUpdateOperationsInput | string | null
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    version?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    queryId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PaymentUpdateWithoutCreatedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    status?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    category?: NullableEnumPaymentCategoryFieldUpdateOperationsInput | $Enums.PaymentCategory | null
    invoiceNumber?: NullableStringFieldUpdateOperationsInput | string | null
    paidAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    project?: ProjectUpdateOneRequiredWithoutPaymentsNestedInput
    media?: MediaUpdateManyWithoutPaymentNestedInput
  }

  export type PaymentUncheckedUpdateWithoutCreatedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    projectId?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    status?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    category?: NullableEnumPaymentCategoryFieldUpdateOperationsInput | $Enums.PaymentCategory | null
    invoiceNumber?: NullableStringFieldUpdateOperationsInput | string | null
    paidAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    media?: MediaUncheckedUpdateManyWithoutPaymentNestedInput
  }

  export type PaymentUncheckedUpdateManyWithoutCreatedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    projectId?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    status?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    category?: NullableEnumPaymentCategoryFieldUpdateOperationsInput | $Enums.PaymentCategory | null
    invoiceNumber?: NullableStringFieldUpdateOperationsInput | string | null
    paidAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    priority?: EnumNotificationPriorityFieldUpdateOperationsInput | $Enums.NotificationPriority
    actionUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isRead?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    priority?: EnumNotificationPriorityFieldUpdateOperationsInput | $Enums.NotificationPriority
    actionUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isRead?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    priority?: EnumNotificationPriorityFieldUpdateOperationsInput | $Enums.NotificationPriority
    actionUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isRead?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProjectUpdateWithoutCreatedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumProjectStatusFieldUpdateOperationsInput | $Enums.ProjectStatus
    isArchived?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    manager?: UserUpdateOneRequiredWithoutManagedProjectsNestedInput
    client?: UserUpdateOneRequiredWithoutClientProjectsNestedInput
    members?: ProjectMemberUpdateManyWithoutProjectNestedInput
    updates?: ProjectUpdateUpdateManyWithoutProjectNestedInput
    media?: MediaUpdateManyWithoutProjectNestedInput
    payments?: PaymentUpdateManyWithoutProjectNestedInput
    milestones?: MilestoneUpdateManyWithoutProjectNestedInput
    inspections?: InspectionUpdateManyWithoutProjectNestedInput
    queries?: QueryUpdateManyWithoutProjectNestedInput
    materials?: MaterialUpdateManyWithoutProjectNestedInput
    auditLogs?: AuditLogUpdateManyWithoutProjectNestedInput
  }

  export type ProjectUncheckedUpdateWithoutCreatedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumProjectStatusFieldUpdateOperationsInput | $Enums.ProjectStatus
    isArchived?: BoolFieldUpdateOperationsInput | boolean
    managerId?: StringFieldUpdateOperationsInput | string
    clientId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    members?: ProjectMemberUncheckedUpdateManyWithoutProjectNestedInput
    updates?: ProjectUpdateUncheckedUpdateManyWithoutProjectNestedInput
    media?: MediaUncheckedUpdateManyWithoutProjectNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutProjectNestedInput
    milestones?: MilestoneUncheckedUpdateManyWithoutProjectNestedInput
    inspections?: InspectionUncheckedUpdateManyWithoutProjectNestedInput
    queries?: QueryUncheckedUpdateManyWithoutProjectNestedInput
    materials?: MaterialUncheckedUpdateManyWithoutProjectNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutProjectNestedInput
  }

  export type ProjectUncheckedUpdateManyWithoutCreatedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumProjectStatusFieldUpdateOperationsInput | $Enums.ProjectStatus
    isArchived?: BoolFieldUpdateOperationsInput | boolean
    managerId?: StringFieldUpdateOperationsInput | string
    clientId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InspectionUpdateWithoutEngineerInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumInspectionStatusFieldUpdateOperationsInput | $Enums.InspectionStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    project?: ProjectUpdateOneRequiredWithoutInspectionsNestedInput
    milestone?: MilestoneUpdateOneRequiredWithoutInspectionsNestedInput
    responses?: InspectionResponseUpdateManyWithoutInspectionNestedInput
    reviewedBy?: UserUpdateOneWithoutReviewedInspectionsNestedInput
  }

  export type InspectionUncheckedUpdateWithoutEngineerInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumInspectionStatusFieldUpdateOperationsInput | $Enums.InspectionStatus
    projectId?: StringFieldUpdateOperationsInput | string
    milestoneId?: StringFieldUpdateOperationsInput | string
    reviewedById?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    responses?: InspectionResponseUncheckedUpdateManyWithoutInspectionNestedInput
  }

  export type InspectionUncheckedUpdateManyWithoutEngineerInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumInspectionStatusFieldUpdateOperationsInput | $Enums.InspectionStatus
    projectId?: StringFieldUpdateOperationsInput | string
    milestoneId?: StringFieldUpdateOperationsInput | string
    reviewedById?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InspectionUpdateWithoutReviewedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumInspectionStatusFieldUpdateOperationsInput | $Enums.InspectionStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    project?: ProjectUpdateOneRequiredWithoutInspectionsNestedInput
    milestone?: MilestoneUpdateOneRequiredWithoutInspectionsNestedInput
    engineer?: UserUpdateOneRequiredWithoutInspectionsNestedInput
    responses?: InspectionResponseUpdateManyWithoutInspectionNestedInput
  }

  export type InspectionUncheckedUpdateWithoutReviewedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumInspectionStatusFieldUpdateOperationsInput | $Enums.InspectionStatus
    projectId?: StringFieldUpdateOperationsInput | string
    milestoneId?: StringFieldUpdateOperationsInput | string
    engineerId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    responses?: InspectionResponseUncheckedUpdateManyWithoutInspectionNestedInput
  }

  export type InspectionUncheckedUpdateManyWithoutReviewedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumInspectionStatusFieldUpdateOperationsInput | $Enums.InspectionStatus
    projectId?: StringFieldUpdateOperationsInput | string
    milestoneId?: StringFieldUpdateOperationsInput | string
    engineerId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type QueryUpdateWithoutAuthorInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    status?: EnumQueryStatusFieldUpdateOperationsInput | $Enums.QueryStatus
    priority?: EnumQueryPriorityFieldUpdateOperationsInput | $Enums.QueryPriority
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    project?: ProjectUpdateOneRequiredWithoutQueriesNestedInput
    attachments?: MediaUpdateManyWithoutQueryNestedInput
    responses?: QueryResponseUpdateManyWithoutQueryNestedInput
  }

  export type QueryUncheckedUpdateWithoutAuthorInput = {
    id?: StringFieldUpdateOperationsInput | string
    projectId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    status?: EnumQueryStatusFieldUpdateOperationsInput | $Enums.QueryStatus
    priority?: EnumQueryPriorityFieldUpdateOperationsInput | $Enums.QueryPriority
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    attachments?: MediaUncheckedUpdateManyWithoutQueryNestedInput
    responses?: QueryResponseUncheckedUpdateManyWithoutQueryNestedInput
  }

  export type QueryUncheckedUpdateManyWithoutAuthorInput = {
    id?: StringFieldUpdateOperationsInput | string
    projectId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    status?: EnumQueryStatusFieldUpdateOperationsInput | $Enums.QueryStatus
    priority?: EnumQueryPriorityFieldUpdateOperationsInput | $Enums.QueryPriority
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type QueryResponseUpdateWithoutAuthorInput = {
    id?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    query?: QueryUpdateOneRequiredWithoutResponsesNestedInput
  }

  export type QueryResponseUncheckedUpdateWithoutAuthorInput = {
    id?: StringFieldUpdateOperationsInput | string
    queryId?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type QueryResponseUncheckedUpdateManyWithoutAuthorInput = {
    id?: StringFieldUpdateOperationsInput | string
    queryId?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditLogUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    entity?: StringFieldUpdateOperationsInput | string
    entityId?: StringFieldUpdateOperationsInput | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    project?: ProjectUpdateOneWithoutAuditLogsNestedInput
  }

  export type AuditLogUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    entity?: StringFieldUpdateOperationsInput | string
    entityId?: StringFieldUpdateOperationsInput | string
    projectId?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditLogUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    entity?: StringFieldUpdateOperationsInput | string
    entityId?: StringFieldUpdateOperationsInput | string
    projectId?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MaterialUpdateWithoutCreatedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    quantity?: FloatFieldUpdateOperationsInput | number
    unit?: StringFieldUpdateOperationsInput | string
    unitCost?: FloatFieldUpdateOperationsInput | number
    totalCost?: FloatFieldUpdateOperationsInput | number
    supplier?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumMaterialStatusFieldUpdateOperationsInput | $Enums.MaterialStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    project?: ProjectUpdateOneRequiredWithoutMaterialsNestedInput
  }

  export type MaterialUncheckedUpdateWithoutCreatedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    projectId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    quantity?: FloatFieldUpdateOperationsInput | number
    unit?: StringFieldUpdateOperationsInput | string
    unitCost?: FloatFieldUpdateOperationsInput | number
    totalCost?: FloatFieldUpdateOperationsInput | number
    supplier?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumMaterialStatusFieldUpdateOperationsInput | $Enums.MaterialStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MaterialUncheckedUpdateManyWithoutCreatedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    projectId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    quantity?: FloatFieldUpdateOperationsInput | number
    unit?: StringFieldUpdateOperationsInput | string
    unitCost?: FloatFieldUpdateOperationsInput | number
    totalCost?: FloatFieldUpdateOperationsInput | number
    supplier?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumMaterialStatusFieldUpdateOperationsInput | $Enums.MaterialStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProjectMemberCreateManyProjectInput = {
    id?: string
    userId: string
    role: $Enums.ProjectMemberRole
    createdAt?: Date | string
  }

  export type ProjectUpdateCreateManyProjectInput = {
    id?: string
    authorId: string
    notes: string
    statusSnapshot?: string | null
    createdAt?: Date | string
  }

  export type MediaCreateManyProjectInput = {
    id?: string
    projectUpdateId?: string | null
    paymentId?: string | null
    type: $Enums.MediaType
    fileKey: string
    fileUrl: string
    mimeType: string
    fileSize: number
    createdById: string
    approvedBy?: string | null
    approvedAt?: Date | string | null
    version?: number | null
    createdAt?: Date | string
    queryId?: string | null
  }

  export type PaymentCreateManyProjectInput = {
    id?: string
    createdById: string
    amount: Decimal | DecimalJsLike | number | string
    currency?: string
    status?: $Enums.PaymentStatus
    category?: $Enums.PaymentCategory | null
    invoiceNumber?: string | null
    paidAt?: Date | string | null
    dueDate?: Date | string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MilestoneCreateManyProjectInput = {
    id?: string
    name: string
    description?: string | null
    order: number
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type InspectionCreateManyProjectInput = {
    id?: string
    status?: $Enums.InspectionStatus
    milestoneId: string
    engineerId: string
    reviewedById?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type QueryCreateManyProjectInput = {
    id?: string
    authorId: string
    title: string
    description: string
    status?: $Enums.QueryStatus
    priority?: $Enums.QueryPriority
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MaterialCreateManyProjectInput = {
    id?: string
    name: string
    quantity: number
    unit: string
    unitCost: number
    totalCost: number
    supplier?: string | null
    status?: $Enums.MaterialStatus
    createdById: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AuditLogCreateManyProjectInput = {
    id?: string
    userId: string
    action: string
    entity: string
    entityId: string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type ProjectMemberUpdateWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: EnumProjectMemberRoleFieldUpdateOperationsInput | $Enums.ProjectMemberRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutProjectMembersNestedInput
  }

  export type ProjectMemberUncheckedUpdateWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    role?: EnumProjectMemberRoleFieldUpdateOperationsInput | $Enums.ProjectMemberRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProjectMemberUncheckedUpdateManyWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    role?: EnumProjectMemberRoleFieldUpdateOperationsInput | $Enums.ProjectMemberRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProjectUpdateUpdateWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    notes?: StringFieldUpdateOperationsInput | string
    statusSnapshot?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    author?: UserUpdateOneRequiredWithoutProjectUpdatesNestedInput
    media?: MediaUpdateManyWithoutProjectUpdateNestedInput
  }

  export type ProjectUpdateUncheckedUpdateWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    authorId?: StringFieldUpdateOperationsInput | string
    notes?: StringFieldUpdateOperationsInput | string
    statusSnapshot?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    media?: MediaUncheckedUpdateManyWithoutProjectUpdateNestedInput
  }

  export type ProjectUpdateUncheckedUpdateManyWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    authorId?: StringFieldUpdateOperationsInput | string
    notes?: StringFieldUpdateOperationsInput | string
    statusSnapshot?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MediaUpdateWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumMediaTypeFieldUpdateOperationsInput | $Enums.MediaType
    fileKey?: StringFieldUpdateOperationsInput | string
    fileUrl?: StringFieldUpdateOperationsInput | string
    mimeType?: StringFieldUpdateOperationsInput | string
    fileSize?: IntFieldUpdateOperationsInput | number
    approvedBy?: NullableStringFieldUpdateOperationsInput | string | null
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    version?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    projectUpdate?: ProjectUpdateUpdateOneWithoutMediaNestedInput
    payment?: PaymentUpdateOneWithoutMediaNestedInput
    createdBy?: UserUpdateOneRequiredWithoutMediaNestedInput
    inspectionResponses?: InspectionResponseUpdateManyWithoutMediaNestedInput
    query?: QueryUpdateOneWithoutAttachmentsNestedInput
  }

  export type MediaUncheckedUpdateWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    projectUpdateId?: NullableStringFieldUpdateOperationsInput | string | null
    paymentId?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumMediaTypeFieldUpdateOperationsInput | $Enums.MediaType
    fileKey?: StringFieldUpdateOperationsInput | string
    fileUrl?: StringFieldUpdateOperationsInput | string
    mimeType?: StringFieldUpdateOperationsInput | string
    fileSize?: IntFieldUpdateOperationsInput | number
    createdById?: StringFieldUpdateOperationsInput | string
    approvedBy?: NullableStringFieldUpdateOperationsInput | string | null
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    version?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    queryId?: NullableStringFieldUpdateOperationsInput | string | null
    inspectionResponses?: InspectionResponseUncheckedUpdateManyWithoutMediaNestedInput
  }

  export type MediaUncheckedUpdateManyWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    projectUpdateId?: NullableStringFieldUpdateOperationsInput | string | null
    paymentId?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumMediaTypeFieldUpdateOperationsInput | $Enums.MediaType
    fileKey?: StringFieldUpdateOperationsInput | string
    fileUrl?: StringFieldUpdateOperationsInput | string
    mimeType?: StringFieldUpdateOperationsInput | string
    fileSize?: IntFieldUpdateOperationsInput | number
    createdById?: StringFieldUpdateOperationsInput | string
    approvedBy?: NullableStringFieldUpdateOperationsInput | string | null
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    version?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    queryId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PaymentUpdateWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    status?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    category?: NullableEnumPaymentCategoryFieldUpdateOperationsInput | $Enums.PaymentCategory | null
    invoiceNumber?: NullableStringFieldUpdateOperationsInput | string | null
    paidAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: UserUpdateOneRequiredWithoutPaymentsCreatedNestedInput
    media?: MediaUpdateManyWithoutPaymentNestedInput
  }

  export type PaymentUncheckedUpdateWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdById?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    status?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    category?: NullableEnumPaymentCategoryFieldUpdateOperationsInput | $Enums.PaymentCategory | null
    invoiceNumber?: NullableStringFieldUpdateOperationsInput | string | null
    paidAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    media?: MediaUncheckedUpdateManyWithoutPaymentNestedInput
  }

  export type PaymentUncheckedUpdateManyWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdById?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    status?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    category?: NullableEnumPaymentCategoryFieldUpdateOperationsInput | $Enums.PaymentCategory | null
    invoiceNumber?: NullableStringFieldUpdateOperationsInput | string | null
    paidAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MilestoneUpdateWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    order?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    checklistItems?: ChecklistItemUpdateManyWithoutMilestoneNestedInput
    inspections?: InspectionUpdateManyWithoutMilestoneNestedInput
  }

  export type MilestoneUncheckedUpdateWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    order?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    checklistItems?: ChecklistItemUncheckedUpdateManyWithoutMilestoneNestedInput
    inspections?: InspectionUncheckedUpdateManyWithoutMilestoneNestedInput
  }

  export type MilestoneUncheckedUpdateManyWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    order?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InspectionUpdateWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumInspectionStatusFieldUpdateOperationsInput | $Enums.InspectionStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    milestone?: MilestoneUpdateOneRequiredWithoutInspectionsNestedInput
    engineer?: UserUpdateOneRequiredWithoutInspectionsNestedInput
    responses?: InspectionResponseUpdateManyWithoutInspectionNestedInput
    reviewedBy?: UserUpdateOneWithoutReviewedInspectionsNestedInput
  }

  export type InspectionUncheckedUpdateWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumInspectionStatusFieldUpdateOperationsInput | $Enums.InspectionStatus
    milestoneId?: StringFieldUpdateOperationsInput | string
    engineerId?: StringFieldUpdateOperationsInput | string
    reviewedById?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    responses?: InspectionResponseUncheckedUpdateManyWithoutInspectionNestedInput
  }

  export type InspectionUncheckedUpdateManyWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumInspectionStatusFieldUpdateOperationsInput | $Enums.InspectionStatus
    milestoneId?: StringFieldUpdateOperationsInput | string
    engineerId?: StringFieldUpdateOperationsInput | string
    reviewedById?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type QueryUpdateWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    status?: EnumQueryStatusFieldUpdateOperationsInput | $Enums.QueryStatus
    priority?: EnumQueryPriorityFieldUpdateOperationsInput | $Enums.QueryPriority
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    author?: UserUpdateOneRequiredWithoutQueriesNestedInput
    attachments?: MediaUpdateManyWithoutQueryNestedInput
    responses?: QueryResponseUpdateManyWithoutQueryNestedInput
  }

  export type QueryUncheckedUpdateWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    authorId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    status?: EnumQueryStatusFieldUpdateOperationsInput | $Enums.QueryStatus
    priority?: EnumQueryPriorityFieldUpdateOperationsInput | $Enums.QueryPriority
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    attachments?: MediaUncheckedUpdateManyWithoutQueryNestedInput
    responses?: QueryResponseUncheckedUpdateManyWithoutQueryNestedInput
  }

  export type QueryUncheckedUpdateManyWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    authorId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    status?: EnumQueryStatusFieldUpdateOperationsInput | $Enums.QueryStatus
    priority?: EnumQueryPriorityFieldUpdateOperationsInput | $Enums.QueryPriority
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MaterialUpdateWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    quantity?: FloatFieldUpdateOperationsInput | number
    unit?: StringFieldUpdateOperationsInput | string
    unitCost?: FloatFieldUpdateOperationsInput | number
    totalCost?: FloatFieldUpdateOperationsInput | number
    supplier?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumMaterialStatusFieldUpdateOperationsInput | $Enums.MaterialStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: UserUpdateOneRequiredWithoutMaterialsCreatedNestedInput
  }

  export type MaterialUncheckedUpdateWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    quantity?: FloatFieldUpdateOperationsInput | number
    unit?: StringFieldUpdateOperationsInput | string
    unitCost?: FloatFieldUpdateOperationsInput | number
    totalCost?: FloatFieldUpdateOperationsInput | number
    supplier?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumMaterialStatusFieldUpdateOperationsInput | $Enums.MaterialStatus
    createdById?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MaterialUncheckedUpdateManyWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    quantity?: FloatFieldUpdateOperationsInput | number
    unit?: StringFieldUpdateOperationsInput | string
    unitCost?: FloatFieldUpdateOperationsInput | number
    totalCost?: FloatFieldUpdateOperationsInput | number
    supplier?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumMaterialStatusFieldUpdateOperationsInput | $Enums.MaterialStatus
    createdById?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditLogUpdateWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    entity?: StringFieldUpdateOperationsInput | string
    entityId?: StringFieldUpdateOperationsInput | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutAuditLogsNestedInput
  }

  export type AuditLogUncheckedUpdateWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    entity?: StringFieldUpdateOperationsInput | string
    entityId?: StringFieldUpdateOperationsInput | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditLogUncheckedUpdateManyWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    entity?: StringFieldUpdateOperationsInput | string
    entityId?: StringFieldUpdateOperationsInput | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MediaCreateManyProjectUpdateInput = {
    id?: string
    projectId: string
    paymentId?: string | null
    type: $Enums.MediaType
    fileKey: string
    fileUrl: string
    mimeType: string
    fileSize: number
    createdById: string
    approvedBy?: string | null
    approvedAt?: Date | string | null
    version?: number | null
    createdAt?: Date | string
    queryId?: string | null
  }

  export type MediaUpdateWithoutProjectUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumMediaTypeFieldUpdateOperationsInput | $Enums.MediaType
    fileKey?: StringFieldUpdateOperationsInput | string
    fileUrl?: StringFieldUpdateOperationsInput | string
    mimeType?: StringFieldUpdateOperationsInput | string
    fileSize?: IntFieldUpdateOperationsInput | number
    approvedBy?: NullableStringFieldUpdateOperationsInput | string | null
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    version?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    project?: ProjectUpdateOneRequiredWithoutMediaNestedInput
    payment?: PaymentUpdateOneWithoutMediaNestedInput
    createdBy?: UserUpdateOneRequiredWithoutMediaNestedInput
    inspectionResponses?: InspectionResponseUpdateManyWithoutMediaNestedInput
    query?: QueryUpdateOneWithoutAttachmentsNestedInput
  }

  export type MediaUncheckedUpdateWithoutProjectUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    projectId?: StringFieldUpdateOperationsInput | string
    paymentId?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumMediaTypeFieldUpdateOperationsInput | $Enums.MediaType
    fileKey?: StringFieldUpdateOperationsInput | string
    fileUrl?: StringFieldUpdateOperationsInput | string
    mimeType?: StringFieldUpdateOperationsInput | string
    fileSize?: IntFieldUpdateOperationsInput | number
    createdById?: StringFieldUpdateOperationsInput | string
    approvedBy?: NullableStringFieldUpdateOperationsInput | string | null
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    version?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    queryId?: NullableStringFieldUpdateOperationsInput | string | null
    inspectionResponses?: InspectionResponseUncheckedUpdateManyWithoutMediaNestedInput
  }

  export type MediaUncheckedUpdateManyWithoutProjectUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    projectId?: StringFieldUpdateOperationsInput | string
    paymentId?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumMediaTypeFieldUpdateOperationsInput | $Enums.MediaType
    fileKey?: StringFieldUpdateOperationsInput | string
    fileUrl?: StringFieldUpdateOperationsInput | string
    mimeType?: StringFieldUpdateOperationsInput | string
    fileSize?: IntFieldUpdateOperationsInput | number
    createdById?: StringFieldUpdateOperationsInput | string
    approvedBy?: NullableStringFieldUpdateOperationsInput | string | null
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    version?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    queryId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type InspectionResponseCreateManyMediaInput = {
    id?: string
    result: $Enums.ChecklistResult
    remark?: string | null
    inspectionId: string
    checklistItemId: string
  }

  export type InspectionResponseUpdateWithoutMediaInput = {
    id?: StringFieldUpdateOperationsInput | string
    result?: EnumChecklistResultFieldUpdateOperationsInput | $Enums.ChecklistResult
    remark?: NullableStringFieldUpdateOperationsInput | string | null
    inspection?: InspectionUpdateOneRequiredWithoutResponsesNestedInput
    checklistItem?: ChecklistItemUpdateOneRequiredWithoutResponsesNestedInput
  }

  export type InspectionResponseUncheckedUpdateWithoutMediaInput = {
    id?: StringFieldUpdateOperationsInput | string
    result?: EnumChecklistResultFieldUpdateOperationsInput | $Enums.ChecklistResult
    remark?: NullableStringFieldUpdateOperationsInput | string | null
    inspectionId?: StringFieldUpdateOperationsInput | string
    checklistItemId?: StringFieldUpdateOperationsInput | string
  }

  export type InspectionResponseUncheckedUpdateManyWithoutMediaInput = {
    id?: StringFieldUpdateOperationsInput | string
    result?: EnumChecklistResultFieldUpdateOperationsInput | $Enums.ChecklistResult
    remark?: NullableStringFieldUpdateOperationsInput | string | null
    inspectionId?: StringFieldUpdateOperationsInput | string
    checklistItemId?: StringFieldUpdateOperationsInput | string
  }

  export type MediaCreateManyPaymentInput = {
    id?: string
    projectId: string
    projectUpdateId?: string | null
    type: $Enums.MediaType
    fileKey: string
    fileUrl: string
    mimeType: string
    fileSize: number
    createdById: string
    approvedBy?: string | null
    approvedAt?: Date | string | null
    version?: number | null
    createdAt?: Date | string
    queryId?: string | null
  }

  export type MediaUpdateWithoutPaymentInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumMediaTypeFieldUpdateOperationsInput | $Enums.MediaType
    fileKey?: StringFieldUpdateOperationsInput | string
    fileUrl?: StringFieldUpdateOperationsInput | string
    mimeType?: StringFieldUpdateOperationsInput | string
    fileSize?: IntFieldUpdateOperationsInput | number
    approvedBy?: NullableStringFieldUpdateOperationsInput | string | null
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    version?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    project?: ProjectUpdateOneRequiredWithoutMediaNestedInput
    projectUpdate?: ProjectUpdateUpdateOneWithoutMediaNestedInput
    createdBy?: UserUpdateOneRequiredWithoutMediaNestedInput
    inspectionResponses?: InspectionResponseUpdateManyWithoutMediaNestedInput
    query?: QueryUpdateOneWithoutAttachmentsNestedInput
  }

  export type MediaUncheckedUpdateWithoutPaymentInput = {
    id?: StringFieldUpdateOperationsInput | string
    projectId?: StringFieldUpdateOperationsInput | string
    projectUpdateId?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumMediaTypeFieldUpdateOperationsInput | $Enums.MediaType
    fileKey?: StringFieldUpdateOperationsInput | string
    fileUrl?: StringFieldUpdateOperationsInput | string
    mimeType?: StringFieldUpdateOperationsInput | string
    fileSize?: IntFieldUpdateOperationsInput | number
    createdById?: StringFieldUpdateOperationsInput | string
    approvedBy?: NullableStringFieldUpdateOperationsInput | string | null
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    version?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    queryId?: NullableStringFieldUpdateOperationsInput | string | null
    inspectionResponses?: InspectionResponseUncheckedUpdateManyWithoutMediaNestedInput
  }

  export type MediaUncheckedUpdateManyWithoutPaymentInput = {
    id?: StringFieldUpdateOperationsInput | string
    projectId?: StringFieldUpdateOperationsInput | string
    projectUpdateId?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumMediaTypeFieldUpdateOperationsInput | $Enums.MediaType
    fileKey?: StringFieldUpdateOperationsInput | string
    fileUrl?: StringFieldUpdateOperationsInput | string
    mimeType?: StringFieldUpdateOperationsInput | string
    fileSize?: IntFieldUpdateOperationsInput | number
    createdById?: StringFieldUpdateOperationsInput | string
    approvedBy?: NullableStringFieldUpdateOperationsInput | string | null
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    version?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    queryId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ChecklistItemCreateManyMilestoneInput = {
    id?: string
    title: string
    description?: string | null
    order: number
    isRequired?: boolean
    isPhotoRequired?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type InspectionCreateManyMilestoneInput = {
    id?: string
    status?: $Enums.InspectionStatus
    projectId: string
    engineerId: string
    reviewedById?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ChecklistItemUpdateWithoutMilestoneInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    order?: IntFieldUpdateOperationsInput | number
    isRequired?: BoolFieldUpdateOperationsInput | boolean
    isPhotoRequired?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    responses?: InspectionResponseUpdateManyWithoutChecklistItemNestedInput
  }

  export type ChecklistItemUncheckedUpdateWithoutMilestoneInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    order?: IntFieldUpdateOperationsInput | number
    isRequired?: BoolFieldUpdateOperationsInput | boolean
    isPhotoRequired?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    responses?: InspectionResponseUncheckedUpdateManyWithoutChecklistItemNestedInput
  }

  export type ChecklistItemUncheckedUpdateManyWithoutMilestoneInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    order?: IntFieldUpdateOperationsInput | number
    isRequired?: BoolFieldUpdateOperationsInput | boolean
    isPhotoRequired?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InspectionUpdateWithoutMilestoneInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumInspectionStatusFieldUpdateOperationsInput | $Enums.InspectionStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    project?: ProjectUpdateOneRequiredWithoutInspectionsNestedInput
    engineer?: UserUpdateOneRequiredWithoutInspectionsNestedInput
    responses?: InspectionResponseUpdateManyWithoutInspectionNestedInput
    reviewedBy?: UserUpdateOneWithoutReviewedInspectionsNestedInput
  }

  export type InspectionUncheckedUpdateWithoutMilestoneInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumInspectionStatusFieldUpdateOperationsInput | $Enums.InspectionStatus
    projectId?: StringFieldUpdateOperationsInput | string
    engineerId?: StringFieldUpdateOperationsInput | string
    reviewedById?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    responses?: InspectionResponseUncheckedUpdateManyWithoutInspectionNestedInput
  }

  export type InspectionUncheckedUpdateManyWithoutMilestoneInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumInspectionStatusFieldUpdateOperationsInput | $Enums.InspectionStatus
    projectId?: StringFieldUpdateOperationsInput | string
    engineerId?: StringFieldUpdateOperationsInput | string
    reviewedById?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InspectionResponseCreateManyChecklistItemInput = {
    id?: string
    result: $Enums.ChecklistResult
    remark?: string | null
    inspectionId: string
    mediaId?: string | null
  }

  export type InspectionResponseUpdateWithoutChecklistItemInput = {
    id?: StringFieldUpdateOperationsInput | string
    result?: EnumChecklistResultFieldUpdateOperationsInput | $Enums.ChecklistResult
    remark?: NullableStringFieldUpdateOperationsInput | string | null
    inspection?: InspectionUpdateOneRequiredWithoutResponsesNestedInput
    media?: MediaUpdateOneWithoutInspectionResponsesNestedInput
  }

  export type InspectionResponseUncheckedUpdateWithoutChecklistItemInput = {
    id?: StringFieldUpdateOperationsInput | string
    result?: EnumChecklistResultFieldUpdateOperationsInput | $Enums.ChecklistResult
    remark?: NullableStringFieldUpdateOperationsInput | string | null
    inspectionId?: StringFieldUpdateOperationsInput | string
    mediaId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type InspectionResponseUncheckedUpdateManyWithoutChecklistItemInput = {
    id?: StringFieldUpdateOperationsInput | string
    result?: EnumChecklistResultFieldUpdateOperationsInput | $Enums.ChecklistResult
    remark?: NullableStringFieldUpdateOperationsInput | string | null
    inspectionId?: StringFieldUpdateOperationsInput | string
    mediaId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type InspectionResponseCreateManyInspectionInput = {
    id?: string
    result: $Enums.ChecklistResult
    remark?: string | null
    checklistItemId: string
    mediaId?: string | null
  }

  export type InspectionResponseUpdateWithoutInspectionInput = {
    id?: StringFieldUpdateOperationsInput | string
    result?: EnumChecklistResultFieldUpdateOperationsInput | $Enums.ChecklistResult
    remark?: NullableStringFieldUpdateOperationsInput | string | null
    checklistItem?: ChecklistItemUpdateOneRequiredWithoutResponsesNestedInput
    media?: MediaUpdateOneWithoutInspectionResponsesNestedInput
  }

  export type InspectionResponseUncheckedUpdateWithoutInspectionInput = {
    id?: StringFieldUpdateOperationsInput | string
    result?: EnumChecklistResultFieldUpdateOperationsInput | $Enums.ChecklistResult
    remark?: NullableStringFieldUpdateOperationsInput | string | null
    checklistItemId?: StringFieldUpdateOperationsInput | string
    mediaId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type InspectionResponseUncheckedUpdateManyWithoutInspectionInput = {
    id?: StringFieldUpdateOperationsInput | string
    result?: EnumChecklistResultFieldUpdateOperationsInput | $Enums.ChecklistResult
    remark?: NullableStringFieldUpdateOperationsInput | string | null
    checklistItemId?: StringFieldUpdateOperationsInput | string
    mediaId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type MediaCreateManyQueryInput = {
    id?: string
    projectId: string
    projectUpdateId?: string | null
    paymentId?: string | null
    type: $Enums.MediaType
    fileKey: string
    fileUrl: string
    mimeType: string
    fileSize: number
    createdById: string
    approvedBy?: string | null
    approvedAt?: Date | string | null
    version?: number | null
    createdAt?: Date | string
  }

  export type QueryResponseCreateManyQueryInput = {
    id?: string
    authorId: string
    message: string
    createdAt?: Date | string
  }

  export type MediaUpdateWithoutQueryInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumMediaTypeFieldUpdateOperationsInput | $Enums.MediaType
    fileKey?: StringFieldUpdateOperationsInput | string
    fileUrl?: StringFieldUpdateOperationsInput | string
    mimeType?: StringFieldUpdateOperationsInput | string
    fileSize?: IntFieldUpdateOperationsInput | number
    approvedBy?: NullableStringFieldUpdateOperationsInput | string | null
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    version?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    project?: ProjectUpdateOneRequiredWithoutMediaNestedInput
    projectUpdate?: ProjectUpdateUpdateOneWithoutMediaNestedInput
    payment?: PaymentUpdateOneWithoutMediaNestedInput
    createdBy?: UserUpdateOneRequiredWithoutMediaNestedInput
    inspectionResponses?: InspectionResponseUpdateManyWithoutMediaNestedInput
  }

  export type MediaUncheckedUpdateWithoutQueryInput = {
    id?: StringFieldUpdateOperationsInput | string
    projectId?: StringFieldUpdateOperationsInput | string
    projectUpdateId?: NullableStringFieldUpdateOperationsInput | string | null
    paymentId?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumMediaTypeFieldUpdateOperationsInput | $Enums.MediaType
    fileKey?: StringFieldUpdateOperationsInput | string
    fileUrl?: StringFieldUpdateOperationsInput | string
    mimeType?: StringFieldUpdateOperationsInput | string
    fileSize?: IntFieldUpdateOperationsInput | number
    createdById?: StringFieldUpdateOperationsInput | string
    approvedBy?: NullableStringFieldUpdateOperationsInput | string | null
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    version?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    inspectionResponses?: InspectionResponseUncheckedUpdateManyWithoutMediaNestedInput
  }

  export type MediaUncheckedUpdateManyWithoutQueryInput = {
    id?: StringFieldUpdateOperationsInput | string
    projectId?: StringFieldUpdateOperationsInput | string
    projectUpdateId?: NullableStringFieldUpdateOperationsInput | string | null
    paymentId?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumMediaTypeFieldUpdateOperationsInput | $Enums.MediaType
    fileKey?: StringFieldUpdateOperationsInput | string
    fileUrl?: StringFieldUpdateOperationsInput | string
    mimeType?: StringFieldUpdateOperationsInput | string
    fileSize?: IntFieldUpdateOperationsInput | number
    createdById?: StringFieldUpdateOperationsInput | string
    approvedBy?: NullableStringFieldUpdateOperationsInput | string | null
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    version?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type QueryResponseUpdateWithoutQueryInput = {
    id?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    author?: UserUpdateOneRequiredWithoutQueryResponsesNestedInput
  }

  export type QueryResponseUncheckedUpdateWithoutQueryInput = {
    id?: StringFieldUpdateOperationsInput | string
    authorId?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type QueryResponseUncheckedUpdateManyWithoutQueryInput = {
    id?: StringFieldUpdateOperationsInput | string
    authorId?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}